package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

// Options configures the generator
type Options struct {
	Verbose    bool
	TestOnly   bool
	StructOnly bool
}

// Generator generates Go code from a spec
type Generator struct {
	spec    *Spec
	options Options
}

// Result represents a generated file
type Result struct {
	Filename  string
	Content   string
	Overwrite bool
}

// New creates a new generator
func New(spec *Spec, options Options) *Generator {
	return &Generator{
		spec:    spec,
		options: options,
	}
}

// Generate generates all code from the spec
func (g *Generator) Generate() ([]Result, error) {
	var results []Result

	if !g.options.StructOnly {
		// Generate test file
		testResult, err := g.generateTestFile()
		if err != nil {
			return nil, fmt.Errorf("generating test file: %w", err)
		}
		results = append(results, testResult)
	}

	if !g.options.TestOnly && len(g.spec.Command.Terraform.StructAdditions) > 0 {
		// Generate struct additions file (for review, not auto-merge)
		structResult, err := g.generateStructAdditions()
		if err != nil {
			return nil, fmt.Errorf("generating struct additions: %w", err)
		}
		results = append(results, structResult)
	}

	return results, nil
}

// generateTestFile generates the test file
func (g *Generator) generateTestFile() (Result, error) {
	tmpl, err := template.New("test").Funcs(template.FuncMap{
		"toCamelCase":   toCamelCase,
		"toSnakeCase":   toSnakeCase,
		"formatValue":   formatValue,
		"formatStruct":  g.formatStruct,
		"quoteIfString": quoteIfString,
	}).Parse(testTemplate)
	if err != nil {
		return Result{}, fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, g.spec); err != nil {
		return Result{}, fmt.Errorf("executing template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code for debugging
		return Result{
			Filename:  fmt.Sprintf("%s_spec_test.go", toSnakeCase(g.spec.Command.Name)),
			Content:   buf.String(),
			Overwrite: true,
		}, nil
	}

	return Result{
		Filename:  fmt.Sprintf("%s_spec_test.go", toSnakeCase(g.spec.Command.Name)),
		Content:   string(formatted),
		Overwrite: true,
	}, nil
}

// generateStructAdditions generates the struct additions review file
func (g *Generator) generateStructAdditions() (Result, error) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by specgen. DO NOT EDIT.\n")
	buf.WriteString("// This file contains struct field additions that need to be manually merged.\n\n")
	buf.WriteString(fmt.Sprintf("// Spec: %s\n", g.spec.Command.Name))
	buf.WriteString(fmt.Sprintf("// Description: %s\n\n", g.spec.Command.Description))

	for structName, fields := range g.spec.Command.Terraform.StructAdditions {
		buf.WriteString(fmt.Sprintf("// Add these fields to %s struct:\n", structName))
		buf.WriteString(fmt.Sprintf("// type %s struct {\n", structName))
		buf.WriteString("//     // ... existing fields ...\n")
		for _, field := range fields {
			buf.WriteString(fmt.Sprintf("//     %s %s `json:\"%s\"` // %s\n",
				field.Name, field.Type, field.JSONTag, field.Description))
		}
		buf.WriteString("// }\n\n")
	}

	return Result{
		Filename:  fmt.Sprintf("%s_struct_additions.txt", toSnakeCase(g.spec.Command.Name)),
		Content:   buf.String(),
		Overwrite: true,
	}, nil
}

// formatStruct formats a terraform value as a Go struct literal
func (g *Generator) formatStruct(terraform interface{}) string {
	switch v := terraform.(type) {
	case map[string]interface{}:
		return g.formatMapAsStruct(v)
	case []interface{}:
		// Array of structs
		var parts []string
		for _, item := range v {
			if m, ok := item.(map[string]interface{}); ok {
				parts = append(parts, g.formatMapAsStruct(m))
			}
		}
		return strings.Join(parts, ",\n")
	default:
		return fmt.Sprintf("%#v", terraform)
	}
}

func (g *Generator) formatMapAsStruct(m map[string]interface{}) string {
	structName := g.spec.Command.Terraform.StructName
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("%s{\n", structName))

	// Order fields consistently
	fieldOrder := []string{
		"scope_id", "network", "range_start", "range_end",
		"lease_time", "max_lease_time", "exclude_ranges", "options",
	}

	for _, key := range fieldOrder {
		if val, ok := m[key]; ok {
			fieldName := toCamelCase(key)
			buf.WriteString(fmt.Sprintf("\t%s: %s,\n", fieldName, formatValue(val)))
		}
	}

	// Handle any remaining fields not in fieldOrder
	for key, val := range m {
		found := false
		for _, ordered := range fieldOrder {
			if key == ordered {
				found = true
				break
			}
		}
		if !found {
			fieldName := toCamelCase(key)
			buf.WriteString(fmt.Sprintf("\t%s: %s,\n", fieldName, formatValue(val)))
		}
	}

	buf.WriteString("}")
	return buf.String()
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			// Handle common abbreviations
			upper := strings.ToUpper(part)
			if upper == "ID" || upper == "IP" || upper == "DNS" || upper == "URL" {
				parts[i] = upper
			} else {
				parts[i] = strings.ToUpper(part[:1]) + part[1:]
			}
		}
	}
	return strings.Join(parts, "")
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func formatValue(v interface{}) string {
	switch val := v.(type) {
	case string:
		return fmt.Sprintf("%q", val)
	case int, int64, float64:
		return fmt.Sprintf("%v", val)
	case bool:
		return fmt.Sprintf("%v", val)
	case nil:
		return "nil"
	case []interface{}:
		if len(val) == 0 {
			return "[]ExcludeRange{}"
		}
		// Check if it's a string slice
		isStringSlice := true
		for _, item := range val {
			if _, ok := item.(string); !ok {
				isStringSlice = false
				break
			}
		}
		if isStringSlice {
			var parts []string
			for _, item := range val {
				parts = append(parts, fmt.Sprintf("%q", item))
			}
			return fmt.Sprintf("[]string{%s}", strings.Join(parts, ", "))
		}
		// Handle struct slices (like ExcludeRanges)
		var parts []string
		for _, item := range val {
			if m, ok := item.(map[string]interface{}); ok {
				parts = append(parts, formatExcludeRange(m))
			}
		}
		return fmt.Sprintf("[]ExcludeRange{%s}", strings.Join(parts, ", "))
	case map[string]interface{}:
		// Handle nested structs (like Options)
		return formatOptions(val)
	default:
		return fmt.Sprintf("%#v", val)
	}
}

func formatExcludeRange(m map[string]interface{}) string {
	start, _ := m["start"].(string)
	end, _ := m["end"].(string)
	return fmt.Sprintf("{Start: %q, End: %q}", start, end)
}

func formatOptions(m map[string]interface{}) string {
	var parts []string

	if dns, ok := m["dns_servers"].([]interface{}); ok && len(dns) > 0 {
		var servers []string
		for _, s := range dns {
			servers = append(servers, fmt.Sprintf("%q", s))
		}
		parts = append(parts, fmt.Sprintf("DNSServers: []string{%s}", strings.Join(servers, ", ")))
	}

	if routers, ok := m["routers"].([]interface{}); ok && len(routers) > 0 {
		var addrs []string
		for _, r := range routers {
			addrs = append(addrs, fmt.Sprintf("%q", r))
		}
		parts = append(parts, fmt.Sprintf("Routers: []string{%s}", strings.Join(addrs, ", ")))
	}

	if domain, ok := m["domain_name"].(string); ok && domain != "" {
		parts = append(parts, fmt.Sprintf("DomainName: %q", domain))
	}

	if len(parts) == 0 {
		return "DHCPScopeOptions{}"
	}
	return fmt.Sprintf("DHCPScopeOptions{%s}", strings.Join(parts, ", "))
}

func quoteIfString(v interface{}) string {
	if s, ok := v.(string); ok {
		return fmt.Sprintf("%q", s)
	}
	return fmt.Sprintf("%v", v)
}

const testTemplate = `// Code generated by specgen. DO NOT EDIT.
// Source: specs/dhcp/scope.yaml
// Command: {{.Command.Name}}
// Reference: {{.Command.Reference}}

package parsers

import (
	"reflect"
	"testing"
)

// TestSpec{{toCamelCase .Command.Name}}Parse tests parsing of {{.Command.Name}} commands from spec
func TestSpec{{toCamelCase .Command.Name}}Parse(t *testing.T) {
	parser := NewDHCPScopeParser()

	tests := []struct {
		name     string
		input    string
		expected []DHCPScope
		skip     string // reason to skip, empty if not skipped
	}{
{{- range .Command.SyntaxTests}}
{{- if not .BuildOnly}}
{{- if not .Note}}
		{
			name:  "{{.Name}}",
			input: ` + "`" + `{{.RTX}}` + "`" + `,
			expected: []DHCPScope{
				{{formatStruct .Terraform}},
			},
		},
{{- end}}
{{- end}}
{{- end}}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.skip != "" {
				t.Skip(tt.skip)
			}

			result, err := parser.ParseScopeConfig(tt.input)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if len(result) != len(tt.expected) {
				t.Fatalf("expected %d scopes, got %d", len(tt.expected), len(result))
			}

			// Create map for easier comparison (order may vary)
			resultMap := make(map[int]DHCPScope)
			for _, s := range result {
				resultMap[s.ScopeID] = s
			}

			for _, expected := range tt.expected {
				got, ok := resultMap[expected.ScopeID]
				if !ok {
					t.Errorf("scope %d not found in result", expected.ScopeID)
					continue
				}

				if got.Network != expected.Network {
					t.Errorf("Network: got %q, want %q", got.Network, expected.Network)
				}
				if got.RangeStart != expected.RangeStart {
					t.Errorf("RangeStart: got %q, want %q", got.RangeStart, expected.RangeStart)
				}
				if got.RangeEnd != expected.RangeEnd {
					t.Errorf("RangeEnd: got %q, want %q", got.RangeEnd, expected.RangeEnd)
				}
				if got.LeaseTime != expected.LeaseTime {
					t.Errorf("LeaseTime: got %q, want %q", got.LeaseTime, expected.LeaseTime)
				}
				// Compare Options
				if !reflect.DeepEqual(got.Options.DNSServers, expected.Options.DNSServers) {
					t.Errorf("Options.DNSServers: got %v, want %v", got.Options.DNSServers, expected.Options.DNSServers)
				}
				if !reflect.DeepEqual(got.Options.Routers, expected.Options.Routers) {
					t.Errorf("Options.Routers: got %v, want %v", got.Options.Routers, expected.Options.Routers)
				}
				if got.Options.DomainName != expected.Options.DomainName {
					t.Errorf("Options.DomainName: got %q, want %q", got.Options.DomainName, expected.Options.DomainName)
				}
				// Compare ExcludeRanges
				if len(got.ExcludeRanges) != len(expected.ExcludeRanges) {
					t.Errorf("ExcludeRanges count: got %d, want %d", len(got.ExcludeRanges), len(expected.ExcludeRanges))
				}
			}
		})
	}
}

// TestSpec{{toCamelCase .Command.Name}}Build tests building of {{.Command.Name}} commands from spec
func TestSpec{{toCamelCase .Command.Name}}Build(t *testing.T) {
	tests := []struct {
		name     string
		scope    DHCPScope
		expected string
		skip     string
	}{
{{- range .Command.SyntaxTests}}
{{- if not .ParseOnly}}
{{- if not .BuildOnly}}
{{- if not .Note}}
		{
			name:  "{{.Name}}",
			scope: {{formatStruct .Terraform}},
			expected: ` + "`" + `{{.RTX}}` + "`" + `,
		},
{{- end}}
{{- end}}
{{- end}}
{{- end}}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.skip != "" {
				t.Skip(tt.skip)
			}

			result := BuildDHCPScopeCommand(tt.scope)
			if result != tt.expected {
				t.Errorf("BuildDHCPScopeCommand() = %q, want %q", result, tt.expected)
			}
		})
	}
}
`
