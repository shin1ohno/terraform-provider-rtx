package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

// Options configures the generator
type Options struct {
	Verbose    bool
	TestOnly   bool
	StructOnly bool
}

// Generator generates Go code from a spec
type Generator struct {
	spec    *Spec
	options Options
}

// Result represents a generated file
type Result struct {
	Filename  string
	Content   string
	Overwrite bool
}

// New creates a new generator
func New(spec *Spec, options Options) *Generator {
	return &Generator{
		spec:    spec,
		options: options,
	}
}

// Generate generates all code from the spec
func (g *Generator) Generate() ([]Result, error) {
	var results []Result

	if !g.options.StructOnly {
		// Generate test file
		testResult, err := g.generateTestFile()
		if err != nil {
			return nil, fmt.Errorf("generating test file: %w", err)
		}
		results = append(results, testResult)
	}

	if !g.options.TestOnly && len(g.spec.Command.Terraform.StructAdditions) > 0 {
		// Generate struct additions file (for review, not auto-merge)
		structResult, err := g.generateStructAdditions()
		if err != nil {
			return nil, fmt.Errorf("generating struct additions: %w", err)
		}
		results = append(results, structResult)
	}

	return results, nil
}

// generateTestFile generates the test file
func (g *Generator) generateTestFile() (Result, error) {
	tmpl, err := template.New("test").Funcs(template.FuncMap{
		"toCamelCase":   toCamelCase,
		"toSnakeCase":   toSnakeCase,
		"formatValue":   formatValue,
		"formatStruct":  g.formatStruct,
		"quoteIfString": quoteIfString,
	}).Parse(testTemplate)
	if err != nil {
		return Result{}, fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, g.spec); err != nil {
		return Result{}, fmt.Errorf("executing template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code for debugging
		return Result{
			Filename:  fmt.Sprintf("%s_spec_test.go", toSnakeCase(g.spec.Command.Name)),
			Content:   buf.String(),
			Overwrite: true,
		}, nil
	}

	return Result{
		Filename:  fmt.Sprintf("%s_spec_test.go", toSnakeCase(g.spec.Command.Name)),
		Content:   string(formatted),
		Overwrite: true,
	}, nil
}

// generateStructAdditions generates the struct additions review file
func (g *Generator) generateStructAdditions() (Result, error) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by specgen. DO NOT EDIT.\n")
	buf.WriteString("// This file contains struct field additions that need to be manually merged.\n\n")
	buf.WriteString(fmt.Sprintf("// Spec: %s\n", g.spec.Command.Name))
	buf.WriteString(fmt.Sprintf("// Description: %s\n\n", g.spec.Command.Description))

	for structName, fields := range g.spec.Command.Terraform.StructAdditions {
		buf.WriteString(fmt.Sprintf("// Add these fields to %s struct:\n", structName))
		buf.WriteString(fmt.Sprintf("// type %s struct {\n", structName))
		buf.WriteString("//     // ... existing fields ...\n")
		for _, field := range fields {
			buf.WriteString(fmt.Sprintf("//     %s %s `json:\"%s\"` // %s\n",
				field.Name, field.Type, field.JSONTag, field.Description))
		}
		buf.WriteString("// }\n\n")
	}

	return Result{
		Filename:  fmt.Sprintf("%s_struct_additions.txt", toSnakeCase(g.spec.Command.Name)),
		Content:   buf.String(),
		Overwrite: true,
	}, nil
}

// formatStruct formats a terraform value as a Go struct literal
func (g *Generator) formatStruct(terraform interface{}) string {
	switch v := terraform.(type) {
	case map[string]interface{}:
		return g.formatMapAsStruct(v)
	case []interface{}:
		// Array of structs
		var parts []string
		for _, item := range v {
			if m, ok := item.(map[string]interface{}); ok {
				parts = append(parts, g.formatMapAsStruct(m))
			}
		}
		return strings.Join(parts, ",\n")
	default:
		return fmt.Sprintf("%#v", terraform)
	}
}

func (g *Generator) formatMapAsStruct(m map[string]interface{}) string {
	structName := g.spec.Command.Terraform.StructName
	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("%s{\n", structName))

	// Order fields consistently
	fieldOrder := []string{
		"scope_id", "network", "range_start", "range_end",
		"lease_time", "max_lease_time", "exclude_ranges", "options",
	}

	for _, key := range fieldOrder {
		if val, ok := m[key]; ok {
			fieldName := toCamelCase(key)
			buf.WriteString(fmt.Sprintf("\t%s: %s,\n", fieldName, formatValue(val)))
		}
	}

	// Handle any remaining fields not in fieldOrder
	for key, val := range m {
		found := false
		for _, ordered := range fieldOrder {
			if key == ordered {
				found = true
				break
			}
		}
		if !found {
			fieldName := toCamelCase(key)
			buf.WriteString(fmt.Sprintf("\t%s: %s,\n", fieldName, formatValue(val)))
		}
	}

	buf.WriteString("}")
	return buf.String()
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			// Handle common abbreviations
			upper := strings.ToUpper(part)
			if upper == "ID" || upper == "IP" || upper == "DNS" || upper == "URL" {
				parts[i] = upper
			} else {
				parts[i] = strings.ToUpper(part[:1]) + part[1:]
			}
		}
	}
	return strings.Join(parts, "")
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func formatValue(v interface{}) string {
	switch val := v.(type) {
	case string:
		return fmt.Sprintf("%q", val)
	case int, int64, float64:
		return fmt.Sprintf("%v", val)
	case bool:
		return fmt.Sprintf("%v", val)
	case nil:
		return "nil"
	case []interface{}:
		if len(val) == 0 {
			return "[]ExcludeRange{}"
		}
		// Check if it's a string slice
		isStringSlice := true
		for _, item := range val {
			if _, ok := item.(string); !ok {
				isStringSlice = false
				break
			}
		}
		if isStringSlice {
			var parts []string
			for _, item := range val {
				parts = append(parts, fmt.Sprintf("%q", item))
			}
			return fmt.Sprintf("[]string{%s}", strings.Join(parts, ", "))
		}
		// Handle struct slices (like ExcludeRanges)
		var parts []string
		for _, item := range val {
			if m, ok := item.(map[string]interface{}); ok {
				parts = append(parts, formatExcludeRange(m))
			}
		}
		return fmt.Sprintf("[]ExcludeRange{%s}", strings.Join(parts, ", "))
	case map[string]interface{}:
		// Handle nested structs (like Options)
		return formatOptions(val)
	default:
		return fmt.Sprintf("%#v", val)
	}
}

func formatExcludeRange(m map[string]interface{}) string {
	start, _ := m["start"].(string)
	end, _ := m["end"].(string)
	return fmt.Sprintf("{Start: %q, End: %q}", start, end)
}

func formatOptions(m map[string]interface{}) string {
	var parts []string

	if dns, ok := m["dns_servers"].([]interface{}); ok && len(dns) > 0 {
		var servers []string
		for _, s := range dns {
			servers = append(servers, fmt.Sprintf("%q", s))
		}
		parts = append(parts, fmt.Sprintf("DNSServers: []string{%s}", strings.Join(servers, ", ")))
	}

	if routers, ok := m["routers"].([]interface{}); ok && len(routers) > 0 {
		var addrs []string
		for _, r := range routers {
			addrs = append(addrs, fmt.Sprintf("%q", r))
		}
		parts = append(parts, fmt.Sprintf("Routers: []string{%s}", strings.Join(addrs, ", ")))
	}

	if domain, ok := m["domain_name"].(string); ok && domain != "" {
		parts = append(parts, fmt.Sprintf("DomainName: %q", domain))
	}

	if len(parts) == 0 {
		return "DHCPScopeOptions{}"
	}
	return fmt.Sprintf("DHCPScopeOptions{%s}", strings.Join(parts, ", "))
}

func quoteIfString(v interface{}) string {
	if s, ok := v.(string); ok {
		return fmt.Sprintf("%q", s)
	}
	return fmt.Sprintf("%v", v)
}

const testTemplate = `// Code generated by specgen. DO NOT EDIT.
// Source: specs/{{.Command.Name}}.yaml
// Command: {{.Command.Name}}
// Reference: {{.Command.Reference}}

package parsers

import (
	"testing"
)

// TestSpec{{toCamelCase .Command.Name}}SyntaxCoverage documents the syntax patterns covered by this spec
func TestSpec{{toCamelCase .Command.Name}}SyntaxCoverage(t *testing.T) {
	// This test documents all syntax patterns defined in the spec
	// Each pattern should have corresponding implementation in the parser

	syntaxPatterns := []struct {
		name        string
		rtxCommand  string
		parseOnly   bool
		buildOnly   bool
		description string
	}{
{{- range .Command.SyntaxTests}}
		{
			name:        "{{.Name}}",
			rtxCommand:  ` + "`" + `{{.RTX}}` + "`" + `,
			parseOnly:   {{.ParseOnly}},
			buildOnly:   {{.BuildOnly}},
			description: "{{.Description}}",
		},
{{- end}}
	}

	t.Logf("Total syntax patterns: %d", len(syntaxPatterns))

	parseOnlyCount := 0
	buildOnlyCount := 0
	bidirectionalCount := 0

	for _, p := range syntaxPatterns {
		if p.parseOnly {
			parseOnlyCount++
		} else if p.buildOnly {
			buildOnlyCount++
		} else {
			bidirectionalCount++
		}
	}

	t.Logf("Parse-only patterns: %d", parseOnlyCount)
	t.Logf("Build-only patterns: %d", buildOnlyCount)
	t.Logf("Bidirectional patterns: %d", bidirectionalCount)
}

// TestSpec{{toCamelCase .Command.Name}}BoundaryCoverage documents the boundary values covered by this spec
func TestSpec{{toCamelCase .Command.Name}}BoundaryCoverage(t *testing.T) {
	// This test documents all boundary value tests defined in the spec
	boundaryParams := []string{
{{- range $param, $tests := .Command.BoundaryTests}}
		"{{$param}}",
{{- end}}
	}

	t.Logf("Parameters with boundary tests: %d", len(boundaryParams))
	for _, param := range boundaryParams {
		t.Logf("  - %s", param)
	}
}

// TestSpec{{toCamelCase .Command.Name}}ModelCompatibility tests router model compatibility
func TestSpec{{toCamelCase .Command.Name}}ModelCompatibility(t *testing.T) {
	// All known RTX router models
	allModels := []string{
		"vRX",
		"RTX5000",
		"RTX3510",
		"RTX3500",
		"RTX1300",
		"RTX1220",
		"RTX1210",
		"RTX840",
		"RTX830",
		"RTX810",
		"NVR700W",
		"NVR510",
		"NVR500",
	}

	// Models that support this command according to the spec
	supportedModels := []string{
{{- range .Command.ApplicableModels}}
		"{{.}}",
{{- end}}
	}

	// Build a map for quick lookup
	supportedMap := make(map[string]bool)
	for _, m := range supportedModels {
		supportedMap[m] = true
	}

	// Find unsupported models
	var unsupportedModels []string
	for _, m := range allModels {
		if !supportedMap[m] {
			unsupportedModels = append(unsupportedModels, m)
		}
	}

	t.Logf("Command: {{.Command.Name}}")
	t.Logf("Supported models (%d): %v", len(supportedModels), supportedModels)
	t.Logf("Unsupported models (%d): %v", len(unsupportedModels), unsupportedModels)

	// Test: Verify supported models are recognized
	for _, model := range supportedModels {
		t.Run("supported_"+model, func(t *testing.T) {
			if !IsModelSupported("{{.Command.Name}}", model) {
				t.Errorf("Model %s should be supported for {{.Command.Name}}", model)
			}
		})
	}

	// Test: Verify unsupported models are rejected
	for _, model := range unsupportedModels {
		t.Run("unsupported_"+model, func(t *testing.T) {
			if IsModelSupported("{{.Command.Name}}", model) {
				t.Errorf("Model %s should NOT be supported for {{.Command.Name}}", model)
			}
		})
	}
}
`
