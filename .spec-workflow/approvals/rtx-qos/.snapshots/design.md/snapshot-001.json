{
  "id": "snapshot_1768799800672_b06pya95g",
  "approvalId": "approval_1768799800666_qs6uxzcwm",
  "approvalTitle": "Design: rtx_qos resource",
  "version": 1,
  "timestamp": "2026-01-19T05:16:40.671Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: rtx_qos\n\n## Overview\n\nThe `rtx_qos` resource enables Terraform-based management of QoS (Quality of Service) and traffic shaping on Yamaha RTX series routers. Following Cisco MQC (Modular QoS CLI) naming patterns, this resource manages traffic classification, priority queuing, bandwidth allocation, and traffic shaping.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`internal/client/dhcp_scope_service.go`**: Pattern for service layer implementation with CRUD operations.\n- **`internal/client/interfaces.go`**: Extend the `Client` interface with QoS methods.\n- **`internal/rtx/parsers/dhcp_scope.go`**: Reference for parser implementation and command builders.\n- **`internal/provider/resource_rtx_dhcp_scope.go`**: Template for Terraform resource structure.\n\n### Integration Points\n\n- **`rtxClient`**: Add QoS methods for CRUD operations\n- **`Executor`**: Use existing SSH command execution infrastructure\n- **Interface configuration**: Coordinate with interface settings\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph Provider Layer\n        TFResource[resource_rtx_qos.go]\n    end\n\n    subgraph Client Layer\n        Client[client.go - Interface Extension]\n        QoSService[qos_service.go]\n    end\n\n    subgraph Parser Layer\n        QoSParser[qos.go]\n        Commands[Command Builders]\n        OutputParser[Output Parsers]\n    end\n\n    TFResource --> Client\n    Client --> QoSService\n    QoSService --> QoSParser\n    QoSParser --> Commands\n    QoSParser --> OutputParser\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: `QoSService` handles all QoS CRUD operations\n- **Component Isolation**: Parser, service, and resource layers clearly separated\n- **Service Layer Separation**: Service encapsulates all QoS logic\n- **Utility Modularity**: Shared validation functions for bandwidth/class operations\n\n## Components and Interfaces\n\n### Component 1: QoSService (`internal/client/qos_service.go`)\n\n- **Purpose:** Handles all QoS CRUD operations against the RTX router\n- **Interfaces:**\n  ```go\n  type QoSService struct {\n      executor Executor\n      client   *rtxClient\n  }\n\n  func (s *QoSService) Create(ctx context.Context, qos QoSConfig) error\n  func (s *QoSService) Get(ctx context.Context, iface string) (*QoSConfig, error)\n  func (s *QoSService) Update(ctx context.Context, qos QoSConfig) error\n  func (s *QoSService) Delete(ctx context.Context, iface string) error\n  func (s *QoSService) List(ctx context.Context) ([]QoSConfig, error)\n  ```\n- **Dependencies:** `Executor`, `rtxClient`, `parsers.QoSParser`\n- **Reuses:** Pattern from service layer implementations\n\n### Component 2: QoSParser (`internal/rtx/parsers/qos.go`)\n\n- **Purpose:** Parses RTX router output for QoS configuration and builds commands\n- **Interfaces:**\n  ```go\n  type QoSConfig struct {\n      Interface     string        `json:\"interface\"`\n      QueueType     string        `json:\"queue_type\"`  // priority, cbq, etc.\n      Classes       []QoSClass    `json:\"classes\"`\n      ShapeAverage  int           `json:\"shape_average,omitempty\"`\n      ShapeBurst    int           `json:\"shape_burst,omitempty\"`\n  }\n\n  type QoSClass struct {\n      Name             string `json:\"name\"`\n      Filter           int    `json:\"filter,omitempty\"`\n      Priority         string `json:\"priority,omitempty\"`\n      BandwidthPercent int    `json:\"bandwidth_percent,omitempty\"`\n      PoliceCIR        int    `json:\"police_cir,omitempty\"`\n      QueueLimit       int    `json:\"queue_limit,omitempty\"`\n  }\n\n  func ParseQoSConfig(raw string) ([]QoSConfig, error)\n  func BuildQueueTypeCommand(iface, qType string) string\n  func BuildQueueClassFilterCommand(iface string, class QoSClass) string\n  func BuildQueueClassPriorityCommand(iface, className, priority string) string\n  func BuildSpeedCommand(iface string, bandwidth int) string\n  func BuildQueueLengthCommand(iface, className string, length int) string\n  func BuildDeleteQoSCommand(iface string) string\n  ```\n- **Dependencies:** `regexp`, `strings`, `strconv`\n- **Reuses:** Bandwidth validation patterns\n\n### Component 3: Terraform Resource (`internal/provider/resource_rtx_qos.go`)\n\n- **Purpose:** Terraform resource definition implementing CRUD lifecycle\n- **Interfaces:**\n  ```go\n  func resourceRTXQoS() *schema.Resource\n  func resourceRTXQoSCreate(ctx, d, meta) diag.Diagnostics\n  func resourceRTXQoSRead(ctx, d, meta) diag.Diagnostics\n  func resourceRTXQoSUpdate(ctx, d, meta) diag.Diagnostics\n  func resourceRTXQoSDelete(ctx, d, meta) diag.Diagnostics\n  func resourceRTXQoSImport(ctx, d, meta) ([]*schema.ResourceData, error)\n  ```\n- **Dependencies:** `Client`, `QoSConfig`, Terraform SDK\n- **Reuses:** Resource patterns from other implementations\n\n### Component 4: Client Interface Extension (`internal/client/interfaces.go`)\n\n- **Purpose:** Extend Client interface with QoS methods\n- **Interfaces:**\n  ```go\n  // Add to existing Client interface:\n  GetQoS(ctx context.Context, iface string) (*QoSConfig, error)\n  CreateQoS(ctx context.Context, qos QoSConfig) error\n  UpdateQoS(ctx context.Context, qos QoSConfig) error\n  DeleteQoS(ctx context.Context, iface string) error\n  ListQoS(ctx context.Context) ([]QoSConfig, error)\n  ```\n- **Dependencies:** Existing Client interface\n- **Reuses:** Pattern from existing methods\n\n## Data Models\n\n### QoSConfig\n\n```go\n// QoSConfig represents QoS configuration on an RTX router interface\ntype QoSConfig struct {\n    Interface    string     `json:\"interface\"`     // Interface name\n    QueueType    string     `json:\"queue_type\"`    // priority, cbq, etc.\n    Classes      []QoSClass `json:\"classes\"`       // Traffic classes\n    ShapeAverage int        `json:\"shape_average\"` // Average rate bps\n    ShapeBurst   int        `json:\"shape_burst\"`   // Burst size bps\n}\n\n// QoSClass represents a traffic class in QoS policy\ntype QoSClass struct {\n    Name             string `json:\"name\"`              // Class name\n    Filter           int    `json:\"filter,omitempty\"`  // IP filter number\n    Priority         string `json:\"priority\"`          // high/medium/normal/low\n    BandwidthPercent int    `json:\"bandwidth_percent\"` // % of interface bandwidth\n    PoliceCIR        int    `json:\"police_cir\"`        // Committed rate bps\n    QueueLimit       int    `json:\"queue_limit\"`       // Queue depth\n}\n```\n\n### Terraform Schema\n\n```hcl\n# Class map - define traffic classification\nresource \"rtx_class_map\" \"voip\" {\n  name = \"VOIP\"\n\n  match_protocol         = \"udp\"\n  match_destination_port = [\"5060\", \"10000-20000\"]\n}\n\nresource \"rtx_class_map\" \"web\" {\n  name = \"WEB\"\n\n  match_protocol         = \"tcp\"\n  match_destination_port = [\"80\", \"443\"]\n}\n\n# Policy map - define QoS policy\nresource \"rtx_policy_map\" \"wan_qos\" {\n  name = \"WAN_QOS\"\n\n  class {\n    name     = \"VOIP\"\n    priority = true\n    police_cir = 1000000  # 1 Mbps\n  }\n\n  class {\n    name              = \"WEB\"\n    bandwidth_percent = 30\n  }\n\n  class {\n    name              = \"class-default\"\n    bandwidth_percent = 20\n    queue_limit       = 64\n  }\n}\n\n# Apply policy to interface\nresource \"rtx_service_policy\" \"wan\" {\n  interface  = \"pp1\"\n  direction  = \"output\"\n  policy_map = \"WAN_QOS\"\n}\n\n# Traffic shaping\nresource \"rtx_shape\" \"upload_limit\" {\n  interface     = \"lan1\"\n  direction     = \"output\"\n  shape_average = 50000000  # 50 Mbps\n  shape_burst   = 1000000   # 1 Mbps burst\n}\n```\n\n## RTX Command Mapping\n\n### Configure Queue Type\n\n```\nqueue <interface> type priority\nqueue <interface> type cbq\n```\n\n### Configure Class Filter\n\n```\nqueue <interface> class filter <n> <filter>\n```\n\nExample: `queue pp1 class filter 1 100`\n\n### Configure Class Priority\n\n```\nqueue <interface> class priority <class> <priority>\n```\n\nExample: `queue pp1 class priority 1 high`\n\n### Configure Interface Speed/Shaping\n\n```\nspeed <interface> <bandwidth>\n```\n\nExample: `speed pp1 50m`\n\n### Configure Queue Length\n\n```\nqueue <interface> length <class> <length>\n```\n\n### Delete QoS Configuration\n\n```\nno queue <interface>\n```\n\n### Show Configuration\n\n```\nshow config | grep queue\nshow queue <interface>\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid Interface**\n   - **Handling:** Validate interface exists\n   - **User Impact:** Clear error indicating invalid interface\n\n2. **Invalid Queue Type**\n   - **Handling:** Validate queue type is supported\n   - **User Impact:** Error with valid types\n\n3. **Invalid Priority**\n   - **Handling:** Validate priority is high/medium/normal/low\n   - **User Impact:** Clear error with valid values\n\n4. **Invalid Bandwidth**\n   - **Handling:** Validate bandwidth is positive integer\n   - **User Impact:** Clear error with expected format\n\n5. **Bandwidth Sum Exceeds 100%**\n   - **Handling:** Validate class bandwidth doesn't exceed 100%\n   - **User Impact:** Clear validation error\n\n6. **Connection/Command Timeout**\n   - **Handling:** Use existing retry logic from `rtxClient`\n   - **User Impact:** Standard Terraform timeout error\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Parser Tests** (`qos_test.go`):\n  - Parse various RTX `show config` output for QoS\n  - Test command builder functions with different parameters\n  - Test bandwidth calculations\n\n- **Service Tests** (`qos_service_test.go`):\n  - Mock executor for service method testing\n  - Test error handling for various failure scenarios\n  - Test class configuration\n\n### Integration Testing\n\n- **Resource Tests** (`resource_rtx_qos_test.go`):\n  - Full CRUD lifecycle with mock client\n  - Import functionality testing\n  - Multi-class configuration testing\n\n### End-to-End Testing\n\n- **Acceptance Tests** (with real RTX router):\n  - Create QoS with priority queuing\n  - Configure traffic shaping\n  - Update class settings\n  - Delete QoS configuration\n  - Import existing QoS\n\n## File Structure\n\n```\ninternal/\n├── provider/\n│   ├── resource_rtx_qos.go      # NEW: Terraform resource\n│   └── resource_rtx_qos_test.go # NEW: Resource tests\n├── client/\n│   ├── interfaces.go             # MODIFY: Add QoS types and methods\n│   ├── client.go                 # MODIFY: Add QoS service initialization\n│   ├── qos_service.go           # NEW: QoS service implementation\n│   └── qos_service_test.go      # NEW: Service tests\n└── rtx/\n    └── parsers/\n        ├── qos.go               # NEW: Parser and command builders\n        └── qos_test.go          # NEW: Parser tests\n```\n\n## Implementation Notes\n\n1. **Per-Interface Resource**: QoS is configured per interface. Terraform ID is the interface name.\n\n2. **Class Map vs Policy Map**: Consider whether to implement as separate resources or combined (RTX style).\n\n3. **Bandwidth Units**: RTX accepts m (mega), k (kilo), etc. suffixes. Normalize in parsing.\n\n4. **Filter Association**: Classes are associated with IP filters for classification.\n\n5. **Priority Queuing**: Four priority levels - high, medium, normal, low.\n\n6. **Shaping vs Policing**: Shaping smooths traffic; policing drops excess. Consider as separate attributes.\n\n7. **ForceNew**: Interface is ForceNew. Other attributes support in-place updates.\n\n8. **Dependency**: Classes depend on IP filters being configured first.\n\n9. **Configuration Save**: Use existing `SaveConfig()` pattern after modifications.\n\n10. **Provider Registration**: Add `resourceRTXQoS` to provider's resource map.\n\n11. **Multiple Resources**: Consider implementing as class_map, policy_map, and service_policy for Cisco compatibility.\n",
  "fileStats": {
    "size": 11455,
    "lines": 371,
    "lastModified": "2026-01-19T05:14:43.066Z"
  },
  "comments": []
}