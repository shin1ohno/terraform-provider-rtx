{
  "id": "snapshot_1769441856986_9x6pz9tzw",
  "approvalId": "approval_1769441750828_tvsetskoh",
  "approvalTitle": "Design: Unified ACL Apply Design",
  "version": 2,
  "timestamp": "2026-01-26T15:37:36.986Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Unified ACL Apply Design\n\n## Overview\n\nThis design document describes the technical implementation of the unified ACL pattern across all ACL types in the Terraform RTX provider. The implementation introduces:\n\n1. A common ACL schema with `name`, `sequence_start`, `sequence_step`, `entry`, and `apply` attributes\n2. Automatic sequence calculation based on entry definition order\n3. Multiple `apply` blocks for interface binding\n4. Sequence collision detection at Plan and Apply time\n5. Removal of ACL attributes from interface resources\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **Language**: Go 1.23 with terraform-plugin-sdk/v2\n- **Logging**: Zerolog for structured logging\n- **SSH Communication**: Existing SSH client infrastructure via `internal/client`\n- **Parser Registry**: Extend existing parser pattern in `internal/rtx/parsers`\n\n### Project Structure (structure.md)\n\nFollowing the established patterns:\n- Resources: `internal/provider/resource_rtx_*.go`\n- Services: `internal/client/*_service.go`\n- Parsers: `internal/rtx/parsers/*.go`\n- Tests: `*_test.go` alongside implementation files\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`resource_rtx_access_list_mac.go`**: Reference implementation for `apply` block pattern\n- **`ethernet_filter_service.go`**: MAC filter service with apply logic to extend\n- **`ip_filter_service.go`**: IP filter service to extend with apply logic\n- **`parsers/access_list_*.go`**: Existing parsers to extend for group-based parsing\n- **`interfaces.go`**: Interface configuration structures (to remove ACL attributes)\n\n### Integration Points\n\n- **RTXClient**: Add unified ACL service methods\n- **SSH Session**: Reuse existing command execution infrastructure\n- **SFTP Cache**: Leverage for efficient state reading\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Terraform Provider\"\n        R1[rtx_access_list_mac]\n        R2[rtx_access_list_extended]\n        R3[rtx_access_list_ip]\n        R4[rtx_access_list_ipv6]\n        R5[rtx_access_list_ip_apply]\n    end\n\n    subgraph \"Shared Components\"\n        SC[acl_schema_common.go]\n        SQ[sequence_calculator.go]\n        CV[collision_validator.go]\n    end\n\n    subgraph \"Service Layer\"\n        AS[acl_service.go]\n        APS[acl_apply_service.go]\n    end\n\n    subgraph \"Parser Layer\"\n        P1[parsers/access_list_common.go]\n        P2[parsers/interface_filter.go]\n    end\n\n    subgraph \"RTX Router\"\n        RTX[SSH/CLI]\n    end\n\n    R1 --> SC\n    R2 --> SC\n    R3 --> SC\n    R4 --> SC\n    R5 --> SC\n    SC --> SQ\n    SC --> CV\n\n    R1 --> AS\n    R2 --> AS\n    R3 --> AS\n    R4 --> AS\n    R5 --> APS\n\n    AS --> P1\n    APS --> P2\n    AS --> RTX\n    APS --> RTX\n```\n\n## Components and Interfaces\n\n### Component 1: ACL Schema Common (`acl_schema_common.go`)\n\n**Purpose:** Provide shared schema definitions and helper functions for all ACL resources\n\n**Location:** `internal/provider/acl_schema_common.go`\n\n**Interfaces:**\n```go\n// CommonACLSchema returns shared schema attributes for all ACL types\nfunc CommonACLSchema() map[string]*schema.Schema\n\n// CommonApplySchema returns the schema for apply blocks\nfunc CommonApplySchema() *schema.Resource\n\n// CommonEntrySchema returns base schema for entry blocks (ACL-specific fields added by each resource)\nfunc CommonEntrySchema() map[string]*schema.Schema\n\n// BuildACLFromResourceData extracts common ACL fields from ResourceData\nfunc BuildACLFromResourceData(d *schema.ResourceData) CommonACL\n\n// ValidateACLSchema validates auto/manual sequence mode consistency\nfunc ValidateACLSchema(ctx context.Context, diff *schema.ResourceDiff, meta interface{}) error\n```\n\n**Dependencies:** terraform-plugin-sdk/v2\n\n### Component 2: Sequence Calculator (`sequence_calculator.go`)\n\n**Purpose:** Calculate sequence numbers for entries in auto mode\n\n**Location:** `internal/provider/sequence_calculator.go`\n\n**Interfaces:**\n```go\n// CalculateSequences computes sequence numbers for entries\n// Returns map[entryIndex]sequenceNumber\nfunc CalculateSequences(start, step, count int) []int\n\n// ValidateSequenceRange checks if sequences fit within valid range\nfunc ValidateSequenceRange(start, step, count int) error\n\n// DetectSequenceMode determines if ACL uses auto or manual mode\nfunc DetectSequenceMode(d *schema.ResourceData) SequenceMode\n\ntype SequenceMode int\nconst (\n    SequenceModeAuto SequenceMode = iota\n    SequenceModeManual\n)\n```\n\n**Dependencies:** None (pure functions)\n\n### Component 3: Collision Validator (`collision_validator.go`)\n\n**Purpose:** Detect sequence collisions between ACL resources\n\n**Location:** `internal/provider/collision_validator.go`\n\n**Interfaces:**\n```go\n// ValidateNoCollision checks for sequence collisions during CustomizeDiff\nfunc ValidateNoCollision(ctx context.Context, diff *schema.ResourceDiff, meta interface{}) error\n\n// CheckRouterCollision verifies sequences don't conflict with router state\nfunc CheckRouterCollision(ctx context.Context, client *RTXClient, aclType string, sequences []int, excludeACL string) error\n\n// CollisionError represents a sequence collision\ntype CollisionError struct {\n    Sequence    int\n    OwnedBy     string\n    ConflictsWith string\n}\n```\n\n**Dependencies:** RTXClient for router state queries\n\n### Component 4: ACL Service (`acl_service.go`)\n\n**Purpose:** CRUD operations for ACL entries on the router\n\n**Location:** `internal/client/acl_service.go`\n\n**Interfaces:**\n```go\n// CreateACLEntries creates all entries for an ACL group\nfunc (c *RTXClient) CreateACLEntries(ctx context.Context, aclType string, acl CommonACL) error\n\n// ReadACLEntries reads all entries for an ACL group\nfunc (c *RTXClient) ReadACLEntries(ctx context.Context, aclType string, name string) (*CommonACL, error)\n\n// UpdateACLEntries updates entries (delete old, create new)\nfunc (c *RTXClient) UpdateACLEntries(ctx context.Context, aclType string, acl CommonACL) error\n\n// DeleteACLEntries removes all entries for an ACL group\nfunc (c *RTXClient) DeleteACLEntries(ctx context.Context, aclType string, sequences []int) error\n\n// GetAllFilterSequences returns all used sequences for an ACL type\nfunc (c *RTXClient) GetAllFilterSequences(ctx context.Context, aclType string) (map[int]string, error)\n```\n\n**Dependencies:** SSH session, parsers\n\n### Component 5: ACL Apply Service (`acl_apply_service.go`)\n\n**Purpose:** Manage interface filter bindings\n\n**Location:** `internal/client/acl_apply_service.go`\n\n**Interfaces:**\n```go\n// ApplyFiltersToInterface binds filter sequences to an interface\nfunc (c *RTXClient) ApplyFiltersToInterface(ctx context.Context, iface, direction string, aclType string, filterIDs []int) error\n\n// RemoveFiltersFromInterface removes filter bindings from an interface\nfunc (c *RTXClient) RemoveFiltersFromInterface(ctx context.Context, iface, direction string, aclType string) error\n\n// GetInterfaceFilters returns current filter bindings for an interface\nfunc (c *RTXClient) GetInterfaceFilters(ctx context.Context, iface, direction string, aclType string) ([]int, error)\n\n// ValidateInterface checks if interface exists and supports the ACL type\nfunc (c *RTXClient) ValidateInterface(ctx context.Context, iface string, aclType string) error\n```\n\n**Dependencies:** SSH session, parsers\n\n### Component 6: Separate Apply Resources\n\n**Purpose:** Dedicated resources for managing ACL-interface bindings separately\n\n**Location:**\n- `internal/provider/resource_rtx_access_list_ip_apply.go`\n- `internal/provider/resource_rtx_access_list_ipv6_apply.go`\n- `internal/provider/resource_rtx_access_list_mac_apply.go`\n\n**Schema:**\n```go\nSchema: map[string]*schema.Schema{\n    \"access_list\": {\n        Type:        schema.TypeString,\n        Required:    true,\n        Description: \"Name of the ACL to apply\",\n    },\n    \"interface\": {\n        Type:        schema.TypeString,\n        Required:    true,\n        ForceNew:    true,\n        Description: \"Interface to apply the ACL to\",\n    },\n    \"direction\": {\n        Type:        schema.TypeString,\n        Required:    true,\n        ForceNew:    true,\n        Description: \"Direction: 'in' or 'out'\",\n    },\n    \"filter_ids\": {\n        Type:        schema.TypeList,\n        Optional:    true,\n        Description: \"Specific filter IDs to apply (default: all)\",\n        Elem:        &schema.Schema{Type: schema.TypeInt},\n    },\n}\n```\n\n## Data Models\n\n### CommonACL\n```go\ntype CommonACL struct {\n    Name          string\n    SequenceStart int           // 0 = manual mode\n    SequenceStep  int           // default 1\n    Entries       []ACLEntry\n    Applies       []ACLApply\n}\n\ntype ACLEntry struct {\n    Sequence int    // calculated or explicit\n    // ACL-type specific fields stored as map[string]interface{}\n    Fields   map[string]interface{}\n}\n\ntype ACLApply struct {\n    Interface string\n    Direction string   // \"in\" or \"out\"\n    FilterIDs []int    // empty = all sequences\n}\n```\n\n### ACL Type Constants\n```go\ntype ACLType string\n\nconst (\n    ACLTypeIP        ACLType = \"ip\"\n    ACLTypeIPv6      ACLType = \"ipv6\"\n    ACLTypeMAC       ACLType = \"mac\"\n    ACLTypeIPDynamic ACLType = \"ip_dynamic\"\n    ACLTypeIPv6Dynamic ACLType = \"ipv6_dynamic\"\n    ACLTypeExtended  ACLType = \"extended\"\n)\n```\n\n### Interface Filter Command Mapping\n```go\nvar InterfaceFilterCommands = map[ACLType]struct{\n    SetCmd    string\n    DeleteCmd string\n}{\n    ACLTypeIP:        {\"ip %s secure filter %s %s\", \"no ip %s secure filter %s\"},\n    ACLTypeIPv6:      {\"ipv6 %s secure filter %s %s\", \"no ipv6 %s secure filter %s\"},\n    ACLTypeMAC:       {\"ethernet %s filter %s %s\", \"no ethernet %s filter %s\"},\n    ACLTypeExtended:  {\"ip %s secure filter %s %s\", \"no ip %s secure filter %s\"},\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Sequence Mode Mixing**\n   - **Handling:** Return validation error in CustomizeDiff\n   - **User Impact:** `Error: entry[2]: sequence cannot be specified when sequence_start is set`\n\n2. **Sequence Collision (Plan)**\n   - **Handling:** Query Terraform state for other ACLs, compare ranges\n   - **User Impact:** `Error: sequence 100 conflicts with ACL \"other_acl\" (sequences 100-110)`\n\n3. **Sequence Collision (Apply)**\n   - **Handling:** Query router for existing filters before creating\n   - **User Impact:** `Error: filter 100 already exists on router (owned by unknown source)`\n\n4. **Invalid Interface**\n   - **Handling:** Validate interface exists and supports ACL type\n   - **User Impact:** `Error: interface \"lan99\" does not exist` or `Error: MAC ACL not supported on PP interfaces`\n\n5. **Apply Conflict (Inline vs Separate)**\n   - **Handling:** Track all applies in state, detect duplicates\n   - **User Impact:** `Error: interface \"lan1\" direction \"in\" already has IP ACL applied by rtx_access_list_extended.other`\n\n6. **Partial Apply Failure**\n   - **Handling:** ACL entries created, apply fails; state reflects partial success\n   - **User Impact:** `Error: failed to apply filters to lan2: connection timeout. ACL entries created. Run terraform apply again to retry.`\n\n## Testing Strategy\n\n### Unit Testing\n\n**Sequence Calculator Tests:**\n```go\nfunc TestCalculateSequences(t *testing.T) {\n    // start=100, step=10, count=3 → [100, 110, 120]\n    // start=1, step=1, count=5 → [1, 2, 3, 4, 5]\n    // edge: step=0 → error\n    // edge: overflow → error\n}\n\nfunc TestDetectSequenceMode(t *testing.T) {\n    // sequence_start set → auto\n    // sequence_start not set → manual\n}\n```\n\n**Collision Validator Tests:**\n```go\nfunc TestValidateNoCollision(t *testing.T) {\n    // no overlap → pass\n    // exact overlap → error\n    // partial overlap → error\n    // same ACL (update) → pass\n}\n```\n\n**Schema Validation Tests:**\n```go\nfunc TestValidateACLSchema(t *testing.T) {\n    // auto mode + entry sequence → error\n    // manual mode + missing sequence → error\n    // valid auto mode → pass\n    // valid manual mode → pass\n}\n```\n\n### Integration Testing\n\n**ACL CRUD Tests (per ACL type):**\n```go\nfunc TestAccRTXAccessListExtended_AutoSequence(t *testing.T)\nfunc TestAccRTXAccessListExtended_ManualSequence(t *testing.T)\nfunc TestAccRTXAccessListExtended_MultipleApply(t *testing.T)\nfunc TestAccRTXAccessListExtended_UpdateAddEntry(t *testing.T)\nfunc TestAccRTXAccessListExtended_UpdateRemoveEntry(t *testing.T)\nfunc TestAccRTXAccessListExtended_UpdateChangeSequenceStart(t *testing.T)\nfunc TestAccRTXAccessListExtended_DeleteWithApply(t *testing.T)\nfunc TestAccRTXAccessListExtended_Import(t *testing.T)\n```\n\n**Collision Detection Tests:**\n```go\nfunc TestAccRTXAccessList_SequenceCollisionPlan(t *testing.T)\nfunc TestAccRTXAccessList_SequenceCollisionApply(t *testing.T)\nfunc TestAccRTXAccessList_ApplyConflict(t *testing.T)\n```\n\n**Separate Apply Resource Tests:**\n```go\nfunc TestAccRTXAccessListIPApply_Basic(t *testing.T)\nfunc TestAccRTXAccessListIPApply_ForEach(t *testing.T)\nfunc TestAccRTXAccessListIPApply_ConflictWithInline(t *testing.T)\n```\n\n### End-to-End Testing\n\n**Full Workflow Tests:**\n```go\nfunc TestAccRTXAccessList_FullWorkflow(t *testing.T) {\n    // 1. Create ACL with auto sequence\n    // 2. Apply to lan1\n    // 3. Add entry (verify sequence recalculation)\n    // 4. Add apply to lan2\n    // 5. Modify entry\n    // 6. Remove apply from lan1\n    // 7. Delete ACL (verify all applies removed)\n}\n\nfunc TestAccRTXAccessList_MultipleACLTypes(t *testing.T) {\n    // Create IP, IPv6, MAC ACLs\n    // Apply all to same interface\n    // Verify no conflicts\n    // Delete in order\n}\n```\n\n## Migration Path\n\n### For Existing Users\n\n1. **Remove ACL attributes from interface resources**\n   - Users must migrate `rtx_interface.access_list_*` to ACL resource `apply` blocks\n   - Provider will error with clear migration instructions\n\n2. **Convert individual filter resources to group resources**\n   - `rtx_access_list_ip` and `rtx_access_list_ipv6` change from individual to group\n   - Existing state must be migrated or resources recreated\n\n### Migration Guide Example\n```hcl\n# Before (old design)\nresource \"rtx_access_list_ip\" \"filter1\" {\n  sequence = 10\n  action   = \"pass\"\n  ...\n}\n\nresource \"rtx_access_list_ip\" \"filter2\" {\n  sequence = 20\n  action   = \"reject\"\n  ...\n}\n\nresource \"rtx_interface\" \"lan1\" {\n  name              = \"lan1\"\n  access_list_ip_in = \"10 20\"\n}\n\n# After (new design)\nresource \"rtx_access_list_ip\" \"policy\" {\n  name           = \"lan1_policy\"\n  sequence_start = 10\n  sequence_step  = 10\n\n  entry {\n    action = \"pass\"\n    ...\n  }\n\n  entry {\n    action = \"reject\"\n    ...\n  }\n\n  apply {\n    interface = \"lan1\"\n    direction = \"in\"\n  }\n}\n\nresource \"rtx_interface\" \"lan1\" {\n  name = \"lan1\"\n  # access_list_ip_in removed\n}\n```\n",
  "fileStats": {
    "size": 14597,
    "lines": 492,
    "lastModified": "2026-01-26T15:35:42.528Z"
  },
  "comments": []
}