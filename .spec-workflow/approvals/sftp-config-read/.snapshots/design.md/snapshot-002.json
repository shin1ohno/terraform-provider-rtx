{
  "id": "snapshot_1769168191430_jytr28tdk",
  "approvalId": "approval_1769168179381_kmsec19es",
  "approvalTitle": "SFTP-Based Configuration Reading - Design",
  "version": 2,
  "timestamp": "2026-01-23T11:36:31.430Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: SFTP-Based Configuration Reading\n\n## Overview\n\nThis feature adds an optional SFTP-based configuration reading mechanism to the RTX Terraform provider. When enabled, the provider downloads the router's complete configuration file via SFTP, caches it in memory, and parses it to serve resource read operations. This replaces hundreds of individual SSH CLI commands with a single file transfer, reducing read time from ~5 minutes to under 10 seconds.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **Language**: Go 1.23 with standard library and established third-party packages\n- **Protocol**: SFTP runs over SSH subsystem, using same encryption as existing SSH connections\n- **Architecture**: Follows existing parser registry pattern for modular parsing\n- **Security**: Credentials handled via Terraform sensitive variables, no disk storage of config data\n\n### Project Structure (structure.md)\n\nNew files follow existing package organization:\n- `internal/client/sftp_client.go` - SFTP connection and download\n- `internal/client/config_cache.go` - In-memory configuration cache\n- `internal/rtx/parsers/config_file.go` - Full config file parser\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`internal/client/Config` struct**: Add `SFTPEnabled bool` field; reuse existing SSH parameters\n- **`internal/client/ssh_dialer.go`**: SFTP uses same SSH connection establishment\n- **`internal/rtx/parsers/*`**: Existing line-based parsers can be reused for individual command parsing\n- **`internal/provider/provider.go`**: Add `sftp_enabled` schema field alongside existing config\n\n### Integration Points\n\n- **Provider Configuration**: New `sftp_enabled` flag in provider schema\n- **Client Interface**: Add `GetConfigCache() *ConfigCache` method to Client interface\n- **Resource Read Functions**: Check cache before falling back to SSH commands\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph Provider\n        P[Provider Config] -->|sftp_enabled=true| CPR[ConfigPathResolver]\n        P -->|sftp_enabled=false| SSH[SSH Client]\n    end\n\n    subgraph SFTP Path\n        CPR -->|show environment| DP[Detect Path]\n        DP -->|/system/configN| SC[SFTP Client]\n        SC -->|Download| CF[config file]\n        CF -->|Store| CC[ConfigCache]\n        CC -->|Parse| CP[ConfigParser]\n        CP -->|Extract| RS[Resource State]\n    end\n\n    subgraph SSH Path\n        SSH -->|Commands| CLI[CLI Output]\n        CLI -->|Parse| EP[Existing Parsers]\n        EP --> RS\n    end\n\n    subgraph Resource Read\n        RR[Resource.Read] -->|Check| CC\n        CC -->|Hit| RS\n        CC -->|Miss/Disabled| SSH\n    end\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: SFTP client, cache, and parser are separate files\n- **Component Isolation**: ConfigCache is independent of SFTP download mechanism\n- **Service Layer Separation**: Parsing logic separate from I/O operations\n- **Fallback Strategy**: SFTP failure triggers SSH fallback with warning log\n\n## Components and Interfaces\n\n### Component 1: SFTPClient\n\n- **Purpose**: Download configuration file from RTX router via SFTP\n- **File**: `internal/client/sftp_client.go`\n- **Interfaces**:\n  ```go\n  type SFTPClient interface {\n      // Download retrieves config file and returns content as bytes\n      Download(ctx context.Context, path string) ([]byte, error)\n      // Close closes the SFTP connection\n      Close() error\n  }\n\n  type sftpClient struct {\n      sshClient  *ssh.Client\n      sftpClient *sftp.Client\n  }\n\n  func NewSFTPClient(config *Config) (SFTPClient, error)\n  ```\n- **Dependencies**: `golang.org/x/crypto/ssh`, `github.com/pkg/sftp`\n- **Reuses**: SSH connection parameters from existing `Config` struct\n\n### Component 2: ConfigCache\n\n- **Purpose**: In-memory cache for downloaded configuration, shared across resource reads\n- **File**: `internal/client/config_cache.go`\n- **Interfaces**:\n  ```go\n  type ConfigCache struct {\n      mu         sync.RWMutex\n      content    string           // Raw config file content\n      parsed     *ParsedConfig    // Parsed configuration data\n      validUntil time.Time        // Cache invalidation timestamp\n      dirty      bool             // True if write occurred, requiring refresh\n  }\n\n  func NewConfigCache() *ConfigCache\n  func (c *ConfigCache) Get() (*ParsedConfig, bool)\n  func (c *ConfigCache) Set(content string, parsed *ParsedConfig)\n  func (c *ConfigCache) Invalidate()\n  func (c *ConfigCache) MarkDirty()\n  ```\n- **Dependencies**: `sync` for thread-safety\n- **Thread Safety**: Uses RWMutex for concurrent read access\n\n### Component 3: ConfigParser\n\n- **Purpose**: Parse full config.txt into structured data for each resource type\n- **File**: `internal/rtx/parsers/config_file.go`\n- **Interfaces**:\n  ```go\n  type ParsedConfig struct {\n      Raw           string\n      StaticRoutes  []StaticRoute\n      DHCPScopes    []DHCPScope\n      VLANs         []VLAN\n      Interfaces    map[string]*InterfaceConfig\n      NAT           *NATConfig\n      Filters       *FilterConfig\n      DNS           *DNSConfig\n      Admin         *AdminConfig\n      Tunnels       map[int]*TunnelConfig\n      // ... other resource types\n  }\n\n  type ConfigFileParser struct {\n      // Reuses existing parsers\n      staticRouteParser *StaticRouteParser\n      dhcpParser        *DHCPScopeParser\n      // ...\n  }\n\n  func NewConfigFileParser() *ConfigFileParser\n  func (p *ConfigFileParser) Parse(content string) (*ParsedConfig, error)\n  ```\n- **Dependencies**: Existing parsers in `internal/rtx/parsers/`\n- **Reuses**: `StaticRouteParser`, `DHCPScopeParser`, `VLANParser`, etc.\n\n### Component 4: ConfigPathResolver\n\n- **Purpose**: Determine the correct config file path by querying router's startup config\n- **File**: `internal/client/config_path_resolver.go`\n- **Interfaces**:\n  ```go\n  type ConfigPathResolver interface {\n      // GetStartupConfigPath returns the SFTP path to the startup config file\n      // by parsing \"show environment\" output\n      GetStartupConfigPath(ctx context.Context) (string, error)\n  }\n\n  type configPathResolver struct {\n      executor Executor\n  }\n\n  func NewConfigPathResolver(executor Executor) ConfigPathResolver\n  ```\n- **Logic**:\n  1. Execute `show environment` command via SSH\n  2. Parse output to find \"デフォルト設定ファイル\" (default config file) line\n  3. Extract config number (e.g., `config0`, `config1`)\n  4. Return SFTP path: `/system/config{N}`\n- **Fallback**: If parsing fails, default to `/system/config0`\n\n### Component 5: Provider Configuration Extension\n\n- **Purpose**: Add SFTP configuration options to provider schema\n- **File**: `internal/provider/provider.go` (modification)\n- **Changes**:\n  ```go\n  // New schema field\n  \"sftp_enabled\": {\n      Type:        schema.TypeBool,\n      Optional:    true,\n      Default:     false,\n      DefaultFunc: schema.EnvDefaultFunc(\"RTX_SFTP_ENABLED\", false),\n      Description: \"Enable SFTP-based bulk configuration reading for faster refresh operations.\",\n  },\n  \"sftp_config_path\": {\n      Type:        schema.TypeString,\n      Optional:    true,\n      Default:     \"\",  // Empty means auto-detect via show environment\n      Description: \"Path to configuration file on RTX router for SFTP download. \" +\n                   \"If empty, automatically detects startup config via 'show environment'. \" +\n                   \"RTX stores configs at /system/config0 through /system/config4.\",\n  },\n  ```\n\n### Component 6: Client Config Extension\n\n- **Purpose**: Add SFTP fields to client configuration\n- **File**: `internal/client/interfaces.go` (modification)\n- **Changes**:\n  ```go\n  type Config struct {\n      // ... existing fields ...\n      SFTPEnabled    bool   // Enable SFTP-based config reading\n      SFTPConfigPath string // Path to config file (empty = auto-detect)\n  }\n  ```\n\n## Data Models\n\n### ParsedConfig\n```go\ntype ParsedConfig struct {\n    // Raw content for debugging\n    Raw string\n\n    // Per-resource type parsed data\n    StaticRoutes      []StaticRoute           // ip route commands\n    DHCPScopes        map[int]*DHCPScope      // dhcp scope N commands\n    DHCPBindings      []DHCPBinding           // dhcp scope bind commands\n    VLANs             map[int]*VLANConfig     // vlan N commands\n    Interfaces        map[string]*InterfaceConfig // ip lanN, ip ppN commands\n    NATMasquerades    map[int]*NATMasquerade  // nat descriptor N commands\n    NATStatics        []NATStatic             // nat descriptor masquerade static\n    IPFilters         map[int]*IPFilter       // ip filter N commands\n    IPFilterDynamics  map[int]*IPFilterDynamic // ip filter dynamic N commands\n    EthernetFilters   map[int]*EthernetFilter // ethernet filter N commands\n    Tunnels           map[int]*TunnelConfig   // tunnel select N context\n    IPsecSA           map[int]*IPsecSA        // ipsec sa policy commands\n    L2TPConfig        *L2TPConfig             // l2tp commands\n    DNSConfig         *DNSConfig              // dns commands\n    DHCPService       *DHCPServiceConfig      // dhcp service commands\n    AdminConfig       *AdminConfig            // login/administrator commands\n    SystemConfig      *SystemConfig           // system commands\n    SSHDConfig        *SSHDConfig             // sshd commands\n    SFTPDConfig       *SFTPDConfig            // sftpd commands\n    HTTPDConfig       *HTTPDConfig            // httpd commands\n    SyslogConfig      *SyslogConfig           // syslog commands\n    BGPConfig         *BGPConfig              // bgp commands\n    OSPFConfig        *OSPFConfig             // ospf commands\n    ScheduleConfig    map[string]*Schedule    // schedule commands\n    IPv6Prefixes      map[int]*IPv6Prefix     // ipv6 prefix commands\n    IPv6Interfaces    map[string]*IPv6InterfaceConfig // ipv6 lanN commands\n    Bridges           map[string]*BridgeConfig // bridge commands\n}\n```\n\n### TunnelConfig (Context-Aware Parsing)\n```go\ntype TunnelConfig struct {\n    Number          int\n    Encapsulation   string  // l2tpv3, l2tp, ipsec, etc.\n    EndpointName    string\n    EndpointAddress string\n    IPsecTunnel     int     // Associated ipsec tunnel number\n    IPsecSAPolicy   *IPsecSAPolicy\n    L2TPConfig      *L2TPTunnelConfig\n    Enabled         bool\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **SFTP Connection Refused**\n   - **Handling**: Log warning with error details, fall back to SSH CLI\n   - **User Impact**: Slower operation but still works; warning indicates SFTP not enabled on router\n\n2. **SFTP Authentication Failed**\n   - **Handling**: Log warning, fall back to SSH CLI\n   - **User Impact**: Warning suggests checking admin_password configuration\n\n3. **Config File Not Found**\n   - **Handling**: Log warning with path, fall back to SSH CLI\n   - **User Impact**: Warning suggests checking sftp_config_path setting\n\n4. **Config Parse Error**\n   - **Handling**: Log error with line number, fall back to SSH CLI\n   - **User Impact**: Degraded mode with warning about potential config syntax issue\n\n5. **Cache Invalidation Race**\n   - **Handling**: Use mutex to ensure atomic read/write; re-download on dirty flag\n   - **User Impact**: Transparent; slight performance impact during concurrent writes\n\n### Fallback Strategy Flow\n\n```mermaid\nflowchart TD\n    A[Resource Read] --> B{SFTP Enabled?}\n    B -->|No| SSH[Use SSH CLI]\n    B -->|Yes| C{Cache Valid?}\n    C -->|Yes| D[Return Cached Data]\n    C -->|No| E[Download via SFTP]\n    E --> F{Download OK?}\n    F -->|Yes| G[Parse Config]\n    G --> H{Parse OK?}\n    H -->|Yes| I[Cache & Return]\n    H -->|No| J[Log Warning]\n    F -->|No| J\n    J --> SSH\n    SSH --> K[Return Data]\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n1. **SFTPClient Tests** (`sftp_client_test.go`)\n   - Mock SSH connection\n   - Test successful download\n   - Test connection error handling\n   - Test file not found error\n\n2. **ConfigCache Tests** (`config_cache_test.go`)\n   - Test concurrent read access\n   - Test cache invalidation\n   - Test dirty flag behavior\n   - Test expiration logic\n\n3. **ConfigFileParser Tests** (`config_file_test.go`)\n   - Test parsing sample config files\n   - Test context-aware parsing (tunnel select blocks)\n   - Test comment handling\n   - Test malformed input handling\n   - Test password extraction from various formats\n\n### Integration Testing\n\n1. **SFTP Download Integration**\n   - Test against mock SFTP server\n   - Test real RTX router (acceptance test)\n\n2. **Fallback Integration**\n   - Test SFTP failure triggers SSH fallback\n   - Verify warning logs are emitted\n\n3. **Cache Integration**\n   - Test cache shared across multiple resource reads\n   - Test cache invalidation after write operation\n\n### End-to-End Testing\n\n1. **Performance Comparison**\n   - Measure refresh time with SFTP enabled vs disabled\n   - Target: < 10 seconds with SFTP vs ~5 minutes with SSH\n\n2. **Import Workflow**\n   - Test `terraform import` with SFTP-extracted passwords\n   - Verify imported state matches router config\n\n3. **Plan/Apply Cycle**\n   - Test full workflow with SFTP enabled\n   - Verify no diff on unchanged resources\n\n## Implementation Notes\n\n### SFTP Library Choice\n\nUsing `github.com/pkg/sftp` (MIT license):\n- Mature, widely-used library\n- Supports Go's `io.Reader`/`io.Writer` interfaces\n- Compatible with Yamaha RTX SFTP implementation\n\n### Password Extraction Patterns\n\nThe parser must recognize these password patterns in config.txt:\n```\nlogin password <plaintext>\nadministrator password <plaintext>\npp auth username <user> <password>\nipsec ike pre-shared-key <n> text <secret>\nl2tp tunnel auth on <secret>\nlogin user <name> encrypted <hash>  # Cannot extract, mark as unknown\n```\n\n### Context-Aware Parsing\n\nRTX config uses hierarchical contexts that must be tracked:\n```\ntunnel select 1          # Enter tunnel 1 context\n tunnel encapsulation l2tpv3\n ipsec tunnel 101        # Commands apply to tunnel 1's ipsec\n  ipsec sa policy 101 1 esp aes-cbc sha-hmac\n tunnel enable 1\ntunnel select 2          # Exit tunnel 1, enter tunnel 2 context\n```\n\nParser maintains a context stack to associate commands with the correct parent resource.\n",
  "fileStats": {
    "size": 14086,
    "lines": 400,
    "lastModified": "2026-01-23T11:35:42.253Z"
  },
  "comments": []
}