{
  "id": "snapshot_1768913237438_2eyk168nv",
  "approvalId": "approval_1768913108252_k8fy2urlr",
  "approvalTitle": "RTX Command Parser Test Coverage - Requirements",
  "version": 2,
  "timestamp": "2026-01-20T12:47:17.438Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document: RTX Command Parser Test Coverage\n\n## Introduction\n\nThis feature ensures comprehensive test coverage for existing RTX command parsers by systematically extracting all command patterns from the 59-chapter RTX command reference documentation and creating test cases to verify parser correctness. The goal is to identify and fix any parsing gaps in the existing implementation.\n\n## Alignment with Product Vision\n\nThis feature supports the product vision by:\n- Ensuring parser reliability for accurate import/export of RTX configurations\n- Reducing configuration errors through comprehensive validation\n- Following the existing Parser Registry Pattern without unnecessary refactoring\n\n## Requirements\n\n### REQ-1: Command Pattern Extraction from Documentation\n\n**User Story:** As a provider developer, I want all RTX command patterns extracted from the documentation, so that I can create comprehensive test cases.\n\n#### Acceptance Criteria\n\n1. WHEN processing each chapter of RTX command documentation THEN the system SHALL extract all `[書式]` (format) sections\n2. WHEN extracting command patterns THEN the system SHALL capture:\n   - Command name and subcommands\n   - Required parameters\n   - Optional parameters (in brackets `[]`)\n   - Parameter value types and ranges from `[設定値]` sections\n   - Default values from `[初期値]` sections\n3. WHEN a command has multiple format variations THEN each variation SHALL be extracted as a separate pattern\n4. WHEN a `no` form exists THEN it SHALL be extracted alongside the positive form\n\n### REQ-2: Command Pattern Categorization\n\n**User Story:** As a provider developer, I want command patterns organized by category, so that I can prioritize test coverage for implemented resources.\n\n#### Acceptance Criteria\n\n1. WHEN organizing extracted patterns THEN they SHALL be categorized by chapter/feature area:\n   - IP Configuration (Chapter 8)\n   - Ethernet Filter (Chapter 9)\n   - DHCP (Chapter 12)\n   - IPsec (Chapter 15)\n   - L2TP (Chapter 16)\n   - PPTP (Chapter 17)\n   - NAT (Chapter 23)\n   - DNS (Chapter 24)\n   - QoS (Chapter 26)\n   - OSPF (Chapter 28)\n   - BGP (Chapter 29)\n   - IPv6 (Chapter 30)\n   - VLAN (Chapter 38)\n   - Schedule (Chapter 37)\n   - SNMP (Chapter 21)\n   - Syslog (Chapter 59)\n   - System/Admin (Chapter 4)\n2. WHEN a pattern maps to an existing parser THEN it SHALL be tagged with the parser name\n3. WHEN a pattern has no corresponding parser THEN it SHALL be flagged for future implementation\n\n### REQ-3: Test Case Generation\n\n**User Story:** As a provider developer, I want test cases generated from extracted patterns, so that I can verify parser correctness.\n\n#### Acceptance Criteria\n\n1. WHEN generating test cases THEN each test SHALL include:\n   - Input: Raw RTX command string (from `[設定例]` or constructed from pattern)\n   - Expected output: Structured data that the parser should produce\n   - Edge cases: Boundary values, optional parameter combinations\n2. WHEN a pattern has documented examples (`[設定例]`) THEN those SHALL be used as test inputs\n3. WHEN a pattern has value ranges THEN test cases SHALL include:\n   - Minimum valid value\n   - Maximum valid value\n   - Typical/common value\n4. WHEN a pattern has optional parameters THEN test cases SHALL cover:\n   - All parameters omitted\n   - Each optional parameter included individually\n   - All optional parameters included\n\n### REQ-4: Existing Parser Verification\n\n**User Story:** As a provider developer, I want to run test cases against existing parsers, so that I can identify parsing gaps.\n\n#### Acceptance Criteria\n\n1. WHEN running tests against existing parsers THEN the system SHALL report:\n   - Pass: Parser correctly handles the pattern\n   - Fail: Parser produces incorrect output\n   - Skip: No parser exists for this pattern\n2. WHEN a test fails THEN the report SHALL include:\n   - Input command string\n   - Expected output\n   - Actual output\n   - Diff between expected and actual\n3. WHEN tests complete THEN a coverage report SHALL show:\n   - Total patterns extracted per category\n   - Patterns with passing tests\n   - Patterns with failing tests\n   - Patterns with no parser coverage\n\n### REQ-5: Interface Name Pattern Coverage\n\n**User Story:** As a provider developer, I want test cases for all interface naming conventions, so that interface-scoped commands are correctly parsed.\n\n#### Acceptance Criteria\n\n1. WHEN generating interface-related tests THEN coverage SHALL include:\n   - Physical LAN: `lan1`, `lan2`\n   - LAN division: `lan1.1`, `lan1.2`\n   - Tagged VLAN: `lan1/1`, `lan1/2`\n   - PP interfaces: `pp`, `pp1`\n   - Tunnel interfaces: `tunnel1`, `tunnel2`\n   - Loopback interfaces: `loopback1` through `loopback9`\n   - Bridge interfaces: `bridge1`\n   - VLAN interfaces: `vlan1`, `vlan2`\n   - Special interfaces: `null`\n2. WHEN a command accepts multiple interface types THEN test cases SHALL cover each valid type\n\n### REQ-6: Value Type Coverage\n\n**User Story:** As a provider developer, I want test cases for all value types, so that value parsing is thoroughly tested.\n\n#### Acceptance Criteria\n\n1. WHEN generating value-related tests THEN coverage SHALL include:\n   - Boolean switches: `on`, `off`\n   - IPv4 addresses: `192.168.1.1`, `0.0.0.0`, `255.255.255.255`\n   - IPv4 with CIDR: `192.168.1.0/24`, `10.0.0.0/8`\n   - Subnet masks: `/24`, `/255.255.255.0`, `0xffffff00`\n   - IPv6 addresses: Standard and compressed formats\n   - Numeric ranges: Boundary values for each documented range\n   - MAC addresses: `00:00:00:00:00:00` format\n   - Time values: `HH:MM` format\n   - Named parameters: `key=value` syntax\n   - Keywords: All documented keyword options\n\n### REQ-7: Gap Analysis Report\n\n**User Story:** As a provider developer, I want a gap analysis report, so that I can prioritize parser improvements.\n\n#### Acceptance Criteria\n\n1. WHEN analysis completes THEN the report SHALL list:\n   - Commands with complete test coverage\n   - Commands with partial test coverage (some patterns tested)\n   - Commands with no test coverage\n   - Commands with no parser implementation\n2. WHEN prioritizing gaps THEN the report SHALL consider:\n   - Commands used by existing Terraform resources (high priority)\n   - Commands commonly used in enterprise configurations (medium priority)\n   - Commands for deprecated/legacy features (low priority)\n\n### REQ-8: Test Fixture Organization\n\n**User Story:** As a provider developer, I want test fixtures organized systematically, so that tests are maintainable.\n\n#### Acceptance Criteria\n\n1. WHEN organizing test fixtures THEN they SHALL follow the pattern:\n   ```\n   internal/rtx/testdata/\n   ├── commands/\n   │   ├── ip/\n   │   │   ├── ip_routing.txt\n   │   │   ├── ip_address.txt\n   │   │   └── ...\n   │   ├── ipsec/\n   │   ├── vlan/\n   │   └── ...\n   └── expected/\n       ├── ip/\n       ├── ipsec/\n       └── ...\n   ```\n2. WHEN adding new test cases THEN they SHALL include comments referencing the documentation source (chapter, section, page)\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Leverage Existing Structure**: Use existing `internal/rtx/parsers/` and test file patterns\n- **Table-Driven Tests**: Use Go's table-driven test pattern for command variations\n- **Test Data Separation**: Keep test inputs and expected outputs in separate files for readability\n\n### Performance\n\n- Test suite execution shall complete within 60 seconds for all patterns\n- Individual parser tests shall complete within 100ms\n\n### Maintainability\n\n- Test fixtures shall be human-readable plain text\n- Expected outputs shall be documented JSON for easy comparison\n- Each test file shall reference its source documentation section\n\n### Coverage Goals\n\n- Phase 1: 100% coverage for commands used by existing Terraform resources\n- Phase 2: 80% coverage for all documented command patterns\n- Phase 3: Edge case coverage for complex parameter combinations\n",
  "fileStats": {
    "size": 7986,
    "lines": 200,
    "lastModified": "2026-01-20T12:44:29.225Z"
  },
  "comments": []
}