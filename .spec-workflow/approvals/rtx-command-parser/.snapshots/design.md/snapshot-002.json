{
  "id": "snapshot_1768913986081_sb68ekcq1",
  "approvalId": "approval_1768913317455_sfegjtgh4",
  "approvalTitle": "RTX Command Parser Test Coverage - Design",
  "version": 2,
  "timestamp": "2026-01-20T12:59:46.081Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: RTX Command Parser Test Coverage\n\n## Overview\n\nThis design describes the approach for systematically extracting RTX command patterns from documentation, generating comprehensive test cases, and validating existing parsers. The goal is to ensure parser reliability by identifying and fixing any parsing gaps.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Uses Go's standard testing package with table-driven tests (established pattern)\n- Follows existing parser registry pattern in `internal/rtx/parsers/`\n- Test fixtures stored in `internal/rtx/testdata/` (existing structure)\n\n### Project Structure (structure.md)\n- Test files colocated with parser implementations (`*_test.go`)\n- Test fixtures organized by category in `internal/rtx/testdata/`\n- Command pattern catalog stored in `docs/RTX-commands/` (source documentation)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **Parser Registry** (`internal/rtx/parsers/registry.go`): Centralized parser management\n- **Existing Parsers** (~25 parsers): dns.go, static_route.go, vlan.go, ipsec_tunnel.go, etc.\n- **Existing Test Patterns**: Table-driven tests with input/expected pairs\n- **Test Fixtures**: `internal/rtx/testdata/` structure with `.txt` and `.golden.json` files\n\n### Integration Points\n- **RTX Command Documentation** (`docs/RTX-commands/*.md`): Source for command patterns\n- **Existing `*_test.go` files**: Extend with additional test cases\n\n## Architecture\n\n```mermaid\ngraph TD\n    A[RTX Command Docs] --> B[Pattern Extractor Tool]\n    B --> C[Command Pattern Catalog<br>JSON/YAML]\n    C --> D[Test Case Generator]\n    D --> E[Test Fixtures<br>.txt + expected]\n    E --> F[Go Tests]\n    F --> G[Existing Parsers]\n    G --> H[Coverage Report]\n    H --> I{Gaps Found?}\n    I -->|Yes| J[Fix Parser]\n    I -->|No| K[Done]\n    J --> F\n```\n\n### Modular Design Principles\n- **Pattern Extractor**: Standalone script to parse markdown documentation\n- **Test Case Generator**: Creates test fixtures from pattern catalog\n- **Coverage Reporter**: Summarizes test results and identifies gaps\n- **Each parser maintains its own tests**: No centralized test runner changes needed\n\n## Components and Interfaces\n\n### Component 1: Command Pattern Catalog\n- **Purpose:** Structured representation of all RTX command syntax patterns\n- **Format:** YAML files organized by chapter/category\n- **Location:** `internal/rtx/testdata/patterns/`\n- **Example:**\n```yaml\n# patterns/dns.yaml\ncommands:\n  - name: dns server\n    syntax: \"dns server <ip1> [ip2] [ip3]\"\n    parameters:\n      - name: ip1\n        type: ipv4\n        required: true\n      - name: ip2\n        type: ipv4\n        required: false\n      - name: ip3\n        type: ipv4\n        required: false\n    examples:\n      - input: \"dns server 8.8.8.8\"\n        chapter: 24\n        section: \"24.1\"\n      - input: \"dns server 8.8.8.8 8.8.4.4\"\n        chapter: 24\n        section: \"24.1\"\n    parser: dns.go\n```\n\n### Component 2: Test Fixture Generator\n- **Purpose:** Generate test input/expected pairs from pattern catalog\n- **Interfaces:**\n  - `GenerateFixtures(patternFile string) ([]TestFixture, error)`\n  - `WriteFixtures(fixtures []TestFixture, outputDir string) error`\n- **Dependencies:** Pattern catalog YAML files\n- **Reuses:** Existing `internal/rtx/testdata/` directory structure\n\n### Component 3: Parser Test Runner\n- **Purpose:** Execute tests and collect results\n- **Interfaces:** Standard Go test commands (`go test ./internal/rtx/parsers/...`)\n- **Dependencies:** Existing test infrastructure\n- **Output:** Test results with pass/fail/skip counts\n\n### Component 4: Coverage Report Generator\n- **Purpose:** Summarize coverage and identify gaps\n- **Interfaces:**\n  - `GenerateReport(testResults, patternCatalog) CoverageReport`\n- **Output:** Markdown report with:\n  - Patterns tested vs. total patterns\n  - Failing tests with details\n  - Patterns without parser coverage\n\n## Data Models\n\n### CommandPattern\n```go\ntype CommandPattern struct {\n    Name        string           `yaml:\"name\"`\n    Syntax      string           `yaml:\"syntax\"`\n    NoForm      string           `yaml:\"no_form,omitempty\"`\n    Parameters  []Parameter      `yaml:\"parameters\"`\n    Examples    []Example        `yaml:\"examples\"`\n    Parser      string           `yaml:\"parser\"`\n    Chapter     int              `yaml:\"chapter\"`\n    Section     string           `yaml:\"section\"`\n}\n\ntype Parameter struct {\n    Name     string   `yaml:\"name\"`\n    Type     string   `yaml:\"type\"`     // ipv4, ipv6, int, bool, string, interface, etc.\n    Required bool     `yaml:\"required\"`\n    Default  string   `yaml:\"default,omitempty\"`\n    Range    string   `yaml:\"range,omitempty\"`   // e.g., \"1-100\", \"64-1500\"\n    Values   []string `yaml:\"values,omitempty\"`  // enum values like \"on\", \"off\"\n}\n\ntype Example struct {\n    Input    string `yaml:\"input\"`\n    Chapter  int    `yaml:\"chapter\"`\n    Section  string `yaml:\"section\"`\n}\n```\n\n### TestFixture\n```go\ntype TestFixture struct {\n    Name           string                 `json:\"name\"`\n    Input          string                 `json:\"input\"`\n    Expected       map[string]interface{} `json:\"expected\"`\n    Parser         string                 `json:\"parser\"`\n    Source         string                 `json:\"source\"` // e.g., \"Chapter 24, Section 24.1\"\n    Category       string                 `json:\"category\"`\n    EdgeCase       bool                   `json:\"edge_case\"`\n}\n```\n\n### CoverageReport\n```go\ntype CoverageReport struct {\n    TotalPatterns    int\n    TestedPatterns   int\n    PassingTests     int\n    FailingTests     int\n    SkippedTests     int\n    CoveragePercent  float64\n    ByCategory       map[string]CategoryStats\n    Gaps             []Gap\n}\n\ntype CategoryStats struct {\n    Total   int\n    Tested  int\n    Passing int\n    Failing int\n}\n\ntype Gap struct {\n    Pattern    string\n    Parser     string\n    Reason     string // \"no_parser\", \"failing_test\", \"no_test\"\n    Priority   string // \"high\", \"medium\", \"low\"\n}\n```\n\n## Test Fixture Organization\n\n```\ninternal/rtx/testdata/\n├── patterns/                    # Command pattern catalog (NEW)\n│   ├── dns.yaml\n│   ├── ip.yaml\n│   ├── ipsec.yaml\n│   ├── vlan.yaml\n│   └── ...\n├── fixtures/                    # Generated test fixtures (NEW)\n│   ├── dns/\n│   │   ├── dns_server_basic.txt\n│   │   ├── dns_server_basic.expected.json\n│   │   ├── dns_server_select.txt\n│   │   ├── dns_server_select.expected.json\n│   │   └── ...\n│   ├── ip/\n│   ├── ipsec/\n│   └── ...\n├── import_fidelity/             # Existing complex test cases\n│   └── ...\n├── RTX830/                      # Existing model-specific data\n│   └── ...\n└── RTX1210/\n    └── ...\n```\n\n## Phase 1 Implementation: Priority Commands\n\nFocus on commands used by existing Terraform resources first:\n\n| Category | Parser File | Terraform Resource | Priority |\n|----------|-------------|-------------------|----------|\n| DNS | dns.go | rtx_dns_server | High |\n| Static Route | static_route.go | rtx_static_route | High |\n| VLAN | vlan.go | rtx_vlan | High |\n| Interface | interface_config.go | rtx_interface | High |\n| IPsec | ipsec_tunnel.go | rtx_ipsec_tunnel | High |\n| OSPF | ospf.go | rtx_ospf | High |\n| BGP | bgp.go | rtx_bgp | High |\n| NAT | nat_masquerade.go, nat_static.go | rtx_nat_* | High |\n| DHCP | dhcp_scope.go, dhcp_bindings.go | rtx_dhcp_* | Medium |\n| L2TP | l2tp.go | rtx_l2tp | Medium |\n| PPTP | pptp.go | rtx_pptp | Medium |\n| Schedule | schedule.go | rtx_schedule | Medium |\n| Admin | admin.go | rtx_admin_user | Medium |\n| SNMP | snmp.go | rtx_snmp | Low |\n| Syslog | syslog.go | rtx_syslog | Low |\n| QoS | qos.go | rtx_qos | Low |\n\n## Error Handling\n\n### Error Scenarios\n1. **Pattern extraction fails**\n   - **Handling:** Log warning, continue with other chapters\n   - **User Impact:** Partial catalog generated\n\n2. **Test fixture generation fails**\n   - **Handling:** Log error with pattern details\n   - **User Impact:** Missing test case identified in report\n\n3. **Parser not found for pattern**\n   - **Handling:** Mark as \"skip\" in test results\n   - **User Impact:** Gap identified in coverage report\n\n4. **Test assertion fails**\n   - **Handling:** Standard Go test failure with diff\n   - **User Impact:** Detailed failure message with expected vs actual\n\n## Testing Strategy\n\n### Unit Testing\n- Each pattern catalog YAML file is validated\n- Test fixture generator produces valid JSON\n- Coverage report generator calculates statistics correctly\n\n### Integration Testing\n- Pattern extraction from sample documentation\n- End-to-end: documentation → catalog → fixtures → test execution\n\n### Existing Test Enhancement\n- Add new test cases to existing `*_test.go` files\n- Use table-driven tests for easy addition of cases\n- Reference documentation source in test comments\n\n## Implementation Workflow\n\n1. **Extract patterns** from one chapter (e.g., DNS, Chapter 24)\n2. **Create YAML catalog** for that chapter\n3. **Generate test fixtures** from catalog\n4. **Add tests** to existing `*_test.go`\n5. **Run tests** and identify failures\n6. **Fix parser** if needed\n7. **Repeat** for next chapter\n\nThis incremental approach allows continuous progress while maintaining working code.\n",
  "fileStats": {
    "size": 9374,
    "lines": 278,
    "lastModified": "2026-01-20T12:48:32.093Z"
  },
  "comments": []
}