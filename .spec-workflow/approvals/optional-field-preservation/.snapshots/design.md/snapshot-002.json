{
  "id": "snapshot_1769254246565_5xnlzuj96",
  "approvalId": "approval_1769254236464_jp0mwpz6t",
  "approvalTitle": "Design: Optional Field Preservation (Recursive Merge)",
  "version": 2,
  "timestamp": "2026-01-24T11:30:46.565Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Optional Field Preservation\n\n## Overview\n\nThis document describes the technical design for preserving optional field values when they are not explicitly specified in Terraform configurations. The solution uses a **Read-Merge-Write** pattern: always read current values from the router, merge with user-specified values, and write the complete configuration back.\n\n## RTX Router Behavior (Critical Discovery)\n\n**The RTX `user attribute` command REPLACES the entire configuration line.**\n\nWhen you execute:\n```\nuser attribute admin login-timer=120\n```\n\nAny attributes NOT included in the command (like `administrator`) are **reset to their defaults**, not preserved.\n\n### Documented Behavior\n\nFrom Yamaha RTX documentation:\n- The `user attribute` command overwrites the existing line completely\n- To change one attribute while keeping others, you must re-specify ALL attributes\n- Missing attributes revert to factory defaults (e.g., `administrator=off`)\n\n### Example of the Problem\n\n```bash\n# Current config\nuser attribute admin administrator=2\n\n# User wants to add login-timer, runs:\nuser attribute admin login-timer=120\n\n# Result: administrator privilege is LOST because it wasn't re-specified\n# New config becomes:\nuser attribute admin login-timer=120\n# (administrator defaults to off)\n```\n\n### Correct Approach\n\n```bash\n# Read current: user attribute admin administrator=2\n# Merge with new: login-timer=120\n# Write complete: user attribute admin administrator=2 login-timer=120\n```\n\nThis behavior necessitates a **Read-Merge-Write** pattern for ALL attribute updates.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\nThe design follows existing project conventions:\n- Uses Zerolog for structured logging\n- Follows interface-first design patterns\n- Uses existing error handling patterns with `fmt.Errorf`\n\n### Project Structure (structure.md)\n\nImplementation will follow the established structure:\n- Shared utilities in `internal/provider/field_tracking.go`\n- Resource-specific changes in `internal/provider/resource_*.go`\n- Client-side changes in `internal/client/*.go`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **Terraform SDK schema.ResourceData**: Use `GetOk()` method to detect explicitly set values\n- **parsers package**: Extend command builders to accept optional parameters\n- **client interfaces**: Update structs to use pointer types for optional fields\n\n### Integration Points\n\n- **Provider resources**: All Create/Update functions will use the new field tracking pattern\n- **Client services**: Service methods will accept optional configurations\n- **RTX parsers**: Command builders will conditionally include fields\n\n## Architecture\n\nThe solution uses a **Read-Merge-Write** pattern across three layers:\n\n1. **Schema Layer**: Mark fields as `Optional: true, Computed: true` to enable preservation\n2. **Resource Layer**: Use `GetOk()` to detect explicitly set values, merge with current router state\n3. **Client Layer**: Use pointer types to distinguish \"not set\" from \"explicitly set\"\n\n```mermaid\ngraph TD\n    A[Terraform Config] -->|Parse| B[schema.ResourceData]\n    C[Terraform State] -->|Read phase| B\n\n    B -->|d.Get key| D{Value Source}\n    D -->|In config| E[User Value]\n    D -->|Not in config| F[State Value]\n\n    E --> G[Merged Value]\n    F --> G\n\n    G -->|All Fields| H[Build Command]\n    H -->|Complete Config| I[RTX Router]\n```\n\n### Read-Merge-Write Flow\n\n1. **Read**: Current configuration is already in Terraform state (from the `Read` function called before `Update`)\n2. **Merge**: For each field:\n   - If user specified a value in config (`GetOk` returns true) → use user's value\n   - If user did NOT specify → use value from current state (`d.Get()`)\n3. **Write**: Send complete configuration with ALL fields to router\n\n**Note**: No additional router API call is needed. Terraform always calls `Read` before `Update` to refresh state, so current values are already available in `schema.ResourceData`.\n\n## Components and Interfaces\n\n### Component 1: OptionalFieldHelper\n\n- **Purpose:** Provide utility functions for extracting optional field values from ResourceData\n- **Location:** `internal/provider/field_tracking.go`\n- **Interfaces:**\n  ```go\n  // GetOptionalBool returns a pointer to bool if the field is set, nil otherwise\n  func GetOptionalBool(d *schema.ResourceData, key string) *bool\n\n  // GetOptionalInt returns a pointer to int if the field is set, nil otherwise\n  func GetOptionalInt(d *schema.ResourceData, key string) *int\n\n  // GetOptionalString returns a pointer to string if the field is set, nil otherwise\n  func GetOptionalString(d *schema.ResourceData, key string) *string\n\n  // GetOptionalStringList returns the list if set, nil otherwise\n  func GetOptionalStringList(d *schema.ResourceData, key string) []string\n  ```\n- **Dependencies:** `github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema`\n\n### Component 2: Updated AdminUserAttributes\n\n- **Purpose:** Represent optional user attributes with pointer types\n- **Location:** `internal/client/interfaces.go`\n- **Current Interface:**\n  ```go\n  type AdminUserAttributes struct {\n      Administrator bool     // Always has a value\n      Connection    []string\n      GUIPages      []string\n      LoginTimer    int      // 0 could be intentional\n  }\n  ```\n- **New Interface:**\n  ```go\n  type AdminUserAttributes struct {\n      Administrator *bool    // nil = not set, true/false = explicit\n      Connection    []string // nil = not set, empty = explicitly empty\n      GUIPages      []string // nil = not set\n      LoginTimer    *int     // nil = not set, 0 = infinite\n  }\n  ```\n\n### Component 3: Updated Command Builders\n\n- **Purpose:** Build RTX commands with ALL fields (after merge)\n- **Location:** `internal/rtx/parsers/admin.go`\n- **Current Behavior:**\n  ```go\n  if attrs.Administrator {\n      parts = append(parts, \"administrator=on\")\n  } else {\n      parts = append(parts, \"administrator=off\")  // Always sent - but may be wrong default!\n  }\n  ```\n- **New Behavior:**\n  ```go\n  // After merge, all fields have values (either user-specified or from current config)\n  if attrs.Administrator != nil {\n      if *attrs.Administrator {\n          parts = append(parts, \"administrator=on\")\n      } else {\n          parts = append(parts, \"administrator=off\")\n      }\n  }\n  // Note: nil should not occur after proper merge, but if it does,\n  // the field is omitted (router will use default)\n  ```\n\n### Component 4: Attribute Merger\n\n- **Purpose:** Merge user-specified attributes with current router configuration\n- **Location:** `internal/client/admin_service.go`\n- **Interface:**\n  ```go\n  // MergeAdminUserAttributes merges user-specified values with current config\n  // For each field: if userAttrs field is non-nil, use it; otherwise use currentAttrs\n  func MergeAdminUserAttributes(userAttrs, currentAttrs AdminUserAttributes) AdminUserAttributes\n  ```\n- **Dependencies:** None (pure function)\n\n## Data Models\n\n### OptionalAdminUserAttributes\n\n```go\n// AdminUserAttributes with pointer types for optional field support\ntype AdminUserAttributes struct {\n    Administrator *bool    `json:\"administrator,omitempty\"` // nil = preserve current\n    Connection    []string `json:\"connection,omitempty\"`    // nil = preserve current\n    GUIPages      []string `json:\"gui_pages,omitempty\"`     // nil = preserve current\n    LoginTimer    *int     `json:\"login_timer,omitempty\"`   // nil = preserve current\n}\n```\n\n### Field Tracking Pattern for Resources (Read-Merge-Write)\n\n```go\n// Example pattern for resource Update function\nfunc resourceRTXAdminUserUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {\n    apiClient := meta.(*apiClient)\n    username := d.Get(\"username\").(string)\n\n    // Current values are already in state (Terraform calls Read before Update)\n    // Use GetValueWithFallback to get user-specified value OR current state value\n    attrs := AdminUserAttributes{\n        Administrator: BoolPtr(GetBoolWithFallback(d, \"administrator\")),\n        Connection:    GetStringListWithFallback(d, \"connection\"),\n        GUIPages:      GetStringListWithFallback(d, \"gui_pages\"),\n        LoginTimer:    IntPtr(GetIntWithFallback(d, \"login_timer\")),\n    }\n\n    // Send complete configuration to router\n    user := AdminUser{\n        Username:   username,\n        Attributes: attrs,  // Contains ALL attributes (merged)\n    }\n    return apiClient.UpdateAdminUser(ctx, user)\n}\n```\n\n### Helper Functions for Merge-from-State\n\n```go\n// GetBoolWithFallback returns config value if set, otherwise state value\n// This achieves the merge without needing a separate merge function\nfunc GetBoolWithFallback(d *schema.ResourceData, key string) bool {\n    // GetOk returns (value, true) if explicitly set in config\n    // GetOk returns (state_value, false) if not in config but in state\n    // Either way, d.Get(key) returns the correct merged value\n    return d.Get(key).(bool)\n}\n\n// GetIntWithFallback returns config value if set, otherwise state value\nfunc GetIntWithFallback(d *schema.ResourceData, key string) int {\n    return d.Get(key).(int)\n}\n\n// GetStringListWithFallback returns config value if set, otherwise state value\nfunc GetStringListWithFallback(d *schema.ResourceData, key string) []string {\n    raw := d.Get(key).([]interface{})\n    result := make([]string, len(raw))\n    for i, v := range raw {\n        result[i] = v.(string)\n    }\n    return result\n}\n\n// BoolPtr returns a pointer to the bool value\nfunc BoolPtr(v bool) *bool { return &v }\n\n// IntPtr returns a pointer to the int value\nfunc IntPtr(v int) *int { return &v }\n```\n\n**Key Insight**: Terraform's `d.Get()` already returns the merged value:\n- If field is in user config → returns user's value\n- If field is NOT in config but IS in state → returns state value\n- This is exactly the merge behavior we need!\n\n## Type-Specific Handling Strategies\n\n### Bool Fields\n\n**Example**: `administrator`\n\n| Config | State | d.Get() Result | Command |\n|--------|-------|----------------|---------|\n| `true` | `false` | `true` | `administrator=on` |\n| `false` | `true` | `false` | `administrator=off` |\n| (not set) | `true` | `true` | `administrator=on` |\n| (not set) | `false` | `false` | `administrator=off` |\n\n**Strategy**: Simply use `d.Get(key).(bool)`. The merged value is always correct.\n\n```go\nadmin := d.Get(\"administrator\").(bool)\nif admin {\n    parts = append(parts, \"administrator=on\")\n} else {\n    parts = append(parts, \"administrator=off\")\n}\n```\n\n### Int Fields\n\n**Example**: `login_timer` (0 = infinite, valid value)\n\n| Config | State | d.Get() Result | Command |\n|--------|-------|----------------|---------|\n| `120` | `0` | `120` | `login-timer=120` |\n| `0` | `120` | `0` | `login-timer=0` |\n| (not set) | `120` | `120` | `login-timer=120` |\n| (not set) | `0` | `0` | `login-timer=0` |\n\n**Strategy**: Use `d.Get(key).(int)`. Zero is a valid value and will be correctly preserved/applied.\n\n```go\ntimer := d.Get(\"login_timer\").(int)\nparts = append(parts, fmt.Sprintf(\"login-timer=%d\", timer))\n```\n\n**Special Case**: If a field should be omitted when zero (not sent to router):\n```go\ntimer := d.Get(\"login_timer\").(int)\nif timer > 0 {\n    parts = append(parts, fmt.Sprintf(\"login-timer=%d\", timer))\n}\n// If 0, omit from command (router uses default)\n```\n\n### String Fields\n\n**Example**: `description`\n\n| Config | State | d.Get() Result | Command |\n|--------|-------|----------------|---------|\n| `\"new\"` | `\"old\"` | `\"new\"` | `description=\"new\"` |\n| `\"\"` | `\"old\"` | `\"\"` | `description=\"\"` (explicit empty) |\n| (not set) | `\"old\"` | `\"old\"` | `description=\"old\"` |\n| (not set) | `\"\"` | `\"\"` | (omit or `description=\"\"`) |\n\n**Strategy**: Use `d.Get(key).(string)`. Empty string may be intentional.\n\n```go\ndesc := d.Get(\"description\").(string)\nif desc != \"\" {\n    parts = append(parts, fmt.Sprintf(\"description=%s\", desc))\n}\n// If empty, decide based on RTX behavior:\n// - If router accepts empty: include it\n// - If router treats empty as \"remove\": may omit\n```\n\n### List/Set Fields (Simple Values)\n\n**Example**: `connection` (allowed connection types: serial, telnet, ssh, etc.)\n\nFor simple value lists (strings, ints), the list is treated as a **whole unit** - if user specifies a list, it replaces the entire list.\n\n| Config | State | d.Get() Result | Command |\n|--------|-------|----------------|---------|\n| `[\"ssh\"]` | `[\"telnet\"]` | `[\"ssh\"]` | `connection=ssh` |\n| `[]` | `[\"telnet\"]` | `[]` | (explicit empty - remove all) |\n| (not set) | `[\"telnet\"]` | `[\"telnet\"]` | `connection=telnet` |\n| (not set) | `[]` | `[]` | (no connection specified) |\n\n**Strategy**: Use `d.Get(key).([]interface{})` and convert to `[]string`.\n\n```go\nfunc getStringList(d *schema.ResourceData, key string) []string {\n    raw := d.Get(key).([]interface{})\n    if len(raw) == 0 {\n        return nil  // or []string{} depending on semantics\n    }\n    result := make([]string, len(raw))\n    for i, v := range raw {\n        result[i] = v.(string)\n    }\n    return result\n}\n\n// Usage\nconnections := getStringList(d, \"connection\")\nif len(connections) > 0 {\n    parts = append(parts, fmt.Sprintf(\"connection=%s\", strings.Join(connections, \",\")))\n}\n```\n\n**Note on Empty Lists**: An explicitly empty list `[]` vs not specified requires `GetOk()` to distinguish:\n```go\nif v, ok := d.GetOk(\"connection\"); ok {\n    // Explicitly set (could be empty list)\n    connections := convertToStringList(v)\n    // Include in command even if empty\n} else {\n    // Not set - use state value\n    connections := getStringList(d, \"connection\")\n}\n```\n\n### List/Set Fields (Nested Blocks) - Recursive Merge\n\n**Example**: `filter_rules` block with multiple rules, each having its own fields\n\n```hcl\nresource \"rtx_firewall\" \"example\" {\n  filter_rules {\n    id       = 1\n    action   = \"accept\"\n    protocol = \"tcp\"\n    # port not specified - should preserve current value\n  }\n  filter_rules {\n    id       = 2\n    action   = \"deny\"\n    # This is a new rule\n  }\n}\n```\n\nFor nested block lists, we need **recursive merge by identifier**:\n\n1. **Match by identifier**: Use a unique field (e.g., `id`, `name`) to match config blocks with state blocks\n2. **Merge each block**: For matched blocks, apply field-level merge (config value or state value)\n3. **Handle additions**: Blocks in config but not in state are new additions\n4. **Handle deletions**: Blocks in state but not in config are removed (if user explicitly removed them)\n\n**Strategy**:\n\n```go\n// MergeNestedBlocks merges config blocks with state blocks by identifier\nfunc MergeNestedBlocks(d *schema.ResourceData, key string, idField string) []map[string]interface{} {\n    // Get config blocks (what user specified)\n    configBlocks := getBlockList(d, key, true)  // from config\n    // Get state blocks (current values)\n    stateBlocks := getBlockList(d, key, false)  // from state\n\n    // Build state lookup by identifier\n    stateByID := make(map[interface{}]map[string]interface{})\n    for _, block := range stateBlocks {\n        if id, ok := block[idField]; ok {\n            stateByID[id] = block\n        }\n    }\n\n    // Merge each config block with corresponding state block\n    result := make([]map[string]interface{}, 0, len(configBlocks))\n    for _, configBlock := range configBlocks {\n        id := configBlock[idField]\n        if stateBlock, exists := stateByID[id]; exists {\n            // Merge: config values override, unset fields use state values\n            merged := mergeBlock(configBlock, stateBlock)\n            result = append(result, merged)\n        } else {\n            // New block - use config values only\n            result = append(result, configBlock)\n        }\n    }\n\n    return result\n}\n\n// mergeBlock merges two blocks, preferring configBlock values when set\nfunc mergeBlock(configBlock, stateBlock map[string]interface{}) map[string]interface{} {\n    result := make(map[string]interface{})\n\n    // Start with state values\n    for k, v := range stateBlock {\n        result[k] = v\n    }\n\n    // Override with config values (recursively for nested structures)\n    for k, v := range configBlock {\n        if nested, ok := v.([]interface{}); ok && len(nested) > 0 {\n            // Recursive merge for nested blocks\n            if stateNested, ok := stateBlock[k].([]interface{}); ok {\n                result[k] = mergeNestedLists(nested, stateNested)\n            } else {\n                result[k] = v\n            }\n        } else {\n            result[k] = v\n        }\n    }\n\n    return result\n}\n```\n\n**Example Merge Scenario**:\n\n```\nState:\n  filter_rules:\n    - id: 1, action: \"accept\", protocol: \"tcp\", port: 80\n    - id: 2, action: \"accept\", protocol: \"udp\", port: 53\n\nConfig:\n  filter_rules:\n    - id: 1, action: \"deny\"  # Change action, keep other fields\n    - id: 3, action: \"accept\", protocol: \"icmp\"  # New rule\n\nResult (after merge):\n  filter_rules:\n    - id: 1, action: \"deny\", protocol: \"tcp\", port: 80  # Merged\n    - id: 3, action: \"accept\", protocol: \"icmp\"  # New\n    # id: 2 removed (not in config)\n```\n\n**Important Considerations for Nested Blocks**:\n\n1. **Identifier Selection**: Choose a field that uniquely identifies each block (e.g., `id`, `name`, `index`)\n2. **Deletion Semantics**: Blocks not in config are removed - this is intentional Terraform behavior\n3. **Deep Nesting**: Apply recursively for blocks within blocks\n4. **Order Sensitivity**: Some resources may be order-sensitive; preserve order from config\n\n## Summary Table: Type Handling\n\n| Type | Get Method | Zero Value | Merge Strategy |\n|------|-----------|------------|----------------|\n| Bool | `d.Get(key).(bool)` | `false` | Direct use - always has value |\n| Int | `d.Get(key).(int)` | `0` | Direct use - 0 may be valid |\n| String | `d.Get(key).(string)` | `\"\"` | Direct use - empty may be valid |\n| List (simple) | `d.Get(key).([]interface{})` | `nil`/`[]` | Replace entire list |\n| List (nested) | Custom merge function | `nil`/`[]` | **Recursive merge by identifier** |\n| Set | `d.Get(key).(*schema.Set)` | empty set | Replace entire set |\n\n## Schema Changes\n\n### Current Schema Pattern (Problematic)\n\n```go\n\"administrator\": {\n    Type:        schema.TypeBool,\n    Optional:    true,\n    Description: \"Whether user has administrator privileges\",\n},\n```\n\n### New Schema Pattern\n\n```go\n\"administrator\": {\n    Type:        schema.TypeBool,\n    Optional:    true,\n    Computed:    true,  // Allow reading current value\n    Description: \"Whether user has administrator privileges\",\n},\n```\n\nThe `Computed: true` flag allows Terraform to:\n1. Accept user-specified values (Optional)\n2. Read and preserve current values from the router (Computed)\n3. Show accurate diffs in `terraform plan`\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Field Type Mismatch**\n   - **Handling:** Use type assertions with ok check, return diagnostic on failure\n   - **User Impact:** Clear error message indicating which field has incorrect type\n\n2. **Router Command Failure**\n   - **Handling:** Existing error handling patterns apply\n   - **User Impact:** Command output included in error message\n\n3. **Partial Update Failure**\n   - **Handling:** If attribute command fails, user creation still succeeds but attributes may not be set\n   - **User Impact:** Error clearly indicates which part failed\n\n## Testing Strategy\n\n### Unit Testing\n\n- Test `GetOptional*` helper functions with:\n  - Value explicitly set\n  - Value not set (GetOk returns false)\n  - Value set to zero/false/empty (should be detected as set)\n- Test command builders with:\n  - All fields set\n  - No fields set (should return empty command)\n  - Mix of set and unset fields\n\n### Integration Testing\n\n- Test resource create with missing optional fields\n- Test resource update preserving unspecified fields\n- Test resource import followed by apply (no changes expected)\n\n### Regression Testing\n\n- **Administrator Lockout Scenario**: Create user without `administrator` field, verify it doesn't get set to `off`\n- **Full Attribute Test**: Create user with all attributes, update only username, verify attributes preserved\n\n## Implementation Order\n\n1. **Phase 1**: Create shared helper utilities (`field_tracking.go`)\n2. **Phase 2**: Update client interfaces to use pointer types\n3. **Phase 3**: Update command builders to handle nil values\n4. **Phase 4**: Update resource Create/Update functions\n5. **Phase 5**: Add/update tests\n6. **Phase 6**: Audit all other resources for same pattern\n\n## Backward Compatibility\n\n### Terraform State Compatibility\n\n- Existing state files remain compatible\n- `Computed: true` allows reading values not in config\n- No state migration required\n\n### Configuration Compatibility\n\n- Existing configs with explicit values continue to work\n- Configs without optional fields now correctly preserve router values\n- No breaking changes to HCL syntax\n\n## Performance Considerations\n\n- `GetOk()` and `d.Get()` overhead is minimal (simple map lookup)\n- **No additional router API calls**: Current values are already in Terraform state\n  - Terraform calls `Read` before `Update` to refresh state\n  - `d.Get()` returns merged value (config or state) automatically\n  - Zero additional SSH commands needed\n- Command strings will be complete (all fields included)\n\n## Security Considerations\n\n- Prevents accidental removal of administrator privileges\n- Sensitive fields (passwords) already handled separately\n- No new security concerns introduced\n",
  "fileStats": {
    "size": 21403,
    "lines": 629,
    "lastModified": "2026-01-24T11:30:29.054Z"
  },
  "comments": []
}