{
  "id": "snapshot_1768919748175_nbpn7fxzk",
  "approvalId": "approval_1768919748141_bh2urbj4p",
  "approvalTitle": "zerolog-integration Design",
  "version": 1,
  "timestamp": "2026-01-20T14:35:48.175Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nこのドキュメントでは、terraform-provider-rtxにzerologを導入するための技術設計を定義します。標準`log`パッケージから`zerolog`への移行により、構造化ロギング、パフォーマンス向上、およびより良いデバッグ体験を実現します。\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **Go 1.23**: zerologはGo 1.23と完全に互換性があります\n- **terraform-plugin-log v0.9.0**: zerologはterraform-plugin-logと並行して使用可能（内部ログ用）\n- **Parser Registry Pattern**: 既存のパターンを維持しながら、ロガーをコンテキスト経由で伝播\n\n### Project Structure (structure.md)\n\n- `internal/logging/`: 新規ロギングパッケージを追加\n- `internal/client/`: SSH/クライアント層のログ移行\n- `internal/provider/`: リソース層のログ移行\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **SanitizeCommandForLog**: `internal/client/log_sanitizer.go` - 機密データのマスキングを継続使用\n- **sensitivePatterns**: 既存のパターンリストをzerologのフックに統合\n- **TF_LOG環境変数**: Terraformの既存のログレベル設定を尊重\n\n### Integration Points\n\n- **Provider ConfigureContextFunc**: ロガーの初期化ポイント\n- **context.Context**: ロガーのコンテキスト伝播\n- **既存の74ファイル**: 段階的に`log.Printf`を`zerolog`に置換\n\n## Architecture\n\n### Modular Design Principles\n\n- **Single File Responsibility**: `internal/logging/logger.go`がロガー設定を集約\n- **Component Isolation**: 各パッケージは`logging.FromContext(ctx)`でロガーを取得\n- **Service Layer Separation**: ロギングロジックはビジネスロジックから分離\n- **Utility Modularity**: サニタイザーはフックとして再利用\n\n```mermaid\ngraph TD\n    subgraph \"Initialization\"\n        A[Provider.ConfigureContextFunc] --> B[logging.NewLogger]\n        B --> C[Set Log Level from TF_LOG]\n        C --> D[Configure Output Format]\n    end\n\n    subgraph \"Runtime\"\n        E[context.Context] --> F[logging.FromContext]\n        F --> G[zerolog.Logger]\n        G --> H[Structured Log Output]\n    end\n\n    subgraph \"Components\"\n        I[client/executor] --> F\n        J[client/*_service] --> F\n        K[provider/resource_*] --> F\n    end\n\n    D --> E\n    H --> L[stdout/stderr]\n```\n\n## Components and Interfaces\n\n### Component 1: logging package\n\n- **Purpose:** ロガーの設定、初期化、コンテキスト管理を提供\n- **Location:** `internal/logging/logger.go`\n- **Interfaces:**\n  ```go\n  // NewLogger creates a configured zerolog logger\n  func NewLogger() zerolog.Logger\n\n  // WithContext adds logger to context\n  func WithContext(ctx context.Context, logger zerolog.Logger) context.Context\n\n  // FromContext retrieves logger from context\n  func FromContext(ctx context.Context) zerolog.Logger\n\n  // SetLevel sets global log level\n  func SetLevel(level string)\n  ```\n- **Dependencies:** `github.com/rs/zerolog`\n- **Reuses:** TF_LOG環境変数の読み取りロジック\n\n### Component 2: Sanitizing Hook\n\n- **Purpose:** ログ出力前に機密データを自動的にマスク\n- **Location:** `internal/logging/sanitizer.go`\n- **Interfaces:**\n  ```go\n  // SanitizingHook implements zerolog.Hook\n  type SanitizingHook struct{}\n\n  // Run sanitizes sensitive fields before logging\n  func (h SanitizingHook) Run(e *zerolog.Event, level zerolog.Level, msg string)\n  ```\n- **Dependencies:** `internal/client.SanitizeCommandForLog`\n- **Reuses:** 既存のsensitivePatterns, redactedMessage\n\n### Component 3: Logger Integration in Client\n\n- **Purpose:** SSH/クライアント層で構造化ログを出力\n- **Location:** `internal/client/*.go`（既存ファイルの修正）\n- **Interfaces:** コンテキストからロガーを取得し、構造化フィールドでログ出力\n- **Dependencies:** `internal/logging`\n- **Reuses:** 既存のSanitizeCommandForLog関数\n\n### Component 4: Logger Integration in Provider\n\n- **Purpose:** リソースCRUD操作で構造化ログを出力\n- **Location:** `internal/provider/*.go`（既存ファイルの修正）\n- **Interfaces:** コンテキストからロガーを取得し、リソース情報をフィールドとして付加\n- **Dependencies:** `internal/logging`\n- **Reuses:** 既存のリソース識別子\n\n## Data Models\n\n### Logger Configuration\n\n```go\ntype LogConfig struct {\n    Level       zerolog.Level  // Log level (debug, info, warn, error)\n    Format      string         // \"json\" or \"console\"\n    Output      io.Writer      // Output destination (os.Stderr)\n    TimeFormat  string         // Timestamp format\n}\n```\n\n### Log Context Fields\n\n```go\n// Common fields added to all logs\ntype LogContext struct {\n    Component   string  // \"client\", \"provider\", \"parser\"\n    Operation   string  // \"create\", \"read\", \"update\", \"delete\", \"connect\"\n    ResourceType string // \"rtx_static_route\", \"rtx_ospf\", etc.\n    ResourceID  string  // Resource identifier\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **TF_LOG環境変数が不正な値**\n   - **Handling:** デフォルトのwarnレベルにフォールバック、警告ログを出力\n   - **User Impact:** ログは出力されるが、期待したレベルではない可能性\n\n2. **コンテキストにロガーが存在しない**\n   - **Handling:** グローバルロガーにフォールバック\n   - **User Impact:** ログは出力されるが、コンテキスト情報が欠落\n\n3. **ログ出力先への書き込み失敗**\n   - **Handling:** zerologは内部でエラーをハンドリング、メイン処理は継続\n   - **User Impact:** 一部のログが欠落する可能性\n\n## Testing Strategy\n\n### Unit Testing\n\n- **logger_test.go**: ロガー初期化、レベル設定のテスト\n- **sanitizer_test.go**: サニタイザーフックが機密データをマスクすることを検証\n- **既存テスト**: `log.Printf`の出力に依存するテストの更新\n\n### Integration Testing\n\n- **context propagation**: ロガーがコンテキスト経由で正しく伝播されることを検証\n- **TF_LOG integration**: 環境変数によるログレベル制御のテスト\n\n### End-to-End Testing\n\n- **Terraform apply**: 実際のTerraform操作でログが正しく出力されることを確認\n- **JSON output**: 運用モードでJSON形式のログが出力されることを確認\n- **Console output**: 開発モードで人間が読みやすいログが出力されることを確認\n\n## Migration Strategy\n\n### Phase 1: Infrastructure (REQ-1, REQ-2)\n\n1. zerolog依存関係を追加\n2. `internal/logging/`パッケージを作成\n3. Provider初期化時にロガーを設定\n\n### Phase 2: Client Layer (REQ-3, REQ-5)\n\n1. `internal/client/`の各ファイルで`log.Printf`を置換\n2. SSH接続、コマンド実行に構造化フィールドを追加\n3. コンテキスト伝播を実装\n\n### Phase 3: Provider Layer (REQ-4)\n\n1. `internal/provider/`の各リソースファイルで`log.Printf`を置換\n2. CRUD操作に構造化フィールドを追加\n\n### Phase 4: Validation (REQ-6)\n\n1. 全テストの実行と修正\n2. 既存機能の動作確認\n",
  "fileStats": {
    "size": 7301,
    "lines": 205,
    "lastModified": "2026-01-20T14:35:41.922Z"
  },
  "comments": []
}