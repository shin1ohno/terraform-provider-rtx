{
  "id": "snapshot_1769055666050_28vksdzl9",
  "approvalId": "approval_1769055666038_mip3mq1ik",
  "approvalTitle": "Design: Parser Import Bugs Fix",
  "version": 1,
  "timestamp": "2026-01-22T04:21:06.050Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Parser Import Bugs\n\n## Overview\n\n本設計書では、Terraform import機能のテスト中に発見された5つのパーサーバグの修正方法を定義します。これらのバグにより、RTXルーターからの設定インポートが不完全になり、`terraform plan`で差分が発生しています。\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- 既存のパーサーパッケージ構造に従う\n- ユニットテストでカバレッジを確保\n- Go標準ライブラリのみを使用（外部依存なし）\n\n### Project Structure (structure.md)\n- パーサーは `internal/rtx/parsers/` に配置\n- リソースは `internal/provider/` に配置\n- クライアントは `internal/client/` に配置\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **parseFilterList関数**: interface_config.goで定義済み、IPv6でも共有可能\n- **isValidIPForDNS関数**: dns.goで定義済み、IPアドレス判定に使用\n- **ParseIPFilterDynamicConfig**: ip_filter.goで定義済み、IPv6版の参考に\n\n### Integration Points\n- **RTX SSH Client**: 既存のSSH接続を使用してコマンド実行\n- **Terraform Resource State**: 既存のスキーマ構造を維持\n\n## Architecture\n\n### Bug Fix Strategy\n\n```mermaid\ngraph TD\n    A[Filter List Bug] --> B[preprocessWrappedLines修正]\n    B --> C[テストケース追加]\n\n    D[DNS Bug] --> E[parseDNSServerSelectFields修正]\n    E --> F[フィールド順序ロジック改善]\n\n    G[DHCP Bug] --> H[scopePattern正規表現修正]\n    H --> I[network取得ロジック追加]\n\n    J[NAT Bug] --> K[ParseNATMasqueradeConfig修正]\n    K --> L[grep patternの改善]\n\n    M[IPv6 Dynamic Bug] --> N[GetIPv6FilterDynamicConfig実装]\n    N --> O[ParseIPv6FilterDynamicConfig作成]\n```\n\n## Component Details\n\n### Component 1: Filter List Parsing Fix\n\n**File:** `internal/rtx/parsers/interface_config.go`\n\n**Problem:**\n- `preprocessWrappedLines`関数が継続行を正しく検出できていない\n- 継続行は先頭にスペース1つがあり、その後に数字が続く\n- 現在のパターン `^\\d` は先頭スペースを考慮していない\n\n**Root Cause:**\nRTXの出力では、行が80文字を超えると次の行に継続される。継続行は先頭にスペース1つが入り、その後に数字が続く。\n\n```\nip lan2 secure filter in 200020 200021 200022 200023 200024 200025 200103 200100\n 200102 200104 200101 200105 200099\n```\n\n現在のコードは `strings.TrimSpace` を先に行ってから `^\\d` でマッチしているが、実際のRTX出力では継続行は先頭にスペースがある。\n\n**Solution:**\n```go\n// preprocessWrappedLines修正案\nfunc preprocessWrappedLines(input string) string {\n    // 継続行パターン: 行頭がスペースで始まり、その後に数字が続く\n    // RTXは80文字で折り返し、継続行は \" <数字>\" で始まる\n    continuationPattern := regexp.MustCompile(`^\\s+\\d`)\n\n    lines := strings.Split(input, \"\\n\")\n    var result []string\n\n    for i := 0; i < len(lines); i++ {\n        line := lines[i]\n\n        // 次の行が継続行かチェック（スペースで始まり数字が続く）\n        for i+1 < len(lines) && continuationPattern.MatchString(lines[i+1]) {\n            i++\n            line = line + \" \" + strings.TrimSpace(lines[i])\n        }\n\n        result = append(result, line)\n    }\n\n    return strings.Join(result, \"\\n\")\n}\n```\n\n**Testing:**\n- 10+フィルター番号を含む折り返し行のテスト\n- 200100などの6桁番号が正しくパースされることを確認\n- dynamic キーワードを含む複合行のテスト\n\n---\n\n### Component 2: DNS server_select Parsing Fix\n\n**File:** `internal/rtx/parsers/dns.go`\n\n**Problem:**\n- `parseDNSServerSelectFields`関数のフィールド順序検出が不正確\n- 2つ目のサーバーIPがquery_patternとして認識される\n\n**Root Cause:**\nコマンドフォーマット: `dns server select <id> <server1> [<server2>] [edns=on] [<record_type>] <query_pattern>`\n\n現在のパーサーは:\n1. サーバーIPを1〜2個パース\n2. edns=onをチェック\n3. record_typeをチェック\n4. query_patternをパース\n\n問題は、record_typeのチェックで`.`（ドット）をquery_patternとして正しく認識できていない場合がある。\n\n**Solution:**\n```go\n// parseDNSServerSelectFields修正案\nfunc parseDNSServerSelectFields(id int, rest string) *DNSServerSelect {\n    fields := strings.Fields(rest)\n    if len(fields) < 2 {\n        return nil\n    }\n\n    sel := &DNSServerSelect{\n        ID:      id,\n        Servers: []string{},\n    }\n\n    i := 0\n\n    // Phase 1: サーバーをパース（最初の1〜2つのIP）\n    for i < len(fields) && isValidIPForDNS(fields[i]) {\n        sel.Servers = append(sel.Servers, fields[i])\n        i++\n        if len(sel.Servers) >= 2 {\n            break // 最大2サーバー\n        }\n    }\n\n    if len(sel.Servers) == 0 {\n        return nil\n    }\n\n    // Phase 2: edns=onをチェック\n    if i < len(fields) && strings.ToLower(fields[i]) == \"edns=on\" {\n        sel.EDNS = true\n        i++\n    }\n\n    // Phase 3: record_typeをチェック（\".\"は除外、それはquery_pattern）\n    if i < len(fields) && validRecordTypes[strings.ToLower(fields[i])] && fields[i] != \".\" {\n        sel.RecordType = strings.ToLower(fields[i])\n        i++\n    }\n\n    // Phase 4: query_pattern（必須）\n    if i < len(fields) {\n        sel.QueryPattern = fields[i]\n        i++\n    }\n\n    // ...残りのフィールド\n    return sel\n}\n```\n\n**Testing:**\n- `dns server select 500000 1.1.1.1 1.0.0.1 edns=on a .` のパース\n- 2サーバー構成でquery_patternが`.`の場合\n- record_type `aaaa` が正しく認識されることを確認\n\n---\n\n### Component 3: DHCP Scope Parsing Fix\n\n**File:** `internal/rtx/parsers/dhcp_scope.go`\n\n**Problem:**\n- `scopePattern`正規表現がnetworkフィールドを正しくキャプチャできていない可能性\n- `expire`キーワードのパース問題\n\n**Root Cause:**\n現在のパターン:\n```go\nscopePattern := regexp.MustCompile(`^\\s*dhcp\\s+scope\\s+(\\d+)\\s+([0-9.]+/\\d+)(?:\\s+gateway\\s+([0-9.]+))?(?:\\s+expire\\s+(\\S+))?\\s*$`)\n```\n\nRTXの出力フォーマット:\n```\ndhcp scope 1 192.168.0.0/16 expire 24:00\n```\n\n問題: `gateway`がオプショナルだが、実際のコマンドでは`gateway`が省略されて`expire`が直接来る場合がある。\n\n**Solution:**\n```go\n// scopePattern修正案\n// gateway is deprecated, directly expect expire after network\nscopePattern := regexp.MustCompile(`^\\s*dhcp\\s+scope\\s+(\\d+)\\s+([0-9.]+/\\d+)(?:\\s+expire\\s+(\\S+))?\\s*$`)\n```\n\n**Testing:**\n- `dhcp scope 1 192.168.0.0/16 expire 24:00` のパース\n- networkフィールドが正しく`192.168.0.0/16`になることを確認\n- lease_timeが`24h`に変換されることを確認\n\n---\n\n### Component 4: NAT Masquerade Import Fix\n\n**File:** `internal/rtx/parsers/nat_masquerade.go`\n\n**Problem:**\n- インポート時に「not found」エラーが発生\n- `BuildShowNATDescriptorCommand`のgrepパターンが適切でない可能性\n\n**Root Cause:**\n現在のshowコマンド:\n```go\nreturn fmt.Sprintf(\"show config | grep -E \\\"nat descriptor (type|address outer|address inner|masquerade static) %d \\\"\", id)\n```\n\n問題:\n1. 末尾のスペースがマッチを妨げる可能性\n2. `type`行では数字の後にスペースがなく`masquerade`が続く\n\n**Solution:**\n```go\n// BuildShowNATDescriptorCommand修正案\nfunc BuildShowNATDescriptorCommand(id int) string {\n    // nat descriptor type 1000 masquerade\n    // nat descriptor address outer 1000 primary\n    // nat descriptor masquerade static 1000 1 ...\n    return fmt.Sprintf(\"show config | grep \\\"nat descriptor\\\" | grep -E \\\"( %d | %d$)\\\"\", id, id)\n}\n```\n\nまたは、より広いパターンでフェッチしてパーサーでフィルタリング:\n```go\nfunc BuildShowNATDescriptorCommand(id int) string {\n    return \"show config | grep \\\"nat descriptor\\\"\"\n}\n```\n\n**Testing:**\n- descriptor ID 1000のNAT masqueradeが正しくパースされる\n- static entriesが全て取得される\n\n---\n\n### Component 5: IPv6 Filter Dynamic Read Implementation\n\n**Files:**\n- `internal/rtx/parsers/ip_filter.go` - IPv6版パーサー追加\n- `internal/client/rtx_ipv6_filter_dynamic.go` - クライアント実装\n\n**Problem:**\n- `GetIPv6FilterDynamicConfig`が未実装または不完全\n- エラーメッセージ「IPv6 filter dynamic config not implemented」\n\n**Solution:**\n\n**Step 1: パーサー追加 (ip_filter.go)**\n```go\n// ParseIPv6FilterDynamicConfig parses IPv6 dynamic filter lines\nfunc ParseIPv6FilterDynamicConfig(raw string) ([]IPFilterDynamic, error) {\n    filters := []IPFilterDynamic{}\n    lines := strings.Split(raw, \"\\n\")\n\n    // Pattern: ipv6 filter dynamic <n> <src> <dst> <protocol> [syslog on]\n    dynamicPattern := regexp.MustCompile(`^\\s*ipv6\\s+filter\\s+dynamic\\s+(\\d+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)(?:\\s+(.*))?$`)\n    syslogPattern := regexp.MustCompile(`\\bsyslog\\s+on\\b`)\n\n    for _, line := range lines {\n        line = strings.TrimSpace(line)\n        if line == \"\" || strings.HasPrefix(line, \"#\") {\n            continue\n        }\n\n        if matches := dynamicPattern.FindStringSubmatch(line); len(matches) >= 5 {\n            number, err := strconv.Atoi(matches[1])\n            if err != nil {\n                continue\n            }\n\n            filter := IPFilterDynamic{\n                Number:   number,\n                Source:   matches[2],\n                Dest:     matches[3],\n                Protocol: matches[4],\n            }\n\n            if len(matches) > 5 && matches[5] != \"\" {\n                if syslogPattern.MatchString(matches[5]) {\n                    filter.SyslogOn = true\n                }\n            }\n\n            filters = append(filters, filter)\n        }\n    }\n\n    return filters, nil\n}\n```\n\n**Step 2: クライアント実装**\n```go\n// GetIPv6FilterDynamicConfig retrieves IPv6 dynamic filter configuration\nfunc (c *RTXClient) GetIPv6FilterDynamicConfig(ctx context.Context) (*IPv6FilterDynamicConfig, error) {\n    raw, err := c.RunCommand(ctx, \"show config | grep \\\"ipv6 filter dynamic\\\"\")\n    if err != nil {\n        return nil, err\n    }\n\n    filters, err := parsers.ParseIPv6FilterDynamicConfig(raw)\n    if err != nil {\n        return nil, err\n    }\n\n    if len(filters) == 0 {\n        return &IPv6FilterDynamicConfig{Entries: []IPv6FilterDynamicEntry{}}, nil\n    }\n\n    config := &IPv6FilterDynamicConfig{\n        Entries: make([]IPv6FilterDynamicEntry, 0, len(filters)),\n    }\n\n    for _, f := range filters {\n        config.Entries = append(config.Entries, IPv6FilterDynamicEntry{\n            Number:   f.Number,\n            Source:   f.Source,\n            Dest:     f.Dest,\n            Protocol: f.Protocol,\n            Syslog:   f.SyslogOn,\n        })\n    }\n\n    return config, nil\n}\n```\n\n**Testing:**\n- 8エントリーのIPv6 dynamic filterが正しくパースされる\n- syslog=onオプションの検出\n- 空の設定でもエラーにならないことを確認\n\n---\n\n## Data Models\n\n### Existing Models (変更なし)\n```go\n// IPFilterDynamic - ip_filter.go\ntype IPFilterDynamic struct {\n    Number   int    `json:\"number\"`\n    Source   string `json:\"source\"`\n    Dest     string `json:\"dest\"`\n    Protocol string `json:\"protocol\"`\n    SyslogOn bool   `json:\"syslog,omitempty\"`\n}\n\n// DNSServerSelect - dns.go\ntype DNSServerSelect struct {\n    ID             int      `json:\"id\"`\n    Servers        []string `json:\"servers\"`\n    EDNS           bool     `json:\"edns\"`\n    RecordType     string   `json:\"record_type\"`\n    QueryPattern   string   `json:\"query_pattern\"`\n    OriginalSender string   `json:\"original_sender\"`\n    RestrictPP     int      `json:\"restrict_pp\"`\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **パース失敗時**\n   - **Handling:** 警告ログを出力し、空のスライスを返す\n   - **User Impact:** terraform planで差分が表示される\n\n2. **SSH接続エラー**\n   - **Handling:** 既存のエラーハンドリングを使用\n   - **User Impact:** エラーメッセージが表示される\n\n3. **予期しないフォーマット**\n   - **Handling:** パースをスキップしてログに記録\n   - **User Impact:** 一部の設定がインポートされない\n\n## Testing Strategy\n\n### Unit Testing\n- 各パーサー関数のテストケース追加\n- 実際のRTX出力を模したテストデータ使用\n- エッジケース（空入力、不正フォーマット）のテスト\n\n### Integration Testing\n- 実機との接続テスト（TF_ACC=1）\n- インポート→plan→差分なしの確認\n\n### Test Files to Create/Update\n1. `internal/rtx/parsers/interface_config_test.go` - 折り返し行テスト追加\n2. `internal/rtx/parsers/dns_test.go` - server_selectテスト追加\n3. `internal/rtx/parsers/dhcp_scope_test.go` - networkパーステスト追加\n4. `internal/rtx/parsers/nat_masquerade_test.go` - import用テスト追加\n5. `internal/rtx/parsers/ip_filter_test.go` - IPv6 dynamicテスト追加\n",
  "fileStats": {
    "size": 13101,
    "lines": 419,
    "lastModified": "2026-01-22T04:20:59.008Z"
  },
  "comments": []
}