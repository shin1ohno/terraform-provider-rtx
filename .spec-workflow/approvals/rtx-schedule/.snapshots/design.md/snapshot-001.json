{
  "id": "snapshot_1768799801428_gzhq6pln6",
  "approvalId": "approval_1768799801421_sbwtrzajf",
  "approvalTitle": "Design: rtx_schedule resource",
  "version": 1,
  "timestamp": "2026-01-19T05:16:41.428Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: rtx_schedule\n\n## Overview\n\nThe `rtx_schedule` resource enables Terraform-based management of scheduled tasks and time-based automation on Yamaha RTX series routers. Following Cisco Kron scheduler naming patterns, this resource manages scheduled command execution including one-time, recurring, and startup schedules.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`internal/client/dhcp_scope_service.go`**: Pattern for service layer implementation with CRUD operations.\n- **`internal/client/interfaces.go`**: Extend the `Client` interface with schedule methods.\n- **`internal/rtx/parsers/dhcp_scope.go`**: Reference for parser implementation and command builders.\n- **`internal/provider/resource_rtx_dhcp_scope.go`**: Template for Terraform resource structure.\n\n### Integration Points\n\n- **`rtxClient`**: Add schedule methods for CRUD operations\n- **`Executor`**: Use existing SSH command execution infrastructure\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph Provider Layer\n        TFResource[resource_rtx_schedule.go]\n    end\n\n    subgraph Client Layer\n        Client[client.go - Interface Extension]\n        ScheduleService[schedule_service.go]\n    end\n\n    subgraph Parser Layer\n        ScheduleParser[schedule.go]\n        Commands[Command Builders]\n        OutputParser[Output Parsers]\n    end\n\n    TFResource --> Client\n    Client --> ScheduleService\n    ScheduleService --> ScheduleParser\n    ScheduleParser --> Commands\n    ScheduleParser --> OutputParser\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: `ScheduleService` handles all schedule CRUD operations\n- **Component Isolation**: Parser, service, and resource layers clearly separated\n- **Service Layer Separation**: Service encapsulates all schedule logic\n- **Utility Modularity**: Shared validation functions for time/date operations\n\n## Components and Interfaces\n\n### Component 1: ScheduleService (`internal/client/schedule_service.go`)\n\n- **Purpose:** Handles all schedule CRUD operations against the RTX router\n- **Interfaces:**\n  ```go\n  type ScheduleService struct {\n      executor Executor\n      client   *rtxClient\n  }\n\n  func (s *ScheduleService) Create(ctx context.Context, schedule Schedule) error\n  func (s *ScheduleService) Get(ctx context.Context, scheduleID int) (*Schedule, error)\n  func (s *ScheduleService) Update(ctx context.Context, schedule Schedule) error\n  func (s *ScheduleService) Delete(ctx context.Context, scheduleID int) error\n  func (s *ScheduleService) List(ctx context.Context) ([]Schedule, error)\n  ```\n- **Dependencies:** `Executor`, `rtxClient`, `parsers.ScheduleParser`\n- **Reuses:** Pattern from service layer implementations\n\n### Component 2: ScheduleParser (`internal/rtx/parsers/schedule.go`)\n\n- **Purpose:** Parses RTX router output for schedule configuration and builds commands\n- **Interfaces:**\n  ```go\n  type Schedule struct {\n      ID          int      `json:\"id\"`\n      Name        string   `json:\"name,omitempty\"`\n      AtTime      string   `json:\"at_time,omitempty\"`\n      DayOfWeek   string   `json:\"day_of_week,omitempty\"`\n      Date        string   `json:\"date,omitempty\"`\n      Recurring   bool     `json:\"recurring\"`\n      OnStartup   bool     `json:\"on_startup\"`\n      PolicyList  string   `json:\"policy_list,omitempty\"`\n      Commands    []string `json:\"commands,omitempty\"`\n      Enabled     bool     `json:\"enabled\"`\n  }\n\n  func ParseScheduleConfig(raw string) ([]Schedule, error)\n  func BuildScheduleAtCommand(id int, time, command string) string\n  func BuildScheduleAtStartupCommand(id int, command string) string\n  func BuildScheduleAtDateTimeCommand(id int, date, time, command string) string\n  func BuildSchedulePPCommand(ppNum int, day, time, action string) string\n  func BuildDeleteScheduleCommand(id int) string\n  ```\n- **Dependencies:** `regexp`, `strings`, `strconv`, `time`\n- **Reuses:** Time/date validation patterns\n\n### Component 3: Terraform Resource (`internal/provider/resource_rtx_schedule.go`)\n\n- **Purpose:** Terraform resource definition implementing CRUD lifecycle\n- **Interfaces:**\n  ```go\n  func resourceRTXSchedule() *schema.Resource\n  func resourceRTXScheduleCreate(ctx, d, meta) diag.Diagnostics\n  func resourceRTXScheduleRead(ctx, d, meta) diag.Diagnostics\n  func resourceRTXScheduleUpdate(ctx, d, meta) diag.Diagnostics\n  func resourceRTXScheduleDelete(ctx, d, meta) diag.Diagnostics\n  func resourceRTXScheduleImport(ctx, d, meta) ([]*schema.ResourceData, error)\n  ```\n- **Dependencies:** `Client`, `Schedule`, Terraform SDK\n- **Reuses:** Resource patterns from other implementations\n\n### Component 4: Client Interface Extension (`internal/client/interfaces.go`)\n\n- **Purpose:** Extend Client interface with schedule methods\n- **Interfaces:**\n  ```go\n  // Add to existing Client interface:\n  GetSchedule(ctx context.Context, scheduleID int) (*Schedule, error)\n  CreateSchedule(ctx context.Context, schedule Schedule) error\n  UpdateSchedule(ctx context.Context, schedule Schedule) error\n  DeleteSchedule(ctx context.Context, scheduleID int) error\n  ListSchedules(ctx context.Context) ([]Schedule, error)\n  ```\n- **Dependencies:** Existing Client interface\n- **Reuses:** Pattern from existing methods\n\n## Data Models\n\n### Schedule\n\n```go\n// Schedule represents a scheduled task on an RTX router\ntype Schedule struct {\n    ID         int      `json:\"id\"`                    // Schedule ID\n    Name       string   `json:\"name,omitempty\"`        // Description\n    AtTime     string   `json:\"at_time,omitempty\"`     // Time (HH:MM format)\n    DayOfWeek  string   `json:\"day_of_week,omitempty\"` // monday, tuesday, etc.\n    Date       string   `json:\"date,omitempty\"`        // Date (YYYY/MM/DD format)\n    Recurring  bool     `json:\"recurring\"`             // Recurring schedule\n    OnStartup  bool     `json:\"on_startup\"`            // Execute on startup\n    PolicyList string   `json:\"policy_list,omitempty\"` // Associated policy name\n    Commands   []string `json:\"commands,omitempty\"`    // Commands to execute\n    Enabled    bool     `json:\"enabled\"`               // Schedule enabled\n}\n```\n\n### Terraform Schema\n\n```hcl\n# Kron policy (command list)\nresource \"rtx_kron_policy\" \"backup_commands\" {\n  name = \"BACKUP_POLICY\"\n\n  command_lines = [\n    \"copy config sd1:backup/config-$(date +%Y%m%d).txt\"\n  ]\n}\n\n# Daily recurring schedule\nresource \"rtx_kron_schedule\" \"daily_backup\" {\n  id   = 1\n  name = \"DAILY_BACKUP\"\n\n  at_time   = \"02:00\"\n  recurring = true\n\n  policy_list = \"BACKUP_POLICY\"\n}\n\n# Weekly recurring schedule\nresource \"rtx_kron_schedule\" \"weekly_reboot\" {\n  id   = 2\n  name = \"WEEKLY_REBOOT\"\n\n  at_time     = \"04:00\"\n  day_of_week = \"sunday\"\n  recurring   = true\n\n  policy_list = \"REBOOT_POLICY\"\n}\n\nresource \"rtx_kron_policy\" \"reboot_commands\" {\n  name = \"REBOOT_POLICY\"\n\n  command_lines = [\"restart\"]\n}\n\n# Startup schedule\nresource \"rtx_kron_schedule\" \"startup_task\" {\n  id   = 3\n  name = \"STARTUP_LOG\"\n\n  on_startup = true\n\n  policy_list = \"STARTUP_POLICY\"\n}\n\nresource \"rtx_kron_policy\" \"startup_commands\" {\n  name = \"STARTUP_POLICY\"\n\n  command_lines = [\n    \"syslog info 'Router started successfully'\"\n  ]\n}\n\n# One-time schedule\nresource \"rtx_kron_schedule\" \"maintenance\" {\n  id   = 4\n  name = \"MAINTENANCE_WINDOW\"\n\n  date      = \"2026/01/25\"\n  at_time   = \"03:00\"\n  recurring = false\n\n  policy_list = \"MAINTENANCE_POLICY\"\n}\n```\n\n## RTX Command Mapping\n\n### Create Scheduled Task\n\n```\nschedule at <id> <time> <command>\n```\n\nExample: `schedule at 1 02:00 copy config sd1:backup.txt`\n\n### Create Startup Task\n\n```\nschedule at <id> startup <command>\n```\n\nExample: `schedule at 2 startup syslog info \"Router started\"`\n\n### Create Date-Specific Task\n\n```\nschedule at <id> <date> <time> <command>\n```\n\nExample: `schedule at 3 2026/01/25 03:00 restart`\n\n### Create PP Schedule (Connection Control)\n\n```\nschedule pp <n> <day> <time> connect\nschedule pp <n> <day> <time> disconnect\n```\n\nExample: `schedule pp 1 mon-fri 08:00 connect`\n\n### Delete Schedule\n\n```\nno schedule at <id>\n```\n\n### Show Configuration\n\n```\nshow config | grep schedule\nshow schedule\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid Schedule ID**\n   - **Handling:** Validate ID is positive integer\n   - **User Impact:** Clear validation error\n\n2. **Invalid Time Format**\n   - **Handling:** Validate HH:MM format\n   - **User Impact:** Error with expected format\n\n3. **Invalid Date Format**\n   - **Handling:** Validate YYYY/MM/DD format\n   - **User Impact:** Error with expected format\n\n4. **Invalid Day of Week**\n   - **Handling:** Validate day name\n   - **User Impact:** Error with valid day names\n\n5. **Duplicate Schedule ID**\n   - **Handling:** Check for existing schedule\n   - **User Impact:** Error suggesting different ID\n\n6. **Connection/Command Timeout**\n   - **Handling:** Use existing retry logic from `rtxClient`\n   - **User Impact:** Standard Terraform timeout error\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Parser Tests** (`schedule_test.go`):\n  - Parse various RTX `show config` output for schedules\n  - Test command builder functions with different parameters\n  - Test time/date parsing\n\n- **Service Tests** (`schedule_service_test.go`):\n  - Mock executor for service method testing\n  - Test error handling for various failure scenarios\n  - Test recurring vs one-time schedules\n\n### Integration Testing\n\n- **Resource Tests** (`resource_rtx_schedule_test.go`):\n  - Full CRUD lifecycle with mock client\n  - Import functionality testing\n  - Startup schedule testing\n\n### End-to-End Testing\n\n- **Acceptance Tests** (with real RTX router):\n  - Create daily recurring schedule\n  - Create startup schedule\n  - Create one-time schedule\n  - Update schedule time\n  - Delete schedule\n  - Import existing schedule\n\n## File Structure\n\n```\ninternal/\n├── provider/\n│   ├── resource_rtx_schedule.go      # NEW: Terraform resource\n│   └── resource_rtx_schedule_test.go # NEW: Resource tests\n├── client/\n│   ├── interfaces.go                  # MODIFY: Add Schedule types and methods\n│   ├── client.go                      # MODIFY: Add schedule service initialization\n│   ├── schedule_service.go           # NEW: Schedule service implementation\n│   └── schedule_service_test.go      # NEW: Service tests\n└── rtx/\n    └── parsers/\n        ├── schedule.go               # NEW: Parser and command builders\n        └── schedule_test.go          # NEW: Parser tests\n```\n\n## Implementation Notes\n\n1. **Terraform ID**: Use schedule ID as Terraform resource ID.\n\n2. **ForceNew**: Schedule ID is ForceNew. Other attributes support in-place updates.\n\n3. **Policy vs Command**: RTX uses direct commands in schedules. Consider kron_policy as Cisco-compatible wrapper or direct command_lines attribute.\n\n4. **Time Format**: RTX uses HH:MM format. Validate and parse accordingly.\n\n5. **Day of Week**: RTX supports individual days and ranges (mon-fri).\n\n6. **Timezone**: Schedules use router's configured timezone.\n\n7. **Date Variables**: RTX may support $(date +%Y%m%d) style variables in commands.\n\n8. **PP Schedules**: Connection schedules for PP interfaces may need separate resource.\n\n9. **Configuration Save**: Use existing `SaveConfig()` pattern after modifications.\n\n10. **Provider Registration**: Add `resourceRTXSchedule` to provider's resource map.\n\n11. **Multiple Resources**: Consider implementing as kron_policy and kron_schedule for Cisco compatibility, or single unified resource for simplicity.\n",
  "fileStats": {
    "size": 11483,
    "lines": 373,
    "lastModified": "2026-01-19T05:14:44.153Z"
  },
  "comments": []
}