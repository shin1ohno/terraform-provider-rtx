{
  "id": "snapshot_1768909524131_2rn5a6bnd",
  "approvalId": "approval_1768907903817_zane5u2nf",
  "approvalTitle": "Design: Import Fidelity Fix (6 parser bugs)",
  "version": 3,
  "timestamp": "2026-01-20T11:45:24.130Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Import Fidelity Fix\n\n## Overview\n\nThis design addresses 6 critical import fidelity bugs in the RTX Terraform provider's parser layer. These bugs cause data loss and incorrect configuration parsing when importing existing router configurations into Terraform state. The fix targets the parser layer (`internal/rtx/parsers/`) with minimal changes to service and provider layers.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **Parser Registry Pattern**: All parser changes follow the established pattern in `internal/rtx/parsers/`\n- **Round-Trip Fidelity**: Parser output must re-serialize to equivalent RTX CLI commands\n- **Test Coverage**: Each fix includes unit tests with real RTX config samples\n- **Error Handling**: Parser failures produce clear error messages with line-level detail\n\n### Project Structure (structure.md)\n\n- **Parsers**: Primary changes in `internal/rtx/parsers/*.go`\n- **Tests**: Corresponding `*_test.go` files with testdata fixtures\n- **Provider**: Schema adjustments in `internal/provider/resource_rtx_*.go` (REQ-6 only)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n| Component | File | Reuse Strategy |\n|-----------|------|----------------|\n| `parseDNSServerSelectFields` | `parsers/dns.go` | Refactor field parsing order |\n| `parseFilterList` | `parsers/interface_config.go` | Verify correctness, likely OK |\n| `ParseRouteConfig` | `parsers/static_route.go` | Already groups multi-gateway; verify grep query |\n| `l2tpTunnelAuthPattern` | `parsers/l2tp.go` | Fix currentTunnelID scope issue |\n| `parseUserAttributeString` | `parsers/admin.go` | Verify hyphen vs underscore handling |\n\n### Integration Points\n\n- **Config Service**: Uses `show config` for full configuration retrieval\n- **Individual Services**: Use filtered `show config | grep` for specific resources\n- **Resource Import**: Calls service Get methods → parser functions → Terraform state\n\n## Architecture\n\n### Bug Location Analysis\n\n```mermaid\ngraph TD\n    subgraph \"Import Data Flow\"\n        A[terraform import] --> B[resource Import func]\n        B --> C[client.GetXxx]\n        C --> D[executor.Run: show config]\n        D --> E[parser.ParseXxx]\n        E --> F[Terraform state]\n    end\n\n    subgraph \"Bug Locations\"\n        E --> |REQ-1| DNS[dns.go: parseDNSServerSelectFields]\n        E --> |REQ-2| IF[interface_config.go: output truncation?]\n        E --> |REQ-3| SR[static_route.go: grep query?]\n        E --> |REQ-4| L2[l2tp.go: tunnel context]\n        E --> |REQ-5| AD[admin.go: attribute parsing]\n        B --> |REQ-6| SC[Schema: Default values]\n    end\n\n    style DNS fill:#ffcccc\n    style IF fill:#ffffcc\n    style SR fill:#ffffcc\n    style L2 fill:#ffcccc\n    style AD fill:#ffffcc\n    style SC fill:#ccffcc\n```\n\n### Modular Design Principles\n\n- **Single Issue per Fix**: Each requirement addressed independently\n- **Test-First Approach**: Add failing tests before implementing fixes\n- **Backward Compatibility**: Existing working imports must continue functioning\n- **Minimal Changes**: Focus on parser layer; avoid service/provider refactoring\n\n## Components and Interfaces\n\n### Component 1: DNS Server Select Parser Fix (REQ-1)\n\n**Purpose**: Fix field parsing order in `parseDNSServerSelectFields`\n\n**File**: `internal/rtx/parsers/dns.go` (lines 202-276)\n\n#### RTX Command Specification\n\n```\ndns server select <id> <server1> [server2] [edns=on] [record_type] <query_pattern> [original_sender] [restrict pp <n>]\n```\n\n| Parameter | Required | Position | Format | Description |\n|-----------|----------|----------|--------|-------------|\n| `id` | Yes | 1 | Integer (1-65535) | Selector ID |\n| `server1` | Yes | 2 | IPv4/IPv6 address | Primary DNS server |\n| `server2` | No | 3 | IPv4/IPv6 address | Secondary DNS server |\n| `edns=on` | No | After servers | Literal string | Enable EDNS |\n| `record_type` | No | After edns | `a`,`aaaa`,`ptr`,`mx`,`ns`,`cname`,`any` | DNS record type filter |\n| `query_pattern` | Yes | After record_type | Domain pattern (`.`, `*.example.com`) | Query match pattern |\n| `original_sender` | No | After query_pattern | IP/CIDR | Source restriction |\n| `restrict pp n` | No | Last | `restrict pp <n>` | PP session restriction |\n\n**Root Cause Analysis**:\n```\nRTX Command: dns server select 500000 1.1.1.1 1.0.0.1 .\nCurrent Parse Result:\n  - servers: [1.1.1.1]\n  - original_sender: 1.0.0.1  ← WRONG (should be in servers)\n  - query_pattern: .          ← CORRECT\n\nRTX Command: dns server select 500100 2606:4700:4700::1111 aaaa .\nCurrent Parse Result:\n  - servers: [2606:4700:4700::1111]\n  - record_type: a            ← WRONG (should be aaaa)\n  - query_pattern: edns       ← WRONG (should be .)\n```\n\n**Fix Strategy**:\n1. Parse servers (1-2 IPs) from beginning - stop when non-IP found\n2. Parse `edns=on` if present (literal match)\n3. Parse record_type if matches `validRecordTypes` AND is not `.`\n4. Parse query_pattern (required, first non-IP/non-keyword after above)\n5. Parse original_sender (optional, IP/CIDR after query_pattern)\n6. Parse `restrict pp n` if present\n\n**Interface Changes**: None (same `DNSServerSelect` struct)\n\n---\n\n### Component 2: Interface Secure Filter Fix (REQ-2)\n\n**Purpose**: Ensure complete filter ID arrays are captured\n\n**File**: `internal/rtx/parsers/interface_config.go`\n\n#### RTX Command Specification\n\n```\nip <interface> secure filter in <filter_id1> [filter_id2] ... [filter_idN]\nip <interface> secure filter out <filter_id1> [filter_id2] ... [filter_idN] [dynamic <dyn_id1> ...]\n```\n\n| Parameter | Required | Format | Description |\n|-----------|----------|--------|-------------|\n| `interface` | Yes | `lan1`, `lan2`, `pp1`, etc. | Interface name |\n| `filter_id` | Yes (1+) | Integer | Static filter ID |\n| `dynamic` | No | Keyword | Marks start of dynamic filters |\n| `dyn_id` | No | Integer | Dynamic filter ID |\n\n**Root Cause Analysis**:\n```\nExpected: [200020, 200021, 200022, 200023, 200024, 200025, 200103, 200100, 200102, 200104, 200101, 200105, 200099]\nActual:   [200020, 200021, 200022, 200023, 200024, 200025, 200103, 20010]  ← Truncated\n```\n\n**Potential Causes**:\n1. SSH output buffer truncation\n2. Regex capture group limitation\n3. Integer parsing error on large numbers\n\n**Fix Strategy**:\n1. Add debug logging to `parseFilterList` function\n2. Test with real SSH output to identify truncation point\n3. If SSH buffer issue: increase buffer size in SSH client\n4. If regex issue: verify `(.+)\\s*$` captures entire line\n\n**Interface Changes**: None\n\n---\n\n### Component 3: Static Route Multi-Gateway Fix (REQ-3)\n\n**Purpose**: Capture all gateways for same prefix/mask\n\n**File**: `internal/rtx/parsers/static_route.go`\n\n#### RTX Command Specification\n\n```\nip route <network>/<prefix_len> gateway <gateway_ip> [weight <n>] [filter <n>] [hide|keepalive]\nip route default gateway <gateway_ip> [weight <n>] [filter <n>] [hide|keepalive]\n```\n\n| Parameter | Required | Format | Description |\n|-----------|----------|--------|-------------|\n| `network` | Yes | IPv4 address or `default` | Destination network |\n| `prefix_len` | Yes* | Integer (0-32) | CIDR prefix length (*not for default) |\n| `gateway_ip` | Yes | IPv4 address | Next-hop gateway |\n| `weight` | No | Integer (1-100) | Administrative distance/weight |\n| `filter` | No | Integer | IP filter number |\n| `hide` | No | Keyword | Remove when gateway unreachable |\n| `keepalive` | No | Keyword | Keep even when gateway unreachable |\n\n**Multi-Gateway Format** (ECMP/Failover):\nEach gateway is a separate command line with same network/prefix.\n\n**Root Cause Analysis**:\n```\nRTX Config:\n  ip route 10.33.128.0/21 gateway 192.168.1.20\n  ip route 10.33.128.0/21 gateway 192.168.1.21\n\nParser Behavior: Already groups by routeKey (prefix/mask)\nLikely Issue: Service query returns only first matching line\n```\n\n**Fix Strategy**:\n1. Verify `show config | grep \"ip route\"` captures all route lines\n2. If service uses specific network filter, ensure it captures all gateway variations\n3. Confirm `ParseRouteConfig` correctly appends to `route.NextHops`\n\n**Interface Changes**: None (existing `[]NextHop` supports multiple)\n\n---\n\n### Component 4: L2TP Tunnel Auth Fix (REQ-4)\n\n**Purpose**: Correctly associate tunnel_auth with tunnel ID\n\n**File**: `internal/rtx/parsers/l2tp.go` (lines 325-339)\n\n#### RTX Command Specification\n\nL2TPv3 tunnel configuration block:\n```\ntunnel select <n>\n tunnel encapsulation l2tpv3\n tunnel endpoint address <local_ip> <remote_ip>\n l2tp local router-id <router_id>\n l2tp remote router-id <router_id>\n l2tp remote end-id <hostname>\n l2tp tunnel auth on <password>        ← Target of this fix\n l2tp keepalive use on <interval> <retry>\n l2tp always-on on\ntunnel enable <n>\n```\n\n| Command | Format | Description |\n|---------|--------|-------------|\n| `tunnel select <n>` | Integer | Select tunnel for configuration |\n| `l2tp tunnel auth on <password>` | on/off + optional password | Enable tunnel authentication |\n| `l2tp tunnel auth off` | - | Disable tunnel authentication |\n\n**Root Cause Analysis**:\n```\nRTX Config:\n  tunnel select 1\n  ...\n  l2tp tunnel auth on Example!Pass123\n  ...\n\nParser State: currentTunnelID may be reset or zero when l2tpTunnelAuthPattern matches\n```\n\n**Fix Strategy**:\n1. Add debug logging to track currentTunnelID during parsing\n2. Verify `tunnel select N` properly sets currentTunnelID\n3. Ensure L2TPv3Config initialization happens at tunnel select\n4. Confirm tunnel auth pattern match uses correct tunnel context\n\n**Interface Changes**: None\n\n---\n\n### Component 5: Admin User Attribute Fix (REQ-5)\n\n**Purpose**: Correctly parse login-timer and gui-page attributes\n\n**File**: `internal/rtx/parsers/admin.go` (lines 152-185)\n\n#### RTX Command Specification\n\n```\nlogin user <username> <password>\nlogin user <username> encrypted <encrypted_password>\nuser attribute <username> <attribute1>=<value1> [attribute2=value2] ...\n```\n\n| Attribute | Format | Description |\n|-----------|--------|-------------|\n| `administrator` | `on`/`off` | Administrator privilege |\n| `connection` | `serial,telnet,remote,ssh,sftp,http` | Comma-separated connection methods |\n| `gui-page` | `dashboard,lan-map,config` | Comma-separated GUI page permissions |\n| `login-timer` | Integer (seconds) | Session timeout (0 = infinite) |\n\n**Root Cause Analysis**:\n```\nRTX Config: user attribute shin1ohno administrator=on connection=... gui-page=dashboard,lan-map,config login-timer=3600\nParsed:     login_timer=0, gui_pages=[]\n```\n\n**Potential Causes**:\n1. Attribute key mismatch (`login-timer` vs parser expectation)\n2. GUI pages using different separator or format\n3. Default value override in provider schema\n\n**Fix Strategy**:\n1. Add test case with exact RTX output format\n2. Verify `strings.HasPrefix(part, \"login-timer=\")` matches\n3. Check if RTX uses different attribute format\n\n**Interface Changes**: None\n\n---\n\n### Component 6: Schema Import Compatibility (REQ-6)\n\n**Purpose**: Allow import without Required attribute errors\n\n**Files**: Various `internal/provider/resource_rtx_*.go`\n\n**Root Cause Analysis**:\nSchema attributes marked `Required: true` fail on import if router doesn't have explicit value.\nSchema `Default:` values override imported values.\n\n**Fix Strategy**:\n1. Change `Required: true` to `Optional: true` for attributes not always present\n2. Use `Computed: true` for attributes where router has implicit defaults\n3. Remove `Default:` for attributes that should use imported values\n\n**Interface Changes**: Schema only (no parser changes)\n\n## Data Models\n\n### DNSServerSelect (existing, no changes)\n\n```go\ntype DNSServerSelect struct {\n    ID             int      `json:\"id\"`\n    Servers        []string `json:\"servers\"`          // Fix: capture all servers\n    EDNS           bool     `json:\"edns\"`             // Fix: parse before query_pattern\n    RecordType     string   `json:\"record_type\"`      // Fix: preserve explicit type\n    QueryPattern   string   `json:\"query_pattern\"`    // Fix: parse in correct position\n    OriginalSender string   `json:\"original_sender\"`  // Fix: parse after query_pattern\n    RestrictPP     int      `json:\"restrict_pp\"`\n}\n```\n\n### InterfaceConfig (existing, no changes)\n\n```go\ntype InterfaceConfig struct {\n    Name             string `json:\"name\"`\n    SecureFilterIn   []int  `json:\"secure_filter_in\"`   // Fix: complete array\n    SecureFilterOut  []int  `json:\"secure_filter_out\"`  // Fix: complete array\n    DynamicFilterOut []int  `json:\"dynamic_filter_out\"`\n    // ... other fields\n}\n```\n\n### L2TPTunnelAuth (existing, no changes)\n\n```go\ntype L2TPTunnelAuth struct {\n    Enabled  bool   `json:\"enabled\"`   // Fix: set true when \"on\"\n    Password string `json:\"password\"`  // Fix: capture password\n}\n```\n\n### UserAttributes (existing, no changes)\n\n```go\ntype UserAttributes struct {\n    Administrator bool     `json:\"administrator\"`\n    Connection    []string `json:\"connection\"`\n    GUIPages      []string `json:\"gui_pages\"`      // Fix: populate correctly\n    LoginTimer    int      `json:\"login_timer\"`    // Fix: parse numeric value\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **DNS parser field order mismatch**\n   - **Handling**: Log warning if unknown field encountered after query_pattern\n   - **User Impact**: Import succeeds with all recognized fields\n\n2. **Filter list truncation**\n   - **Handling**: Log actual vs expected filter count if mismatch detected\n   - **User Impact**: Full filter list captured\n\n3. **L2TP tunnel context lost**\n   - **Handling**: Log current tunnel ID at each pattern match\n   - **User Impact**: Tunnel auth correctly associated\n\n4. **Admin attribute parsing failure**\n   - **Handling**: Return partial result with warning for unparsed attributes\n   - **User Impact**: Known attributes imported; unknown logged\n\n## Testing Strategy\n\n### Unit Testing\n\nEach parser fix requires:\n1. **Test file**: `*_test.go` in same package\n2. **Test data**: Real RTX config samples in `internal/rtx/testdata/`\n3. **Test cases**:\n   - Normal case (valid input)\n   - Edge case (boundary conditions)\n   - Regression case (existing working configs)\n\n### Test Fixtures Required\n\n```\ninternal/rtx/testdata/\n├── dns_server_select_multi_server.txt     # REQ-1: Two servers\n├── dns_server_select_aaaa.txt             # REQ-1: AAAA record type\n├── interface_filter_long_list.txt          # REQ-2: 13+ filter IDs\n├── static_route_multi_gateway.txt          # REQ-3: Same prefix, 2 gateways\n├── l2tp_tunnel_auth.txt                    # REQ-4: tunnel auth on\n└── admin_user_full_attributes.txt          # REQ-5: All attributes\n```\n\n### Integration Testing\n\n- Import → Read → Plan should produce \"No changes\"\n- Verify against real RTX1210-Ebisu configuration\n\n## Implementation Order\n\n| Order | Requirement | Complexity | Risk |\n|-------|-------------|------------|------|\n| 1 | REQ-1: DNS server_select | Medium | High (affects DNS routing) |\n| 2 | REQ-2: Interface filters | Low | Medium (firewall rules) |\n| 3 | REQ-3: Static routes | Low | Low (routing) |\n| 4 | REQ-5: Admin attributes | Low | Low (user management) |\n| 5 | REQ-4: L2TP tunnel_auth | Medium | Medium (VPN security) |\n| 6 | REQ-6: Schema compatibility | Low | Low (all resources) |\n",
  "fileStats": {
    "size": 15176,
    "lines": 430,
    "lastModified": "2026-01-20T11:38:30.211Z"
  },
  "comments": []
}