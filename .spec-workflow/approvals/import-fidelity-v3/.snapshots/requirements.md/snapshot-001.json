{
  "id": "snapshot_1769063192175_hopn0xwxc",
  "approvalId": "approval_1769063192158_6ku7i6poy",
  "approvalTitle": "Import Fidelity v3 Requirements",
  "version": 1,
  "timestamp": "2026-01-22T06:26:32.175Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document: Import Fidelity Fix v3\n\n## Introduction\n\nThis spec addresses remaining import fidelity issues discovered during reconciliation of `config.txt` (actual RTX router configuration) with `examples/import/main.tf` (Terraform configuration). These bugs cause critical discrepancies between the router's actual configuration and what Terraform reads/manages.\n\n## Problem Summary\n\nAfter implementing import-fidelity-v2, additional issues remain:\n\n1. **Filter List Line-Wrap Truncation**: RTX wraps long lines at ~80 chars, but when a number is split across lines (e.g., `20010\\n0` for `200100`), the parser only captures the truncated value\n2. **DNS Service Recursive**: `dns service recursive` is not recognized (only `on|off` supported)\n3. **DNS Server Select Multi-EDNS**: When each server has its own `edns=on`, parsing fails\n4. **L2TPv3 Tunnel Auth Import**: `tunnel_auth_enabled` imports as false despite config having `l2tp tunnel auth on`\n5. **DHCP Scope Network Null**: Network field imports as null when IP range format is used\n\n## Evidence from Terraform State\n\n| Resource | Expected | Actual (State) |\n|----------|----------|----------------|\n| lan2.secure_filter_in | 13 values ending `...200099` | 8 values ending `...20010` |\n| lan2.secure_filter_out | values ending `...200099` | values ending `...2000` |\n| lan2.dynamic_filter_out | `[200080-200085]` | `[]` (empty) |\n| ipv6_lan2.dynamic_filter_out | 8 values `[101080-101099]` | 6 values ending `...1` |\n| dns_server.service_on | `true` (recursive) | `false` |\n| dns_server.server_select[500100] | query_pattern=\".\", record_type=\"aaaa\" | query_pattern=\"edns\", record_type=\"a\" |\n| l2tp.tunnel1.tunnel_auth_enabled | `true` | `false` |\n| dhcp_scope.network | `192.168.1.20-192.168.1.99/16` | `null` |\n\n## Alignment with Product Vision\n\nImport fidelity is critical for:\n- Accurate drift detection (terraform plan shows real differences)\n- Safe infrastructure-as-code adoption\n- Predictable state management\n\n## Requirements\n\n### REQ-1: Filter List Line-Wrap Handling\n\n**User Story:** As a Terraform user, I want filter lists to be parsed correctly even when RTX output wraps long lines, so that all filter numbers are captured.\n\n#### Root Cause\n\nRTX routers wrap long output lines at approximately 80 characters. When a filter number spans the line break (e.g., `200100` becomes `20010\\n0`), the current `preprocessWrappedLines` function joins lines but `parseFilterList` only parses complete numbers separated by whitespace.\n\n#### Acceptance Criteria\n\n1. WHEN config contains `ip lan2 secure filter in 200020 200021 200022 200023 200024 200025 200103 20010\\n0 200102 200104 200101 200105 200099` THEN parser SHALL reconstruct `200100` and capture all 13 filter numbers\n\n2. WHEN a filter number is split across lines (e.g., `2000\\n27`) THEN `preprocessWrappedLines` SHALL detect the split and join the number fragments correctly\n\n3. WHEN parsing `dynamic` keyword followed by filter numbers THEN all dynamic filter numbers SHALL be captured even if line-wrapped\n\n### REQ-2: DNS Service Recursive Support\n\n**User Story:** As a Terraform user, I want `dns service recursive` to be recognized, so that the DNS service state is imported correctly.\n\n#### Root Cause\n\nCurrent regex pattern: `^\\s*dns\\s+service\\s+(on|off)\\s*$`\nDoes not match: `dns service recursive`\n\n#### Acceptance Criteria\n\n1. WHEN config contains `dns service recursive` THEN parser SHALL set `ServiceOn = true`\n\n2. WHEN config contains `dns service on` THEN parser SHALL set `ServiceOn = true`\n\n3. WHEN config contains `dns service off` THEN parser SHALL set `ServiceOn = false`\n\n4. WHEN building DNS config with ServiceOn=true THEN builder SHALL output `dns service recursive` (preferred form)\n\n### REQ-3: DNS Server Select Multi-Server EDNS Parsing\n\n**User Story:** As a Terraform user, I want DNS server select entries with multiple servers and EDNS options to be parsed correctly, so that all servers and options are captured.\n\n#### Root Cause\n\nConfig line: `dns server select 500100 2606:4700:4700::1111 edns=on 2606:4700:4700::1001 edns=on aaaa .`\n\nCurrent parser:\n- Phase 1: Parses first server, stops at `edns=on` (not an IP)\n- Phase 2: Captures `edns=on`\n- Phase 4: Sets `query_pattern = \"2606:4700:4700::1001\"` (wrong!)\n\n#### Acceptance Criteria\n\n1. WHEN config contains `dns server select <id> <server1> edns=on <server2> edns=on <record_type> <query_pattern>` THEN parser SHALL extract:\n   - servers = [server1, server2]\n   - edns = true\n   - record_type correctly\n   - query_pattern correctly\n\n2. WHEN EDNS option appears after each server THEN parser SHALL handle interleaved format\n\n3. WHEN building DNS server select command THEN output SHALL follow RTX standard format\n\n### REQ-4: L2TPv3 Tunnel Auth Import\n\n**User Story:** As a Terraform user, I want L2TPv3 tunnel authentication settings to be imported correctly, so that VPN security configurations are preserved.\n\n#### Root Cause\n\nParser correctly parses `l2tp tunnel auth on <password>`, but resource Read function may not properly map parsed TunnelAuth to schema field `tunnel_auth_enabled`.\n\n#### Acceptance Criteria\n\n1. WHEN config contains `l2tp tunnel auth on <password>` THEN resource state SHALL have `tunnel_auth_enabled = true`\n\n2. WHEN config contains `l2tp tunnel auth off` THEN resource state SHALL have `tunnel_auth_enabled = false`\n\n3. WHEN tunnel auth is not configured THEN resource state SHALL have `tunnel_auth_enabled = false` (default)\n\n### REQ-5: DHCP Scope Network Field Population\n\n**User Story:** As a Terraform user, I want DHCP scope network information to be correctly populated, so that IP allocation settings are preserved.\n\n#### Root Cause\n\nDHCP scope parsing correctly extracts IP range but resource Read may not map it to the `network` schema field.\n\n#### Acceptance Criteria\n\n1. WHEN config contains `dhcp scope 1 192.168.1.20-192.168.1.99/16` THEN resource state SHALL have `network = \"192.168.0.0/16\"` (CIDR form)\n\n2. WHEN DHCP scope has IP range format THEN `range_start` and `range_end` fields SHALL be populated\n\n3. WHEN reading DHCP scope THEN network field SHALL NOT be null\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- Extend existing parsers without breaking changes\n- Maintain backward compatibility with existing configurations\n- Follow existing code patterns in `internal/rtx/parsers/`\n\n### Testing\n- Add unit tests for each parser fix\n- Include tests with actual RTX output samples (line-wrapped)\n- Test edge cases and variations\n\n### Reliability\n- Graceful handling of malformed input\n- Clear error messages for unsupported formats\n",
  "fileStats": {
    "size": 6624,
    "lines": 146,
    "lastModified": "2026-01-22T06:26:26.386Z"
  },
  "comments": []
}