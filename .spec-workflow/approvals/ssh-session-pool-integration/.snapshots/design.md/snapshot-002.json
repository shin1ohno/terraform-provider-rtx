{
  "id": "snapshot_1769341319850_kp790d72a",
  "approvalId": "approval_1769341295314_1mlvnzp3q",
  "approvalTitle": "SSH Session Pool Integration - Design Document",
  "version": 2,
  "timestamp": "2026-01-25T11:41:59.850Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: SSH Session Pool Integration\n\n## Overview\n\nThis design integrates the existing `SSHSessionPool` into the executor layer by creating a new `PooledExecutor` implementation. The pool already exists in `client.go` but is not wired into the command execution path. The `PooledExecutor` will acquire sessions from the pool for command execution, eliminating redundant SSH connections that cause rate limiting errors on RTX routers.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Uses Zerolog for all logging (per CLAUDE.md requirements)\n- Follows existing Go patterns in the codebase\n- Maintains interface-based design (`Executor` interface)\n\n### Project Structure (structure.md)\n- New executor implementation in `internal/client/pooled_executor.go`\n- No changes to existing package structure\n- Tests alongside implementation files\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`SSHSessionPool`**: Already implements session management, acquisition, release, and idle cleanup\n- **`workingSession`**: Provides command execution via `Send()`, prompt detection, and admin mode tracking\n- **`Executor` interface**: Already defined with `Run()`, `RunBatch()`, `SetAdministratorPassword()`, `SetLoginPassword()`\n- **`simpleExecutor`**: Reference implementation for admin authentication patterns\n\n### Integration Points\n- **`rtxClient.sshSessionPool`**: Already created in client initialization; `PooledExecutor` will receive it as dependency\n- **`rtxClient.executor`**: Change initialization to use `PooledExecutor` when pool is enabled\n\n## Architecture\n\nThe design follows the Strategy pattern where `PooledExecutor` and `simpleExecutor` are interchangeable implementations of the `Executor` interface.\n\n```mermaid\ngraph TD\n    subgraph Client Layer\n        C[rtxClient]\n    end\n\n    subgraph Executor Layer\n        EI[Executor Interface]\n        PE[PooledExecutor]\n        SE[simpleExecutor]\n    end\n\n    subgraph Pool Layer\n        SP[SSHSessionPool]\n        PS[PooledSSHSession]\n    end\n\n    subgraph Session Layer\n        WS[workingSession]\n    end\n\n    C --> EI\n    EI -.-> PE\n    EI -.-> SE\n    PE --> SP\n    SP --> PS\n    PS --> WS\n    SE -->|creates per command| WS\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: `pooled_executor.go` handles only pooled command execution\n- **Component Isolation**: Pool management stays in `SSHSessionPool`, executor only uses pool interface\n- **Dependency Injection**: `PooledExecutor` receives `SSHSessionPool` as constructor parameter\n\n## Components and Interfaces\n\n### PooledExecutor\n- **Purpose:** Executes commands using sessions from the pool instead of creating new connections\n- **File:** `internal/client/pooled_executor.go`\n- **Interfaces:** Implements `Executor` interface:\n  ```go\n  type PooledExecutor struct {\n      pool           *SSHSessionPool\n      promptDetector *PromptDetector\n      config         *Config\n      mu             sync.Mutex\n  }\n\n  func NewPooledExecutor(pool *SSHSessionPool, promptDetector *PromptDetector, config *Config) *PooledExecutor\n\n  func (e *PooledExecutor) Run(ctx context.Context, cmd string) ([]byte, error)\n  func (e *PooledExecutor) RunBatch(ctx context.Context, cmds []string) ([]byte, error)\n  func (e *PooledExecutor) SetAdministratorPassword(ctx context.Context, oldPassword, newPassword string) error\n  func (e *PooledExecutor) SetLoginPassword(ctx context.Context, newPassword string) error\n  ```\n- **Dependencies:** `SSHSessionPool`, `PromptDetector`, `Config`\n- **Reuses:** `SSHSessionPool.Acquire()`, `SSHSessionPool.Release()`, `workingSession.Send()`\n\n### Modified rtxClient Initialization\n- **Purpose:** Wire `PooledExecutor` as the default executor when pool is enabled\n- **File:** `internal/client/client.go` (modification)\n- **Change:** Replace `simpleExecutor` creation with `PooledExecutor` when `sshPoolEnabled=true`\n\n## Data Models\n\n### Session State Tracking\nThe pool already tracks session state via `PooledSSHSession`. No new data models needed.\n\n```go\n// Existing in ssh_session_pool.go\ntype PooledSSHSession struct {\n    session     *workingSession\n    poolID      string\n    lastUsed    time.Time\n    useCount    int64\n    initialized bool\n}\n```\n\n### Admin Mode State\nAdmin mode is already tracked per `workingSession` via `adminMode` field. The design reuses this existing mechanism.\n\n## Command Execution Flow\n\n### Standard Command (Run)\n```mermaid\nsequenceDiagram\n    participant C as Client\n    participant PE as PooledExecutor\n    participant SP as SSHSessionPool\n    participant PS as PooledSSHSession\n    participant WS as workingSession\n\n    C->>PE: Run(ctx, cmd)\n    PE->>SP: Acquire(ctx)\n    SP-->>PE: PooledSSHSession\n\n    alt requiresAdminPrivileges && !session.adminMode\n        PE->>WS: authenticateAsAdmin()\n        WS-->>PE: admin prompt confirmed\n    end\n\n    PE->>WS: Send(cmd)\n    WS-->>PE: output\n    PE->>SP: Release(session)\n    PE-->>C: output, nil\n```\n\n### Batch Commands (RunBatch)\nFor batch commands, acquire once, execute all commands sequentially, then release:\n\n```mermaid\nsequenceDiagram\n    participant PE as PooledExecutor\n    participant SP as SSHSessionPool\n    participant WS as workingSession\n\n    PE->>SP: Acquire(ctx)\n    SP-->>PE: PooledSSHSession\n\n    loop for each command\n        PE->>WS: Send(cmd)\n        WS-->>PE: output\n    end\n\n    PE->>SP: Release(session)\n```\n\n### Password Change Operations\nPassword operations require interactive prompts. These use the same pooled session with admin authentication:\n\n1. Acquire session from pool\n2. Authenticate as administrator (if needed)\n3. Execute interactive password change sequence\n4. Release session back to pool\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Pool Exhausted (Acquire Timeout)**\n   - **Handling:** `Acquire()` returns error after `AcquireTimeout` (default 30s)\n   - **User Impact:** Terraform operation fails with clear message: \"failed to acquire SSH session: timeout waiting for available session\"\n   - **Recovery:** Automatic retry via Terraform's retry logic\n\n2. **Session Failure During Command**\n   - **Handling:** Discard failed session (don't return to pool), retry with new session\n   - **User Impact:** Transparent retry, operation succeeds if second attempt works\n   - **Implementation:**\n     ```go\n     output, err := e.executeWithRetry(ctx, cmd, maxRetries)\n     if err != nil {\n         // Log and return error\n     }\n     ```\n\n3. **Admin Authentication Failure**\n   - **Handling:** Release session, return authentication error\n   - **User Impact:** \"administrator authentication failed: [reason]\"\n   - **Note:** Session remains in user mode, can be reused for non-admin commands\n\n4. **SSH Client Connection Lost**\n   - **Handling:** Pool detects via session health check, invalidates all sessions\n   - **User Impact:** Next operation triggers reconnection\n   - **Implementation:** Pool's existing health management handles this\n\n### Retry Strategy\n```go\nconst (\n    maxRetries     = 2\n    retryBaseDelay = 100 * time.Millisecond\n)\n\nfunc (e *PooledExecutor) executeWithRetry(ctx context.Context, cmd string, retries int) ([]byte, error) {\n    var lastErr error\n    for attempt := 0; attempt <= retries; attempt++ {\n        session, err := e.pool.Acquire(ctx)\n        if err != nil {\n            return nil, fmt.Errorf(\"failed to acquire session: %w\", err)\n        }\n\n        output, err := e.executeOnSession(ctx, session, cmd)\n        if err == nil {\n            e.pool.Release(session)\n            return output, nil\n        }\n\n        lastErr = err\n        // Don't release failed session - let pool discard it\n        e.pool.Discard(session)\n\n        if attempt < retries {\n            time.Sleep(retryBaseDelay * time.Duration(attempt+1))\n        }\n    }\n    return nil, lastErr\n}\n```\n\n## Admin Mode Management\n\n### Strategy: Lazy Authentication\nSessions start in user mode. Admin authentication happens only when needed:\n\n1. Check if command `requiresAdminPrivileges()`\n2. Check if session is already in admin mode (`session.session.adminMode`)\n3. If admin needed and not in admin mode → authenticate\n4. Execute command\n5. **Keep session in admin mode** when returning to pool (optimization)\n\n### Session Reuse with Admin State\n```go\nfunc (e *PooledExecutor) prepareSession(ctx context.Context, session *PooledSSHSession, needsAdmin bool) error {\n    ws := session.session\n\n    if needsAdmin && !ws.adminMode {\n        if err := e.authenticateAsAdmin(ws); err != nil {\n            return err\n        }\n        ws.SetAdminMode(true)\n    }\n    return nil\n}\n```\n\n### Pool Release Behavior\nWhen releasing a session:\n- **Do NOT exit admin mode** - next user might need admin access\n- Pool keeps session as-is (admin mode preserved)\n- On pool close or idle cleanup, `workingSession.Close()` handles proper exit sequence\n\n## Backward Compatibility\n\n### Configuration Flag\nPool is enabled by default (existing behavior in `client.go`):\n```go\nsshPoolEnabled := config.SSHPoolEnabled || (config.SSHPoolMaxSessions == 0 && config.SSHPoolIdleTimeout == \"\")\n```\n\n### Fallback to simpleExecutor\nWhen pool is disabled:\n```go\nif sshPoolEnabled {\n    c.executor = NewPooledExecutor(c.sshSessionPool, c.promptDetector, c.config)\n} else {\n    c.executor = NewSimpleExecutor(sshConfig, addr, c.promptDetector, c.config)\n}\n```\n\n### Error Message Consistency\nAll error messages follow existing patterns:\n- \"failed to execute command: [reason]\"\n- \"administrator authentication failed: [reason]\"\n- \"failed to acquire SSH session: [reason]\"\n\n## Testing Strategy\n\n### Unit Testing\n- **Mock SSHSessionPool:** Test `PooledExecutor` with mock pool that returns controlled sessions\n- **Test scenarios:**\n  - Successful command execution\n  - Admin authentication flow\n  - Pool exhaustion handling\n  - Session failure and retry\n  - Batch command execution\n\n### Integration Testing\n- **Test with real pool:** Verify session reuse by counting pool statistics\n- **Test scenarios:**\n  - Multiple commands share same session\n  - Concurrent command execution\n  - Admin mode persistence across commands\n\n### End-to-End Testing\n- **Terraform acceptance tests:**\n  - Create/read/update/delete resource with pooled executor\n  - Verify no connection errors with 10+ resources\n  - Measure execution time improvement\n\n### Test File Structure\n```\ninternal/client/\n├── pooled_executor.go\n├── pooled_executor_test.go\n├── mock_session_pool_test.go  // Test helper\n```\n\n## Implementation Phases\n\n### Phase 1: Core PooledExecutor\n1. Create `PooledExecutor` struct with `Run()` method\n2. Implement session acquisition and release\n3. Add basic error handling\n\n### Phase 2: Admin Mode Support\n1. Implement `prepareSession()` with admin authentication\n2. Port `authenticateAsAdmin()` from `simpleExecutor`\n3. Add admin mode state tracking\n\n### Phase 3: Advanced Features\n1. Implement `RunBatch()` for efficient batch execution\n2. Add retry logic with exponential backoff\n3. Implement `SetAdministratorPassword()` and `SetLoginPassword()`\n\n### Phase 4: Integration & Testing\n1. Wire `PooledExecutor` into `rtxClient`\n2. Add comprehensive unit tests\n3. Run acceptance tests to verify reliability\n\n## Performance Considerations\n\n- **Session Acquisition:** < 10ms when sessions available (existing pool behavior)\n- **Admin Authentication:** ~100-200ms (one-time per session)\n- **Connection Reuse:** Eliminates ~500ms per command (SSH handshake overhead)\n- **Expected Improvement:** 50%+ faster for large configurations (60+ resources)\n",
  "fileStats": {
    "size": 11514,
    "lines": 351,
    "lastModified": "2026-01-25T11:41:30.079Z"
  },
  "comments": []
}