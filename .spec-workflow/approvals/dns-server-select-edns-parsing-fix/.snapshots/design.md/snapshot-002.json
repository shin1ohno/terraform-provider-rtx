{
  "id": "snapshot_1769073212766_5p520hwe0",
  "approvalId": "approval_1769073047605_zdg2p4yzb",
  "approvalTitle": "Design: DNS Server Select Per-Server EDNS Support",
  "version": 2,
  "timestamp": "2026-01-22T09:13:32.766Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: DNS Server Select Per-Server EDNS Support\n\n## Overview\n\nThis design introduces a nested `server` block within `server_select` to enable per-server EDNS configuration, replacing the flat `servers` list and shared `edns` boolean. This change aligns with RTX router capabilities and fixes the parsing issue where `query_pattern` incorrectly reads as \"edns\".\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Follows existing parser/builder pattern in `internal/rtx/parsers/`\n- Maintains separation between parser, client, and provider layers\n- Uses Terraform SDK v2 schema patterns consistent with other resources\n\n### Project Structure (structure.md)\n- Changes isolated to DNS-related files across three layers\n- No new packages or major structural changes required\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`parsers.DNSParser`**: Extend `parseDNSServerSelectFields` to parse per-server EDNS\n- **`parsers.BuildDNSServerSelectCommand`**: Modify to generate per-server EDNS in commands\n- **`client.DNSService`**: Conversion functions already handle struct transformation\n- **`validateIPAddressAny`**: Reuse existing IP validation for server addresses\n\n### Integration Points\n- **Provider Schema**: Update `server_select` element schema\n- **State Migration**: Terraform handles backward compatibility via Computed + Optional\n- **Client Layer**: Struct definitions mirror parser layer\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Provider Layer\"\n        A[resource_rtx_dns_server.go]\n        A1[Schema: server_select]\n        A2[buildDNSConfigFromResourceData]\n    end\n\n    subgraph \"Client Layer\"\n        B[interfaces.go]\n        B1[DNSServerSelect struct]\n        B2[DNSServer struct - NEW]\n        C[dns_service.go]\n        C1[toParserConfig / fromParserConfig]\n    end\n\n    subgraph \"Parser Layer\"\n        D[parsers/dns.go]\n        D1[DNSServerSelect struct]\n        D2[DNSServer struct - NEW]\n        D3[parseDNSServerSelectFields]\n        D4[BuildDNSServerSelectCommand]\n    end\n\n    A1 --> A2\n    A2 --> B1\n    B1 --> C1\n    C1 --> D1\n    D3 --> D1\n    D1 --> D4\n```\n\n## Components and Interfaces\n\n### Component 1: New DNSServer Struct\n- **Purpose:** Represents a single DNS server with its EDNS setting\n- **Location:** `internal/rtx/parsers/dns.go`, `internal/client/interfaces.go`\n- **Definition:**\n  ```go\n  type DNSServer struct {\n      Address string `json:\"address\"` // DNS server IP (IPv4 or IPv6)\n      EDNS    bool   `json:\"edns\"`    // Per-server EDNS setting\n  }\n  ```\n\n### Component 2: Updated DNSServerSelect Struct\n- **Purpose:** Represents a DNS server select entry with nested servers\n- **Changes:**\n  - Remove: `Servers []string`, `EDNS bool`\n  - Add: `Servers []DNSServer`\n- **Definition:**\n  ```go\n  type DNSServerSelect struct {\n      ID             int         `json:\"id\"`\n      Servers        []DNSServer `json:\"servers\"`         // Changed from []string\n      // EDNS removed - now per-server\n      RecordType     string      `json:\"record_type\"`\n      QueryPattern   string      `json:\"query_pattern\"`\n      OriginalSender string      `json:\"original_sender\"`\n      RestrictPP     int         `json:\"restrict_pp\"`\n  }\n  ```\n\n### Component 3: Updated Parser (`parseDNSServerSelectFields`)\n- **Purpose:** Parse RTX output with per-server EDNS options\n- **Current Logic Issue:**\n  - Parses `edns=on` but stores in single boolean\n  - After parsing servers, may incorrectly identify next token\n- **New Logic:**\n  ```\n  For each token after ID:\n    IF token is valid IP:\n      Create DNSServer{Address: token}\n      IF next token is \"edns=on\" or \"edns=off\":\n        Set server.EDNS accordingly\n        Advance\n      Append server to list\n    ELSE:\n      Break to next phase (record_type, query_pattern)\n  ```\n- **Reuses:** `isValidIPForDNS()` for IP validation\n\n### Component 4: Updated Command Builder (`BuildDNSServerSelectCommand`)\n- **Purpose:** Generate RTX command with per-server EDNS\n- **Output Format:**\n  ```\n  dns server select <id> <server1> [edns=on] [<server2> [edns=on]] [<type>] <pattern>\n  ```\n- **Logic:**\n  ```\n  For each server in Servers:\n    Append server.Address\n    IF server.EDNS:\n      Append \"edns=on\"\n  ```\n\n### Component 5: Updated Provider Schema\n- **Purpose:** Enable per-server EDNS in Terraform configuration\n- **Changes to `server_select` element:**\n  ```go\n  // Deprecated - for backward compatibility\n  \"servers\": {\n      Type:       schema.TypeList,\n      Optional:   true,\n      Deprecated: \"Use 'server' blocks instead for per-server EDNS control\",\n      Elem:       &schema.Schema{Type: schema.TypeString},\n  },\n  \"edns\": {\n      Type:       schema.TypeBool,\n      Optional:   true,\n      Deprecated: \"Use 'edns' within 'server' blocks instead\",\n  },\n\n  // New nested block\n  \"server\": {\n      Type:     schema.TypeList,\n      Optional: true,\n      MaxItems: 2,  // RTX limit\n      Elem: &schema.Resource{\n          Schema: map[string]*schema.Schema{\n              \"address\": {\n                  Type:         schema.TypeString,\n                  Required:     true,\n                  ValidateFunc: validateIPAddressAny,\n              },\n              \"edns\": {\n                  Type:     schema.TypeBool,\n                  Optional: true,\n                  Default:  false,\n              },\n          },\n      },\n  },\n  ```\n\n### Component 6: Data Conversion Functions\n- **Location:** `resource_rtx_dns_server.go`\n- **Functions to Update:**\n  - `buildDNSConfigFromResourceData`: Handle both old and new schema\n  - State reading in `resourceRTXDNSServerRead`: Convert to new format\n  - Import in `resourceRTXDNSServerImport`: Same conversion\n\n## Data Models\n\n### New: DNSServer\n```go\ntype DNSServer struct {\n    Address string `json:\"address\"` // DNS server IP address (IPv4/IPv6)\n    EDNS    bool   `json:\"edns\"`    // EDNS enabled for this server\n}\n```\n\n### Updated: DNSServerSelect\n```go\ntype DNSServerSelect struct {\n    ID             int         `json:\"id\"`              // Selector ID (1-65535)\n    Servers        []DNSServer `json:\"servers\"`         // DNS servers with per-server EDNS\n    RecordType     string      `json:\"record_type\"`     // a, aaaa, ptr, mx, ns, cname, any\n    QueryPattern   string      `json:\"query_pattern\"`   // \".\", \"*.example.com\", etc.\n    OriginalSender string      `json:\"original_sender\"` // Source IP/CIDR restriction\n    RestrictPP     int         `json:\"restrict_pp\"`     // PP session restriction\n}\n```\n\n## Backward Compatibility Strategy\n\n### Detection Logic\n```go\nfunc buildDNSConfigFromResourceData(d *schema.ResourceData) client.DNSConfig {\n    // Check which schema is used\n    hasNewServerBlocks := len(d.Get(\"server_select.0.server\").([]interface{})) > 0\n    hasOldServers := len(d.Get(\"server_select.0.servers\").([]interface{})) > 0\n\n    if hasNewServerBlocks && hasOldServers {\n        // Validation error: cannot use both\n    }\n\n    if hasOldServers {\n        // Convert old format to new\n        edns := d.Get(\"server_select.0.edns\").(bool)\n        for _, addr := range oldServers {\n            servers = append(servers, DNSServer{Address: addr, EDNS: edns})\n        }\n    }\n}\n```\n\n### State Read (Always New Format)\nWhen reading from RTX, always populate the new `server` blocks format in state. The old `servers` and `edns` attributes will be empty, encouraging migration.\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Both old and new schema used**\n   - **Handling:** Return validation error during plan\n   - **Message:** \"Cannot use both 'servers' and 'server' blocks. Please migrate to 'server' blocks.\"\n\n2. **More than 2 servers specified**\n   - **Handling:** Schema MaxItems validation\n   - **Message:** \"RTX routers support at most 2 DNS servers per selector.\"\n\n3. **Invalid IP address**\n   - **Handling:** Existing `validateIPAddressAny` function\n   - **Message:** Standard IP validation error\n\n4. **Parse failure on malformed RTX output**\n   - **Handling:** Log warning, skip entry\n   - **Message:** \"Failed to parse dns server select entry: <details>\"\n\n## Testing Strategy\n\n### Unit Testing\n\n**Parser Tests** (`dns_test.go`):\n- Interleaved EDNS: `<server1> edns=on <server2> edns=on <type> <pattern>`\n- Mixed EDNS: `<server1> edns=on <server2> edns=off <type> <pattern>`\n- Trailing EDNS (legacy): `<server1> <server2> edns=on <pattern>`\n- Single server with EDNS\n- No EDNS specified (default off)\n\n**Builder Tests**:\n- All servers EDNS on\n- All servers EDNS off\n- Mixed EDNS settings\n- Single server\n\n### Integration Testing\n\n**Provider Tests** (`resource_rtx_dns_server_test.go`):\n- Create with new `server` block schema\n- Create with deprecated `servers` schema (verify warning)\n- Update from old to new schema\n- Import and verify correct format\n\n### Acceptance Testing\n- Configure RTX with per-server EDNS\n- Import and verify `terraform plan` shows no changes\n- Verify server_select[500100] has correct `query_pattern` and `record_type`\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| `internal/rtx/parsers/dns.go` | Add `DNSServer` struct, update `DNSServerSelect`, modify parser/builder |\n| `internal/rtx/parsers/dns_test.go` | Add tests for per-server EDNS parsing |\n| `internal/client/interfaces.go` | Mirror struct changes from parser layer |\n| `internal/client/dns_service.go` | Update conversion functions |\n| `internal/provider/resource_rtx_dns_server.go` | Update schema, add deprecated attrs, update data conversion |\n| `internal/provider/resource_rtx_dns_server_test.go` | Add tests for new schema |\n",
  "fileStats": {
    "size": 9519,
    "lines": 283,
    "lastModified": "2026-01-22T09:10:41.576Z"
  },
  "comments": []
}