{
  "id": "snapshot_1769185892049_gpin2oyt1",
  "approvalId": "approval_1769185892044_qgt3zjrz2",
  "approvalTitle": "Design for SFTP Config Parsing Fixes",
  "version": 1,
  "timestamp": "2026-01-23T16:31:32.049Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: SFTP Config Parsing Fixes\n\n## Overview\n\nThis design addresses parser issues discovered when reading RTX configuration via SFTP. The raw config is correctly retrieved, but several parsers fail to extract fields correctly. This document specifies the code changes needed to fix each issue.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Go 1.21+ with testify for testing\n- Parser functions in `internal/rtx/parsers/`\n- Table-driven tests for comprehensive coverage\n- Real RTX config formats in test fixtures\n\n### Project Structure (structure.md)\n- Parser source: `internal/rtx/parsers/*.go`\n- Parser tests: `internal/rtx/parsers/*_test.go`\n- Config extraction: `internal/rtx/parsers/config_file.go`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **ConfigFileParser**: Main parser that handles context-aware command extraction\n- **ParseL2TPConfig**: L2TP tunnel parser in `l2tp.go`\n- **ParseL2TPServiceConfig**: L2TP service parser in `l2tp_service.go`\n- **ParseSystemConfig**: System config parser in `system.go`\n- **ParseBindings**: DHCP binding parser in `dhcp_binding.go`\n- **Existing test patterns**: `config_file_test.go` holistic test approach\n\n### Integration Points\n\n- **ConfigFileParser.Parse()**: Entry point for config parsing\n- **ConfigFileParser.ExtractXxx()**: Resource-specific extraction methods\n- **Context handling**: Tunnel context, PP context command grouping\n\n## Architecture\n\n### Parser Data Flow\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│ SFTP Config Read                                            │\n│ /system/config0 → raw string                                │\n└─────────────────────────────────────────────────────────────┘\n                           ↓\n┌─────────────────────────────────────────────────────────────┐\n│ ConfigFileParser.Parse(rawConfig)                           │\n│ - Split into lines                                          │\n│ - Detect context boundaries (tunnel select, pp select)      │\n│ - Group commands by context                                 │\n└─────────────────────────────────────────────────────────────┘\n                           ↓\n┌─────────────────────────────────────────────────────────────┐\n│ ExtractXxx() Methods                                        │\n│ - Filter commands by prefix                                 │\n│ - Build raw config for specific parser                      │\n│ - Call resource-specific parser                             │\n└─────────────────────────────────────────────────────────────┘\n                           ↓\n┌─────────────────────────────────────────────────────────────┐\n│ Resource Parsers (l2tp.go, system.go, etc.)                 │\n│ - Parse raw config lines                                    │\n│ - Extract field values                                      │\n│ - Return structured config                                  │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Components and Fixes\n\n### FIX-1: L2TP Tunnel Context Parsing\n\n**File:** `internal/rtx/parsers/l2tp.go`\n\n**Problem:** `l2tp always-on on`, `l2tp hostname`, `l2tp keepalive use on` commands in tunnel context are not parsed.\n\n**Root Cause Analysis:**\nThe `ParseL2TPConfig` function receives raw config built from context commands. Need to verify:\n1. Commands are correctly collected from tunnel context\n2. Parser correctly handles `l2tp always-on on` format\n3. Parser correctly handles `l2tp hostname <name>` format\n4. Parser correctly handles `l2tp keepalive use on <interval> <retry>` format\n\n**Solution:**\n```go\n// In ParseL2TPConfig, ensure these patterns are handled:\n\n// Pattern: l2tp always-on on\nif strings.HasPrefix(line, \"l2tp always-on \") {\n    config.AlwaysOn = strings.TrimPrefix(line, \"l2tp always-on \") == \"on\"\n}\n\n// Pattern: l2tp hostname <name>\nif strings.HasPrefix(line, \"l2tp hostname \") {\n    config.Name = strings.TrimPrefix(line, \"l2tp hostname \")\n}\n\n// Pattern: l2tp keepalive use on <interval> <retry>\nif strings.HasPrefix(line, \"l2tp keepalive use \") {\n    parts := strings.Fields(line)\n    if len(parts) >= 4 && parts[3] == \"on\" {\n        config.KeepaliveEnabled = true\n        // Optionally parse interval and retry\n    }\n}\n```\n\n### FIX-2: L2TPv2 Mode Detection\n\n**File:** `internal/rtx/parsers/l2tp.go`\n\n**Problem:** When `tunnel encapsulation l2tp` is detected, `Mode` stays as default `\"l2vpn\"` instead of `\"lns\"`.\n\n**Current Code (lines ~203-213):**\n```go\nif strings.HasPrefix(line, \"tunnel encapsulation \") {\n    encap := strings.TrimPrefix(line, \"tunnel encapsulation \")\n    if encap == \"l2tp\" {\n        config.Version = \"l2tp\"\n        // Mode is NOT set here - BUG\n    } else if encap == \"l2tpv3\" {\n        config.Version = \"l2tpv3\"\n    }\n}\n```\n\n**Solution:**\n```go\nif strings.HasPrefix(line, \"tunnel encapsulation \") {\n    encap := strings.TrimPrefix(line, \"tunnel encapsulation \")\n    if encap == \"l2tp\" {\n        config.Version = \"l2tp\"\n        config.Mode = \"lns\"  // L2TPv2 is always LNS mode\n    } else if encap == \"l2tpv3\" {\n        config.Version = \"l2tpv3\"\n        config.Mode = \"l2vpn\"  // L2TPv3 is L2VPN mode\n    }\n}\n```\n\n### FIX-3: L2TP Service Protocol Parsing\n\n**File:** `internal/rtx/parsers/l2tp_service.go`\n\n**Problem:** `l2tp service on l2tpv3 l2tp` does not extract protocols.\n\n**RTX Command Format:**\n```\nl2tp service on [<protocol1> [<protocol2>]]\n```\n\n**Solution:**\n```go\nfunc ParseL2TPServiceConfig(rawConfig string) (*L2TPServiceConfig, error) {\n    config := &L2TPServiceConfig{}\n\n    for _, line := range strings.Split(rawConfig, \"\\n\") {\n        line = strings.TrimSpace(line)\n\n        // Pattern: l2tp service on [protocol1] [protocol2]\n        if strings.HasPrefix(line, \"l2tp service \") {\n            parts := strings.Fields(line)\n            // parts[0] = \"l2tp\", parts[1] = \"service\", parts[2] = \"on\"/\"off\"\n            if len(parts) >= 3 {\n                config.Enabled = parts[2] == \"on\"\n                // Extract protocols after \"on\"\n                if config.Enabled && len(parts) > 3 {\n                    config.Protocols = parts[3:]\n                }\n            }\n        }\n    }\n\n    return config, nil\n}\n```\n\n### FIX-4: System Config Extraction\n\n**File:** `internal/rtx/parsers/config_file.go` and `internal/rtx/parsers/system.go`\n\n**Problem:** System fields (timezone, console, packet-buffer, statistics) are all null.\n\n**Root Cause Analysis:**\n1. `ExtractSystem` in `config_file.go` filters global commands\n2. Commands may not be reaching `ParseSystemConfig`\n3. Or `ParseSystemConfig` has parsing issues\n\n**Debug Steps:**\n1. Add logging to `ExtractSystem` to see what commands are collected\n2. Verify global context commands include system lines\n3. Check `ParseSystemConfig` handles all formats\n\n**Expected Commands in Global Context:**\n```\ntimezone +09:00\nconsole character ja.utf8\nconsole lines infinity\nconsole prompt \"[RTX1210] \"\nsystem packet-buffer small max-buffer=5000 max-free=1300\nsystem packet-buffer middle max-buffer=10000 max-free=4950\nsystem packet-buffer large max-buffer=20000 max-free=5600\nstatistics traffic on\nstatistics nat on\n```\n\n**Solution (if parsing issue):**\n```go\n// In ParseSystemConfig, ensure these patterns are handled:\n\n// Pattern: timezone <offset>\nif strings.HasPrefix(line, \"timezone \") {\n    config.Timezone = strings.TrimPrefix(line, \"timezone \")\n}\n\n// Pattern: console character <charset>\nif strings.HasPrefix(line, \"console character \") {\n    config.Console.Character = strings.TrimPrefix(line, \"console character \")\n}\n\n// Pattern: console lines <value>\nif strings.HasPrefix(line, \"console lines \") {\n    config.Console.Lines = strings.TrimPrefix(line, \"console lines \")\n}\n\n// Pattern: console prompt \"<prompt>\"\nif strings.HasPrefix(line, \"console prompt \") {\n    prompt := strings.TrimPrefix(line, \"console prompt \")\n    config.Console.Prompt = strings.Trim(prompt, \"\\\"\")\n}\n\n// Pattern: system packet-buffer <size> max-buffer=<n> max-free=<n>\nif strings.HasPrefix(line, \"system packet-buffer \") {\n    pb := parsePacketBuffer(line)\n    config.PacketBuffers = append(config.PacketBuffers, pb)\n}\n\n// Pattern: statistics traffic on/off\nif strings.HasPrefix(line, \"statistics traffic \") {\n    config.Statistics.Traffic = strings.TrimPrefix(line, \"statistics traffic \") == \"on\"\n}\n\n// Pattern: statistics nat on/off\nif strings.HasPrefix(line, \"statistics nat \") {\n    config.Statistics.NAT = strings.TrimPrefix(line, \"statistics nat \") == \"on\"\n}\n```\n\n### FIX-5: DHCP Binding Scope ID\n\n**File:** `internal/rtx/parsers/config_file.go` and `internal/rtx/parsers/dhcp_binding.go`\n\n**Problem:** `ExtractDHCPBindings` passes `scopeID=0` to `ParseBindings`.\n\n**Current Code (lines ~920-923):**\n```go\nfunc (p *ParsedConfig) ExtractDHCPBindings() []*DHCPBindingConfig {\n    // ...\n    return parser.ParseBindings(raw, 0)  // BUG: hardcoded scopeID=0\n}\n```\n\n**RTX Command Format:**\n```\ndhcp scope bind <scope_id> <ip_address> <mac_address>\n```\n\n**Solution:**\n```go\n// Option 1: Parse scope ID from each line in ParseBindings\nfunc ParseBindings(rawConfig string, defaultScopeID int) []*DHCPBindingConfig {\n    var bindings []*DHCPBindingConfig\n\n    for _, line := range strings.Split(rawConfig, \"\\n\") {\n        line = strings.TrimSpace(line)\n        if !strings.HasPrefix(line, \"dhcp scope bind \") {\n            continue\n        }\n\n        // Parse: dhcp scope bind <scope_id> <ip> <mac...>\n        parts := strings.Fields(line)\n        if len(parts) < 5 {\n            continue\n        }\n\n        scopeID, _ := strconv.Atoi(parts[3])\n        ip := parts[4]\n        mac := strings.Join(parts[5:], \" \")\n\n        binding := &DHCPBindingConfig{\n            ScopeID:    scopeID,  // Extract from line, not parameter\n            IPAddress:  ip,\n            MACAddress: mac,\n        }\n        bindings = append(bindings, binding)\n    }\n\n    return bindings\n}\n```\n\n### FIX-6: Update main.tf DNS Servers Order\n\n**File:** `examples/import/main.tf`\n\n**Change:**\n```hcl\n# Before\ndns_servers = [\"1.0.0.1\", \"1.1.1.1\"]\n\n# After\ndns_servers = [\"1.1.1.1\", \"1.0.0.1\"]\n```\n\nThis is not a parser fix but a configuration correction to match the actual RTX config.\n\n## Testing Strategy\n\n### Unit Testing (TDD Approach)\n\n**Phase 1: Write Holistic Tests (Red)**\n- Create `config_file_sftp_test.go`\n- Use actual RTX config as test input\n- Tests will fail initially (expected)\n\n**Phase 2: Fix Implementation (Green)**\n- Apply fixes FIX-1 through FIX-5\n- Run tests after each fix\n- Continue until all tests pass\n\n**Phase 3: Verify and Refactor**\n- Run full test suite\n- Check for regressions\n- Refactor if needed while keeping tests green\n\n### Test File Structure\n\n```go\n// config_file_sftp_test.go\n\nconst sftpTestConfig = `\n#\n# Admin\n#\nlogin password TEST_LOGIN_PASS\n...\n`\n\nfunc TestConfigFileParser_SFTPConfig(t *testing.T) {\n    parser := NewConfigFileParser()\n    result, err := parser.Parse(sftpTestConfig)\n    require.NoError(t, err)\n\n    t.Run(\"L2TP Tunnel 1\", func(t *testing.T) {\n        tunnels := result.ExtractL2TPTunnels()\n        tunnel1 := findTunnel(tunnels, 1)\n        require.NotNil(t, tunnel1)\n\n        assert.True(t, tunnel1.AlwaysOn)\n        assert.True(t, tunnel1.KeepaliveEnabled)\n        assert.Equal(t, \"test-RTX1210\", tunnel1.Name)\n        assert.Equal(t, \"l2tpv3\", tunnel1.Version)\n        assert.Equal(t, \"l2vpn\", tunnel1.Mode)\n    })\n\n    t.Run(\"L2TP Tunnel 2\", func(t *testing.T) {\n        tunnels := result.ExtractL2TPTunnels()\n        tunnel2 := findTunnel(tunnels, 2)\n        require.NotNil(t, tunnel2)\n\n        assert.Equal(t, \"l2tp\", tunnel2.Version)\n        assert.Equal(t, \"lns\", tunnel2.Mode)\n    })\n\n    t.Run(\"L2TP Service\", func(t *testing.T) {\n        service := result.ExtractL2TPService()\n        require.NotNil(t, service)\n\n        assert.True(t, service.Enabled)\n        assert.Equal(t, []string{\"l2tpv3\", \"l2tp\"}, service.Protocols)\n    })\n\n    t.Run(\"System Config\", func(t *testing.T) {\n        system := result.ExtractSystem()\n        require.NotNil(t, system)\n\n        assert.Equal(t, \"+09:00\", system.Timezone)\n        assert.Equal(t, \"ja.utf8\", system.Console.Character)\n        assert.Equal(t, \"infinity\", system.Console.Lines)\n        assert.Equal(t, \"[RTX1210] \", system.Console.Prompt)\n        assert.Len(t, system.PacketBuffers, 3)\n        assert.True(t, system.Statistics.Traffic)\n        assert.True(t, system.Statistics.NAT)\n    })\n\n    t.Run(\"DHCP Bindings\", func(t *testing.T) {\n        bindings := result.ExtractDHCPBindings()\n        assert.Len(t, bindings, 5)\n\n        for _, b := range bindings {\n            assert.Equal(t, 1, b.ScopeID)\n        }\n\n        ips := extractIPs(bindings)\n        assert.Contains(t, ips, \"192.168.1.20\")\n        assert.Contains(t, ips, \"192.168.1.21\")\n        assert.Contains(t, ips, \"192.168.1.22\")\n        assert.Contains(t, ips, \"192.168.1.28\")\n        assert.Contains(t, ips, \"192.168.1.29\")\n    })\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Malformed config line**\n   - **Handling:** Skip line, log warning\n   - **Test:** Include malformed lines in test config\n\n2. **Missing required field**\n   - **Handling:** Use default value, log warning\n   - **Test:** Test with minimal config\n\n3. **Invalid numeric value**\n   - **Handling:** Use default, log error\n   - **Test:** Test with invalid numbers\n\n## RTX Command Reference\n\n### L2TP Commands\n\n| Command | Parser | Field |\n|---------|--------|-------|\n| `l2tp always-on on` | l2tp.go | AlwaysOn |\n| `l2tp hostname <name>` | l2tp.go | Name |\n| `l2tp keepalive use on <int> <retry>` | l2tp.go | KeepaliveEnabled |\n| `tunnel encapsulation l2tp` | l2tp.go | Version=\"l2tp\", Mode=\"lns\" |\n| `tunnel encapsulation l2tpv3` | l2tp.go | Version=\"l2tpv3\", Mode=\"l2vpn\" |\n| `l2tp service on [proto...]` | l2tp_service.go | Enabled, Protocols |\n\n### System Commands\n\n| Command | Parser | Field |\n|---------|--------|-------|\n| `timezone <offset>` | system.go | Timezone |\n| `console character <charset>` | system.go | Console.Character |\n| `console lines <value>` | system.go | Console.Lines |\n| `console prompt \"<prompt>\"` | system.go | Console.Prompt |\n| `system packet-buffer <size> max-buffer=<n> max-free=<n>` | system.go | PacketBuffers |\n| `statistics traffic on` | system.go | Statistics.Traffic |\n| `statistics nat on` | system.go | Statistics.NAT |\n\n### DHCP Commands\n\n| Command | Parser | Field |\n|---------|--------|-------|\n| `dhcp scope bind <id> <ip> <mac>` | dhcp_binding.go | ScopeID, IPAddress, MACAddress |\n",
  "fileStats": {
    "size": 15498,
    "lines": 460,
    "lastModified": "2026-01-23T16:31:26.617Z"
  },
  "comments": []
}