{
  "id": "snapshot_1768800350175_lr0to5io7",
  "approvalId": "approval_1768800326161_wqffm1y66",
  "approvalTitle": "Design: rtx_l2tp resource (L2TPv3対応版)",
  "version": 3,
  "timestamp": "2026-01-19T05:25:50.175Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: rtx_l2tp\n\n## Overview\n\nThe `rtx_l2tp` resource enables Terraform-based management of L2TP (Layer 2 Tunneling Protocol) configuration on Yamaha RTX series routers. This resource supports both **L2TPv2** (L2TP/IPsec for remote access VPN) and **L2TPv3** (L2VPN for site-to-site Layer 2 connectivity).\n\n### L2TP Versions Supported\n\n| Version | Use Case | Description |\n|---------|----------|-------------|\n| **L2TPv2** | Remote Access VPN | L2TP/IPsec for smartphone/PC clients connecting to LAN. Server (LNS) mode only. |\n| **L2TPv3** | Site-to-Site L2VPN | Ethernet frame tunneling between routers. Enables same L2 segment across multiple sites. |\n\n### RTX L2TP Limitations\n- **L2TPv2**: L2TP/IPsec only (no standalone L2TP), LNS mode only (no LAC), IKEv1 only\n- **L2TPv3**: L2TPv3 over UDP only (no L2TPv3 over IP), Ethernet frames only, IKEv1 transport mode for IPsec\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`internal/client/dhcp_scope_service.go`**: Pattern for service layer implementation with CRUD operations.\n- **`internal/client/interfaces.go`**: Extend the `Client` interface with L2TP methods.\n- **`internal/rtx/parsers/dhcp_scope.go`**: Reference for parser implementation and command builders.\n- **`internal/provider/resource_rtx_dhcp_scope.go`**: Template for Terraform resource structure.\n\n### Integration Points\n\n- **`rtxClient`**: Add L2TP methods for CRUD operations\n- **`Executor`**: Use existing SSH command execution infrastructure\n- **PP Anonymous**: Coordinate with PP anonymous configuration\n- **IPsec**: Optional integration with IPsec tunnel\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph Provider Layer\n        TFResource[resource_rtx_l2tp.go]\n    end\n\n    subgraph Client Layer\n        Client[client.go - Interface Extension]\n        L2TPService[l2tp_service.go]\n    end\n\n    subgraph Parser Layer\n        L2TPParser[l2tp.go]\n        Commands[Command Builders]\n        OutputParser[Output Parsers]\n    end\n\n    TFResource --> Client\n    Client --> L2TPService\n    L2TPService --> L2TPParser\n    L2TPParser --> Commands\n    L2TPParser --> OutputParser\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: `L2TPService` handles all L2TP CRUD operations\n- **Component Isolation**: Parser, service, and resource layers clearly separated\n- **Service Layer Separation**: Service encapsulates all L2TP logic\n- **Utility Modularity**: Shared validation functions for authentication parameters\n\n## Components and Interfaces\n\n### Component 1: L2TPService (`internal/client/l2tp_service.go`)\n\n- **Purpose:** Handles all L2TP CRUD operations against the RTX router\n- **Interfaces:**\n  ```go\n  type L2TPService struct {\n      executor Executor\n      client   *rtxClient\n  }\n\n  func (s *L2TPService) Create(ctx context.Context, l2tp L2TPConfig) error\n  func (s *L2TPService) Get(ctx context.Context, tunnelID int) (*L2TPConfig, error)\n  func (s *L2TPService) Update(ctx context.Context, l2tp L2TPConfig) error\n  func (s *L2TPService) Delete(ctx context.Context, tunnelID int) error\n  func (s *L2TPService) List(ctx context.Context) ([]L2TPConfig, error)\n  ```\n- **Dependencies:** `Executor`, `rtxClient`, `parsers.L2TPParser`\n- **Reuses:** Pattern from service layer implementations\n\n### Component 2: L2TPParser (`internal/rtx/parsers/l2tp.go`)\n\n- **Purpose:** Parses RTX router output for L2TP configuration and builds commands\n- **Interfaces:**\n  ```go\n  type L2TPConfig struct {\n      ID               int            `json:\"id\"`\n      Name             string         `json:\"name,omitempty\"`\n      Version          string         `json:\"version\"`         // l2tp (v2) or l2tpv3\n      Mode             string         `json:\"mode\"`            // lns, lac (v2 only), or l2vpn (v3)\n      Shutdown         bool           `json:\"shutdown\"`\n      TunnelSource     string         `json:\"tunnel_source,omitempty\"`\n      TunnelDest       string         `json:\"tunnel_destination,omitempty\"`\n      Authentication   L2TPAuth       `json:\"authentication\"`\n      IPPool           *L2TPIPPool    `json:\"ip_pool,omitempty\"`\n      IPsecProfile     *L2TPIPsec     `json:\"ipsec_profile,omitempty\"`\n      L2TPv3Config     *L2TPv3Config  `json:\"l2tpv3_config,omitempty\"`  // L2TPv3 specific\n      KeepaliveEnabled bool           `json:\"keepalive_enabled\"`\n      DisconnectTime   int            `json:\"disconnect_time,omitempty\"`\n  }\n\n  // L2TPv3Config represents L2TPv3-specific settings\n  type L2TPv3Config struct {\n      LocalRouterID   string `json:\"local_router_id\"`   // IPv4 address for local router ID\n      RemoteRouterID  string `json:\"remote_router_id\"`  // IPv4 address for remote router ID\n      RemoteEndID     string `json:\"remote_end_id,omitempty\"` // Optional end ID string\n      AlwaysOn        bool   `json:\"always_on\"`         // Keep connection always active\n      BridgeInterface string `json:\"bridge_interface,omitempty\"` // Bridge interface to bind\n  }\n\n  type L2TPAuth struct {\n      Method   string `json:\"method\"`   // pap, chap\n      Username string `json:\"username,omitempty\"`\n      Password string `json:\"password,omitempty\"`\n  }\n\n  type L2TPIPPool struct {\n      Start string `json:\"start\"`\n      End   string `json:\"end\"`\n  }\n\n  type L2TPIPsec struct {\n      Enabled       bool   `json:\"enabled\"`\n      PreSharedKey  string `json:\"pre_shared_key,omitempty\"`\n  }\n\n  func ParseL2TPConfig(raw string) ([]L2TPConfig, error)\n  func BuildPPSelectAnonymousCommand() string\n  func BuildPPBindTunnelCommand(tunnelID int) string\n  func BuildPPAuthAcceptCommand(method string) string\n  func BuildPPAuthMynameCommand(user, pass string) string\n  func BuildL2TPTunnelDisconnectTimeCommand(seconds int) string\n  func BuildL2TPKeepaliveCommand(enabled bool) string\n  func BuildDeleteL2TPCommand(tunnelID int) string\n  ```\n- **Dependencies:** `regexp`, `strings`, `strconv`\n- **Reuses:** IP validation patterns, authentication patterns\n\n### Component 3: Terraform Resource (`internal/provider/resource_rtx_l2tp.go`)\n\n- **Purpose:** Terraform resource definition implementing CRUD lifecycle\n- **Interfaces:**\n  ```go\n  func resourceRTXL2TP() *schema.Resource\n  func resourceRTXL2TPCreate(ctx, d, meta) diag.Diagnostics\n  func resourceRTXL2TPRead(ctx, d, meta) diag.Diagnostics\n  func resourceRTXL2TPUpdate(ctx, d, meta) diag.Diagnostics\n  func resourceRTXL2TPDelete(ctx, d, meta) diag.Diagnostics\n  func resourceRTXL2TPImport(ctx, d, meta) ([]*schema.ResourceData, error)\n  ```\n- **Dependencies:** `Client`, `L2TPConfig`, Terraform SDK\n- **Reuses:** Resource patterns from other implementations\n\n### Component 4: Client Interface Extension (`internal/client/interfaces.go`)\n\n- **Purpose:** Extend Client interface with L2TP methods\n- **Interfaces:**\n  ```go\n  // Add to existing Client interface:\n  GetL2TP(ctx context.Context, tunnelID int) (*L2TPConfig, error)\n  CreateL2TP(ctx context.Context, l2tp L2TPConfig) error\n  UpdateL2TP(ctx context.Context, l2tp L2TPConfig) error\n  DeleteL2TP(ctx context.Context, tunnelID int) error\n  ListL2TPs(ctx context.Context) ([]L2TPConfig, error)\n  ```\n- **Dependencies:** Existing Client interface\n- **Reuses:** Pattern from existing methods\n\n## Data Models\n\n### L2TPConfig\n\n```go\n// L2TPConfig represents L2TP configuration on an RTX router\ntype L2TPConfig struct {\n    ID               int          `json:\"id\"`                 // Tunnel ID\n    Name             string       `json:\"name,omitempty\"`     // Description\n    Version          string       `json:\"version\"`            // \"l2tp\" (v2) or \"l2tpv3\"\n    Mode             string       `json:\"mode\"`               // lns (v2), l2vpn (v3)\n    Shutdown         bool         `json:\"shutdown\"`           // Admin state\n    TunnelSource     string       `json:\"tunnel_source\"`      // Local endpoint\n    TunnelDest       string       `json:\"tunnel_destination\"` // Remote endpoint\n    Authentication   L2TPAuth     `json:\"authentication\"`     // Auth settings (v2 only)\n    IPPool           *L2TPIPPool  `json:\"ip_pool,omitempty\"`  // IP pool for clients (v2 only)\n    IPsecProfile     *L2TPIPsec   `json:\"ipsec_profile,omitempty\"` // L2TP/IPsec\n    L2TPv3Config     *L2TPv3Config `json:\"l2tpv3_config,omitempty\"` // L2TPv3 specific settings\n    KeepaliveEnabled bool         `json:\"keepalive_enabled\"`\n    DisconnectTime   int          `json:\"disconnect_time\"`    // Idle timeout\n}\n\n// L2TPAuth represents authentication settings (L2TPv2 only)\ntype L2TPAuth struct {\n    Method   string `json:\"method\"`   // pap, chap\n    Username string `json:\"username\"` // For LAC mode\n    Password string `json:\"password\"` // Sensitive\n}\n\n// L2TPIPPool represents IP address pool for clients (L2TPv2 only)\ntype L2TPIPPool struct {\n    Start string `json:\"start\"` // Start IP\n    End   string `json:\"end\"`   // End IP\n}\n\n// L2TPIPsec represents L2TP over IPsec settings\ntype L2TPIPsec struct {\n    Enabled      bool   `json:\"enabled\"`\n    PreSharedKey string `json:\"pre_shared_key\"` // Sensitive\n}\n\n// L2TPv3Config represents L2TPv3-specific settings for L2VPN\ntype L2TPv3Config struct {\n    LocalRouterID   string `json:\"local_router_id\"`    // IPv4 address for local router ID\n    RemoteRouterID  string `json:\"remote_router_id\"`   // IPv4 address for remote router ID\n    RemoteEndID     string `json:\"remote_end_id\"`      // Optional end ID string (32 chars max)\n    AlwaysOn        bool   `json:\"always_on\"`          // Keep connection always active (default: true)\n    BridgeInterface string `json:\"bridge_interface\"`   // Bridge interface to bind for L2 forwarding\n}\n```\n\n### Terraform Schema\n\n```hcl\n# ============================================\n# L2TPv2: Remote Access VPN Server (LNS mode)\n# ============================================\nresource \"rtx_l2tp\" \"vpn_server\" {\n  id       = 1\n  name     = \"L2TP_VPN\"\n  version  = \"l2tp\"   # L2TPv2\n  mode     = \"lns\"    # L2TP Network Server\n  shutdown = false\n\n  tunnel_source      = \"203.0.113.1\"\n  tunnel_destination = \"0.0.0.0\"  # Accept from any\n\n  authentication {\n    method   = \"chap\"\n    username = \"vpnuser\"\n    password = var.l2tp_password\n  }\n\n  ip_pool {\n    start = \"192.168.100.100\"\n    end   = \"192.168.100.200\"\n  }\n\n  # L2TP/IPsec (required for L2TPv2 on RTX)\n  ipsec_profile {\n    enabled        = true\n    pre_shared_key = var.ipsec_psk\n  }\n\n  keepalive_enabled = true\n  disconnect_time   = 3600\n}\n\n# ============================================\n# L2TPv3: Site-to-Site L2VPN\n# ============================================\nresource \"rtx_l2tp\" \"l2vpn_site_a\" {\n  id       = 2\n  name     = \"L2VPN_TO_SITE_B\"\n  version  = \"l2tpv3\"  # L2TPv3\n  mode     = \"l2vpn\"\n  shutdown = false\n\n  tunnel_source      = \"203.0.113.1\"\n  tunnel_destination = \"198.51.100.1\"\n\n  # L2TPv3 specific configuration\n  l2tpv3_config {\n    local_router_id  = \"1.1.1.1\"      # Unique identifier for this router\n    remote_router_id = \"2.2.2.2\"      # Remote router's identifier\n    remote_end_id    = \"site-b-tunnel\"\n    always_on        = true\n    bridge_interface = \"bridge1\"      # Bridge interface for L2 forwarding\n  }\n\n  # Optional: L2TPv3/IPsec for encryption\n  ipsec_profile {\n    enabled        = true\n    pre_shared_key = var.ipsec_psk\n  }\n\n  keepalive_enabled = true\n  disconnect_time   = 60\n}\n\n# L2TPv3 without IPsec (unencrypted L2VPN)\nresource \"rtx_l2tp\" \"l2vpn_unencrypted\" {\n  id       = 3\n  name     = \"L2VPN_INTERNAL\"\n  version  = \"l2tpv3\"\n  mode     = \"l2vpn\"\n  shutdown = false\n\n  tunnel_source      = \"10.0.0.1\"\n  tunnel_destination = \"10.0.0.2\"\n\n  l2tpv3_config {\n    local_router_id  = \"10.0.0.1\"\n    remote_router_id = \"10.0.0.2\"\n    always_on        = true\n    bridge_interface = \"bridge2\"\n  }\n\n  keepalive_enabled = true\n}\n```\n\n## RTX Command Mapping\n\n### Enable L2TP Service\n\n```\nl2tp service on                      # Enable both L2TPv2 and L2TPv3\nl2tp service on l2tp                 # Enable L2TPv2 only\nl2tp service on l2tpv3               # Enable L2TPv3 only\n```\n\n---\n\n### L2TPv2 Commands (Remote Access VPN)\n\n#### Configure PP Anonymous (LNS)\n\n```\npp select anonymous\npp bind tunnel<n>\n```\n\n#### Configure Authentication\n\n```\npp auth accept <pap/chap>\npp auth myname <name> <password>\n```\n\n#### Configure IPCP\n\n```\nppp ipcp ipaddress on\nppp ipcp msext on\nip pp remote address pool <start>-<end>\n```\n\n#### Configure L2TP/IPsec (Required for L2TPv2)\n\n```\ntunnel enable <n>\ntunnel encapsulation <n> l2tp\nipsec tunnel <n>\nipsec ike pre-shared-key <n> text <key>\n```\n\n---\n\n### L2TPv3 Commands (Site-to-Site L2VPN)\n\n#### Configure L2TPv3 Tunnel\n\n```\ntunnel select <n>\ntunnel encapsulation l2tpv3\ntunnel endpoint address <local_ip> <remote_ip>\n```\n\n#### Configure L2TPv3 Router IDs\n\n```\nl2tp local router-id <ipv4_address>    # Local router identifier\nl2tp remote router-id <ipv4_address>   # Remote router identifier\nl2tp remote end-id <string>            # Optional end ID (32 chars max)\n```\n\n#### Configure L2TPv3 Connection Behavior\n\n```\nl2tp always-on on                      # Keep connection always active (default)\nl2tp always-on off                     # Connect on demand\n```\n\n#### Configure L2TPv3/IPsec (Optional)\n\n```\nipsec tunnel <n>\nipsec ike pre-shared-key <n> text <key>\nipsec sa policy <n> <tunnel_n> esp aes-cbc sha-hmac\n```\n\n#### Bind L2TPv3 to Bridge Interface\n\n```\nbridge member bridge<n> tunnel<n>      # Add tunnel to bridge for L2 forwarding\n```\n\n---\n\n### Common L2TP Settings\n\n```\nl2tp tunnel disconnect time <n>        # Idle disconnect timeout (seconds)\nl2tp keepalive use on                  # Enable keepalive\nl2tp keepalive log on                  # Log keepalive events\nl2tp hostname <name>                   # Set hostname for L2TP negotiation\nl2tp tunnel auth on <password>         # Enable tunnel authentication\n```\n\n### Delete L2TP\n\n```\nno pp select anonymous                 # Delete L2TPv2 anonymous PP\nno tunnel <n>                          # Delete tunnel\nno l2tp service                        # Disable L2TP service\n```\n\n### Show Configuration\n\n```\nshow config | grep l2tp\nshow config | grep \"pp select anonymous\"\nshow status l2tp\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid Tunnel ID**\n   - **Handling:** Validate ID is positive integer\n   - **User Impact:** Clear validation error\n\n2. **Invalid Mode**\n   - **Handling:** Validate mode is \"lns\" or \"lac\"\n   - **User Impact:** Clear error with valid values\n\n3. **Invalid Authentication Method**\n   - **Handling:** Validate method is supported\n   - **User Impact:** Error with valid methods\n\n4. **Invalid IP Pool**\n   - **Handling:** Validate IP range is valid and start < end\n   - **User Impact:** Clear error with expected format\n\n5. **Missing Credentials**\n   - **Handling:** Require username/password for LAC mode\n   - **User Impact:** Validation error\n\n6. **Connection/Command Timeout**\n   - **Handling:** Use existing retry logic from `rtxClient`\n   - **User Impact:** Standard Terraform timeout error\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Parser Tests** (`l2tp_test.go`):\n  - Parse various RTX `show config` output for L2TP\n  - Test command builder functions with different parameters\n  - Test authentication configuration\n\n- **Service Tests** (`l2tp_service_test.go`):\n  - Mock executor for service method testing\n  - Test error handling for various failure scenarios\n  - Test LNS vs LAC mode handling\n\n### Integration Testing\n\n- **Resource Tests** (`resource_rtx_l2tp_test.go`):\n  - Full CRUD lifecycle with mock client\n  - Import functionality testing\n  - Sensitive attribute handling\n\n### End-to-End Testing\n\n- **Acceptance Tests** (with real RTX router):\n  - Create L2TP server\n  - Create L2TP client\n  - Configure L2TP/IPsec\n  - Update settings\n  - Delete configuration\n  - Import existing L2TP\n\n## File Structure\n\n```\ninternal/\n├── provider/\n│   ├── resource_rtx_l2tp.go      # NEW: Terraform resource\n│   └── resource_rtx_l2tp_test.go # NEW: Resource tests\n├── client/\n│   ├── interfaces.go              # MODIFY: Add L2TP types and methods\n│   ├── client.go                  # MODIFY: Add L2TP service initialization\n│   ├── l2tp_service.go           # NEW: L2TP service implementation\n│   └── l2tp_service_test.go      # NEW: Service tests\n└── rtx/\n    └── parsers/\n        ├── l2tp.go               # NEW: Parser and command builders\n        └── l2tp_test.go          # NEW: Parser tests\n```\n\n## Implementation Notes\n\n1. **Sensitive Data**: Password and PSK must be marked as sensitive in Terraform state.\n\n2. **Terraform ID**: Use tunnel ID as Terraform resource ID.\n\n3. **ForceNew**: Tunnel ID and mode are ForceNew. Other attributes support in-place updates.\n\n4. **PP Anonymous**: LNS mode uses PP anonymous configuration. Consider relationship.\n\n5. **L2TP/IPsec**: IPsec integration requires coordinating with IPsec tunnel configuration.\n\n6. **Tunnel vs PP**: RTX uses both tunnel and PP concepts. Map appropriately.\n\n7. **IP Pool**: Consider as embedded or separate resource.\n\n8. **Keepalive**: L2TP keepalive is different from IPsec DPD.\n\n9. **Configuration Save**: Use existing `SaveConfig()` pattern after modifications.\n\n10. **Provider Registration**: Add `resourceRTXL2TP` to provider's resource map.\n",
  "fileStats": {
    "size": 17144,
    "lines": 530,
    "lastModified": "2026-01-19T05:23:47.733Z"
  },
  "comments": []
}