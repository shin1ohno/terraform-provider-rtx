{
  "id": "snapshot_1769256687580_v6rg6fawh",
  "approvalId": "approval_1769256687574_zcvwk1e53",
  "approvalTitle": "Requirements: Terraform Schema Design Patterns",
  "version": 1,
  "timestamp": "2026-01-24T12:11:27.580Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document: Terraform Schema Design Patterns\n\n## Introduction\n\nThis specification establishes comprehensive schema design patterns and best practices for the Terraform provider for RTX routers. Proper schema design is fundamental to creating a provider that behaves predictably, integrates well with Terraform's workflow, and provides an excellent user experience.\n\nThese patterns are based on HashiCorp's official terraform-plugin-framework and terraform-plugin-sdk/v2 documentation (2025-2026), covering attribute configurability, plan modification, custom types, and migration strategies.\n\n## Alignment with Product Vision\n\nThis feature supports the product vision by:\n- **Predictability**: Users can understand and predict provider behavior based on schema design\n- **Consistency**: All resources follow the same patterns, reducing cognitive load\n- **Future-proofing**: Patterns prepare for eventual migration to terraform-plugin-framework\n- **Safety**: Proper schema design prevents accidental data loss or security issues\n\n## Requirements\n\n### Requirement 1: Attribute Configurability Matrix\n\n**User Story:** As a provider developer, I want clear guidelines for choosing between Required, Optional, and Computed flags, so that I select the correct combination for each attribute.\n\n#### Acceptance Criteria\n\n1. WHEN an attribute must always be provided by the user THEN it SHALL be marked `Required: true`\n2. WHEN an attribute may be provided by the user but has a sensible default THEN it SHALL be marked `Optional: true`\n3. WHEN an attribute is read-only and populated by the provider/API THEN it SHALL be marked `Computed: true`\n4. WHEN an attribute can be provided by the user OR populated by the API THEN it SHALL be marked `Optional: true, Computed: true`\n5. WHEN combining flags THEN `Required: true` and `Computed: true` SHALL NOT be combined (contradictory)\n6. WHEN combining flags THEN `Required: true` and `Optional: true` SHALL NOT be combined (contradictory)\n\n### Requirement 2: WriteOnly Attributes for Sensitive Data\n\n**User Story:** As a provider developer, I want to properly handle sensitive write-only data like passwords, so that credentials are not stored in state and cannot be read back.\n\n#### Acceptance Criteria\n\n1. WHEN an attribute contains sensitive credentials (passwords, API keys, tokens) THEN it SHALL be considered for WriteOnly treatment\n2. WHEN using WriteOnly attributes THEN `Computed: true` SHALL NOT be combined (WriteOnly values cannot be read)\n3. WHEN a WriteOnly attribute is set THEN the value SHALL be sent to the router but NOT stored in state\n4. WHEN implementing WriteOnly in SDK v2 THEN the system SHALL use `Sensitive: true` with appropriate handling\n5. WHEN migrating to plugin-framework THEN the system SHALL use the `WriteOnly: true` flag\n\n### Requirement 3: RequiresReplace Patterns\n\n**User Story:** As a provider developer, I want to correctly identify attributes that force resource recreation when changed, so that users understand the impact of their changes.\n\n#### Acceptance Criteria\n\n1. WHEN an attribute is immutable after creation (e.g., username, resource ID) THEN it SHALL use RequiresReplace\n2. WHEN an attribute change requires recreation only under certain conditions THEN it SHALL use RequiresReplaceIf\n3. WHEN an attribute change requires recreation only if user explicitly configured it THEN it SHALL use RequiresReplaceIfConfigured\n4. WHEN implementing in SDK v2 THEN the system SHALL use `ForceNew: true`\n5. WHEN implementing in plugin-framework THEN the system SHALL use plan modifiers\n6. WHEN a RequiresReplace attribute is changed THEN terraform plan SHALL clearly show resource will be destroyed and recreated\n\n### Requirement 4: DiffSuppressFunc and Semantic Equality\n\n**User Story:** As a provider developer, I want to suppress irrelevant diffs when values are semantically equal, so that users don't see noise in their plans.\n\n#### Acceptance Criteria\n\n1. WHEN two values are semantically equal but syntactically different (e.g., JSON with different key order) THEN the system SHALL suppress the diff\n2. WHEN implementing in SDK v2 THEN the system SHALL use `DiffSuppressFunc`\n3. WHEN implementing in plugin-framework THEN the system SHALL use custom types with semantic equality or plan modifiers\n4. WHEN normalizing values THEN the preferred approach SHALL be to canonicalize before storing in state\n5. WHEN case-insensitive comparison is needed THEN the system SHALL normalize to lowercase before storing\n6. WHEN whitespace differences should be ignored THEN the system SHALL trim/normalize whitespace\n\n### Requirement 5: Custom Types for Domain-Specific Values\n\n**User Story:** As a provider developer, I want to use custom types for domain-specific values, so that validation and equality checks are handled automatically.\n\n#### Acceptance Criteria\n\n1. WHEN an attribute represents an IP address or CIDR THEN the system SHALL use or create a custom IP/CIDR type\n2. WHEN an attribute represents JSON data THEN the system SHALL use a custom JSON type with semantic equality\n3. WHEN an attribute represents a timestamp THEN the system SHALL use a custom time type with format normalization\n4. WHEN an attribute has domain-specific validation (MAC address, RTX command format) THEN the system SHALL consider a custom type\n5. WHEN implementing custom types THEN the system SHALL prefer existing community packages (nettypes, jsontypes, timetypes)\n6. WHEN custom validation is needed THEN custom types SHALL implement the Validate() method\n\n### Requirement 6: UseStateForUnknown Pattern (Framework Migration Prep)\n\n**User Story:** As a provider developer, I want to understand the UseStateForUnknown pattern, so that I can prepare for eventual migration to terraform-plugin-framework.\n\n#### Acceptance Criteria\n\n1. WHEN an Optional+Computed attribute value is not expected to change frequently THEN UseStateForUnknown SHALL be used (in framework)\n2. WHEN UseStateForUnknown is used on list/set nested attributes THEN special care SHALL be taken due to index instability\n3. WHEN the attribute is at the top level or in a single-nested block THEN UseStateForUnknown is safe to use\n4. WHEN preparing SDK v2 code for migration THEN documentation SHALL note where UseStateForUnknown will be needed\n5. WHEN attribute value is truly computed fresh each time THEN UseStateForUnknown SHALL NOT be used\n\n### Requirement 7: Nested Block Design Patterns\n\n**User Story:** As a provider developer, I want clear guidelines for choosing between list, set, and single nested blocks, so that I select the appropriate structure for each use case.\n\n#### Acceptance Criteria\n\n1. WHEN elements have a defined order that matters THEN ListNestedAttribute/Block SHALL be used\n2. WHEN elements are order-independent and unique THEN SetNestedAttribute/Block SHALL be used\n3. WHEN exactly one nested object exists THEN SingleNestedAttribute/Block SHALL be used\n4. WHEN nested blocks have optional fields THEN each child attribute SHALL be marked appropriately (Optional/Computed)\n5. WHEN a nested element needs a stable identifier for updates THEN an `id` or `name` field SHALL be included\n6. WHEN elements lack a stable server-side ID THEN a synthetic identifier strategy SHALL be documented\n\n### Requirement 8: Zero Value Handling\n\n**User Story:** As a provider developer, I want to correctly distinguish between \"not set\" and \"explicitly set to zero/empty\", so that user intent is preserved.\n\n#### Acceptance Criteria\n\n1. WHEN a user explicitly sets a value to `\"\"`, `0`, or `false` THEN the system SHALL treat it as intentional\n2. WHEN a user does not specify a value THEN the system SHALL NOT send a zero value to the API\n3. WHEN using SDK v2 THEN `GetOk()` SHALL be used to distinguish set from unset\n4. WHEN using plugin-framework THEN `IsNull()` and `IsUnknown()` SHALL be used appropriately\n5. WHEN an API returns empty string to mean \"not configured\" THEN the state SHALL store null, not empty string\n6. WHEN converting between Terraform types and Go types THEN null/unknown checks SHALL precede value access\n\n### Requirement 9: Schema Versioning and State Migration\n\n**User Story:** As a provider developer, I want to safely evolve schema over time without breaking existing state files, so that users can upgrade smoothly.\n\n#### Acceptance Criteria\n\n1. WHEN schema layout changes (rename, restructure) THEN SchemaVersion SHALL be incremented\n2. WHEN SchemaVersion increases THEN a StateUpgrader function SHALL be provided\n3. WHEN writing StateUpgrader THEN the function SHALL handle all previous versions\n4. WHEN testing state migration THEN unit tests SHALL verify upgrader logic\n5. WHEN testing state migration THEN acceptance tests SHALL verify upgrade from previous provider versions\n6. WHEN breaking changes are unavoidable THEN migration guide documentation SHALL be provided\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: Each custom type should handle one domain concept\n- **Modular Design**: Custom types and validators should be in dedicated packages\n- **Reusability**: Patterns should be easily applicable to new resources\n- **Clear Interfaces**: Schema builders should have consistent signatures\n\n### Documentation\n\n- Each pattern should be documented with examples\n- Decision rationale should be recorded for non-obvious choices\n- Migration notes should be maintained for framework transition\n\n### Backward Compatibility\n\n- Schema changes must not break existing state files without migration\n- New optional fields should have sensible defaults\n- Changing Optional+Computed to Computed-only is a breaking change\n\n### Performance\n\n- Custom type validation should not significantly impact plan time\n- Semantic equality checks should be efficient\n- State migration should handle large state files gracefully\n\n## Scope\n\n### Patterns to Document and Implement\n\n1. **Attribute Configurability**: Required/Optional/Computed decision tree\n2. **WriteOnly**: Sensitive credential handling\n3. **RequiresReplace**: Immutable attribute handling\n4. **DiffSuppressFunc**: Semantic equality patterns\n5. **Custom Types**: IP/CIDR, JSON, Time, RTX-specific types\n6. **UseStateForUnknown**: Framework migration preparation\n7. **Nested Blocks**: List vs Set vs Single selection\n8. **Zero Values**: Null vs Zero distinction\n9. **State Migration**: Version upgrade patterns\n\n### Resources to Apply Patterns\n\nAll existing and future resources should follow these patterns. Priority:\n- [ ] rtx_admin_user (reference implementation)\n- [ ] rtx_admin\n- [ ] Resources with password/credential fields (WriteOnly)\n- [ ] Resources with immutable identifiers (RequiresReplace)\n\n## References\n\n- HashiCorp terraform-plugin-framework Handling Data documentation\n- HashiCorp terraform-plugin-sdk/v2 Schema documentation\n- terraform-plugin-framework-jsontypes package\n- terraform-plugin-framework-nettypes package\n- terraform-plugin-framework-timetypes package\n- Existing `optional-field-preservation` spec\n- Existing `terraform-provider-testing-patterns` spec\n",
  "fileStats": {
    "size": 11081,
    "lines": 192,
    "lastModified": "2026-01-24T12:10:46.727Z"
  },
  "comments": []
}