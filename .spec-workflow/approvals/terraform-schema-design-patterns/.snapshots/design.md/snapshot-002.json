{
  "id": "snapshot_1769256918193_21vso2w8e",
  "approvalId": "approval_1769256892331_dvci1f95m",
  "approvalTitle": "Design: Terraform Schema Design Patterns",
  "version": 2,
  "timestamp": "2026-01-24T12:15:18.193Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Terraform Schema Design Patterns\n\n## Overview\n\nThis document describes the technical design for implementing comprehensive schema design patterns in the Terraform provider for RTX routers. These patterns establish consistent approaches to attribute configurability, sensitive data handling, immutable fields, diff suppression, custom types, and schema evolution.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **SDK**: terraform-plugin-sdk/v2 v2.37.0 (with notes for plugin-framework migration)\n- **Go Version**: 1.23 with proper nil/pointer handling\n- **Logging**: Zerolog for debugging schema issues\n- **Code Style**: golangci-lint compliance\n\n### Project Structure (structure.md)\n\nImplementation will follow the established structure:\n- Schema definitions in `internal/provider/resource_*.go`\n- Custom types in `internal/provider/types/`\n- Validators in `internal/provider/validators/`\n- State upgraders in `internal/provider/state_upgraders/`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **terraform-plugin-sdk/v2/helper/schema**: Core schema definitions\n- **terraform-plugin-sdk/v2/helper/validation**: Built-in validators\n- **field_helpers.go**: Existing field extraction utilities from optional-field-preservation spec\n- **Parsers**: Value normalization in parsers package\n\n### Integration Points\n\n- **Provider resources**: All schema definitions\n- **Client interfaces**: Pointer types for optional fields\n- **Command builders**: Value formatting and normalization\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Schema Layer\"\n        A[Attribute Definition] --> B{Configurability}\n        B --> C[Required]\n        B --> D[Optional]\n        B --> E[Computed]\n        B --> F[Optional+Computed]\n    end\n\n    subgraph \"Behavior Modifiers\"\n        G[ForceNew/RequiresReplace]\n        H[Sensitive/WriteOnly]\n        I[DiffSuppressFunc]\n        J[StateFunc]\n    end\n\n    subgraph \"Type System\"\n        K[Primitive Types] --> L[TypeString]\n        K --> M[TypeInt]\n        K --> N[TypeBool]\n        O[Collection Types] --> P[TypeList]\n        O --> Q[TypeSet]\n        O --> R[TypeMap]\n        S[Custom Types] --> T[IPType]\n        S --> U[JSONType]\n        S --> V[TimeType]\n    end\n\n    subgraph \"Evolution\"\n        W[SchemaVersion]\n        X[StateUpgraders]\n    end\n\n    A --> G\n    A --> H\n    A --> I\n    A --> J\n    A --> K\n    A --> O\n    A --> S\n    A --> W\n```\n\n## Components and Interfaces\n\n### Component 1: Attribute Configurability Patterns\n\n- **Purpose:** Define when to use each attribute configuration\n- **Location:** Documentation and code patterns in all resource files\n- **Patterns:**\n\n```go\n// Pattern A: Required - Must be provided by user\n\"username\": {\n    Type:        schema.TypeString,\n    Required:    true,\n    Description: \"Username for the admin user\",\n},\n\n// Pattern B: Optional - User may provide, no default\n\"description\": {\n    Type:        schema.TypeString,\n    Optional:    true,\n    Description: \"Optional description\",\n},\n\n// Pattern C: Computed - Read-only, provider fills\n\"created_at\": {\n    Type:        schema.TypeString,\n    Computed:    true,\n    Description: \"Timestamp when resource was created\",\n},\n\n// Pattern D: Optional+Computed - User may override API default\n\"administrator\": {\n    Type:        schema.TypeBool,\n    Optional:    true,\n    Computed:    true,\n    Description: \"Whether user has admin privileges\",\n},\n```\n\n### Component 2: WriteOnly/Sensitive Handler\n\n- **Purpose:** Handle credentials without storing in state\n- **Location:** `internal/provider/schema_helpers.go`\n- **Interfaces:**\n\n```go\n// WriteOnlyStringSchema returns a schema for write-only string fields (SDK v2)\n// Note: True WriteOnly requires plugin-framework; this is best-effort for SDK v2\nfunc WriteOnlyStringSchema(description string) *schema.Schema {\n    return &schema.Schema{\n        Type:        schema.TypeString,\n        Optional:    true,\n        Sensitive:   true,\n        Description: description,\n        // In SDK v2, we can't truly make it write-only\n        // Best practice: don't read back in Read function\n    }\n}\n\n// SensitiveStringSchema returns a schema for sensitive but readable fields\nfunc SensitiveStringSchema(description string, required bool) *schema.Schema {\n    return &schema.Schema{\n        Type:        schema.TypeString,\n        Required:    required,\n        Optional:    !required,\n        Sensitive:   true,\n        Description: description,\n    }\n}\n```\n\n### Component 3: RequiresReplace Patterns\n\n- **Purpose:** Mark immutable fields that force recreation\n- **Location:** Resource schema definitions\n- **Patterns:**\n\n```go\n// Pattern: Immutable identifier\n\"username\": {\n    Type:        schema.TypeString,\n    Required:    true,\n    ForceNew:    true,  // SDK v2 way\n    Description: \"Username (cannot be changed after creation)\",\n},\n\n// Pattern: Conditional replacement (plugin-framework prep)\n// In SDK v2, use CustomizeDiff for conditional ForceNew\nfunc resourceAdminUserCustomizeDiff(ctx context.Context, d *schema.ResourceDiff, meta interface{}) error {\n    // If username_type changes from \"local\" to \"remote\", force replacement\n    if d.HasChange(\"username_type\") {\n        old, new := d.GetChange(\"username_type\")\n        if old.(string) == \"local\" && new.(string) == \"remote\" {\n            d.ForceNew(\"username_type\")\n        }\n    }\n    return nil\n}\n```\n\n### Component 4: DiffSuppressFunc Library\n\n- **Purpose:** Suppress irrelevant diffs for semantic equality\n- **Location:** `internal/provider/diff_suppress.go`\n- **Interfaces:**\n\n```go\n// SuppressCaseDiff ignores case differences\nfunc SuppressCaseDiff(k, old, new string, d *schema.ResourceData) bool {\n    return strings.EqualFold(old, new)\n}\n\n// SuppressWhitespaceDiff ignores leading/trailing whitespace\nfunc SuppressWhitespaceDiff(k, old, new string, d *schema.ResourceData) bool {\n    return strings.TrimSpace(old) == strings.TrimSpace(new)\n}\n\n// SuppressJSONDiff compares JSON semantically\nfunc SuppressJSONDiff(k, old, new string, d *schema.ResourceData) bool {\n    var oldJSON, newJSON interface{}\n    if err := json.Unmarshal([]byte(old), &oldJSON); err != nil {\n        return false\n    }\n    if err := json.Unmarshal([]byte(new), &newJSON); err != nil {\n        return false\n    }\n    return reflect.DeepEqual(oldJSON, newJSON)\n}\n\n// SuppressEquivalentIPDiff compares IP addresses accounting for format\nfunc SuppressEquivalentIPDiff(k, old, new string, d *schema.ResourceData) bool {\n    oldIP := net.ParseIP(old)\n    newIP := net.ParseIP(new)\n    if oldIP == nil || newIP == nil {\n        return old == new\n    }\n    return oldIP.Equal(newIP)\n}\n```\n\n### Component 5: Custom Types (Framework Migration Prep)\n\n- **Purpose:** Define domain-specific types with validation and equality\n- **Location:** `internal/provider/types/`\n- **Note:** SDK v2 doesn't support custom types directly; use StateFunc + DiffSuppressFunc\n\n```go\n// For SDK v2: Normalize in StateFunc, suppress in DiffSuppressFunc\n\"ip_address\": {\n    Type:             schema.TypeString,\n    Optional:         true,\n    StateFunc:        normalizeIPAddress,\n    DiffSuppressFunc: SuppressEquivalentIPDiff,\n    ValidateFunc:     validation.IsIPAddress,\n    Description:      \"IP address in any valid format\",\n},\n\n// normalizeIPAddress converts IP to canonical form\nfunc normalizeIPAddress(val interface{}) string {\n    ip := net.ParseIP(val.(string))\n    if ip == nil {\n        return val.(string)\n    }\n    // Return canonical IPv4 or IPv6 form\n    if ip4 := ip.To4(); ip4 != nil {\n        return ip4.String()\n    }\n    return ip.String()\n}\n```\n\n### Component 6: Nested Block Patterns\n\n- **Purpose:** Define consistent patterns for nested structures\n- **Location:** Resource schema definitions\n- **Patterns:**\n\n```go\n// Pattern: List (ordered, duplicates allowed)\n\"filter_rules\": {\n    Type:     schema.TypeList,\n    Optional: true,\n    Elem: &schema.Resource{\n        Schema: map[string]*schema.Schema{\n            \"id\": {\n                Type:     schema.TypeInt,\n                Required: true,\n            },\n            \"action\": {\n                Type:     schema.TypeString,\n                Required: true,\n            },\n            \"protocol\": {\n                Type:     schema.TypeString,\n                Optional: true,\n                Computed: true,\n            },\n        },\n    },\n},\n\n// Pattern: Set (unordered, unique by hash)\n\"allowed_hosts\": {\n    Type:     schema.TypeSet,\n    Optional: true,\n    Elem: &schema.Schema{\n        Type: schema.TypeString,\n    },\n},\n\n// Pattern: Single nested block (MaxItems=1)\n\"timeouts\": {\n    Type:     schema.TypeList,\n    Optional: true,\n    MaxItems: 1,\n    Elem: &schema.Resource{\n        Schema: map[string]*schema.Schema{\n            \"create\": {Type: schema.TypeString, Optional: true},\n            \"update\": {Type: schema.TypeString, Optional: true},\n            \"delete\": {Type: schema.TypeString, Optional: true},\n        },\n    },\n},\n```\n\n### Component 7: Zero Value Handling\n\n- **Purpose:** Distinguish between unset and explicitly zero\n- **Location:** Resource CRUD functions using field_helpers.go\n- **Pattern:**\n\n```go\n// Using GetOk to check if value was set\nfunc resourceUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {\n    // Check if user explicitly set the value\n    if v, ok := d.GetOk(\"timeout\"); ok {\n        // User set a value (could be 0 if TypeInt allows)\n        config.Timeout = v.(int)\n    } else {\n        // User did not set - preserve existing or use default\n        // d.Get(\"timeout\") returns state value due to Optional+Computed\n        config.Timeout = d.Get(\"timeout\").(int)\n    }\n}\n\n// For boolean fields where false is meaningful\nif v, ok := d.GetOkExists(\"enabled\"); ok {\n    // User explicitly set true or false\n    config.Enabled = v.(bool)\n}\n```\n\n### Component 8: State Upgraders\n\n- **Purpose:** Handle schema version migrations\n- **Location:** `internal/provider/state_upgraders/`\n- **Interfaces:**\n\n```go\n// ResourceAdminUserV0 returns the V0 schema for state upgrade\nfunc ResourceAdminUserV0() *schema.Resource {\n    return &schema.Resource{\n        Schema: map[string]*schema.Schema{\n            \"name\": {  // Old field name\n                Type:     schema.TypeString,\n                Required: true,\n            },\n        },\n    }\n}\n\n// StateUpgradeAdminUserV0 upgrades from V0 to V1\nfunc StateUpgradeAdminUserV0(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) {\n    if rawState == nil {\n        return nil, nil\n    }\n\n    // Rename \"name\" to \"username\"\n    if v, ok := rawState[\"name\"]; ok {\n        rawState[\"username\"] = v\n        delete(rawState, \"name\")\n    }\n\n    return rawState, nil\n}\n\n// Resource definition with StateUpgraders\nfunc resourceAdminUser() *schema.Resource {\n    return &schema.Resource{\n        // ... CRUD functions ...\n        SchemaVersion: 1,\n        StateUpgraders: []schema.StateUpgrader{\n            {\n                Version: 0,\n                Type:    ResourceAdminUserV0().CoreConfigSchema().ImpliedType(),\n                Upgrade: StateUpgradeAdminUserV0,\n            },\n        },\n        Schema: currentSchema,\n    }\n}\n```\n\n## Data Models\n\n### Decision Tree for Attribute Configuration\n\n```\nIs the value always provided by the user?\n├── YES → Required: true\n└── NO\n    ├── Is the value ever provided by the user?\n    │   ├── NO → Computed: true (read-only)\n    │   └── YES\n    │       ├── Can API/router provide a default?\n    │       │   ├── YES → Optional: true, Computed: true\n    │       │   └── NO → Optional: true\n    │       └── Is change immutable after create?\n    │           ├── YES → Add ForceNew: true\n    │           └── NO → (no additional flag)\n    └── Is it sensitive (password, key)?\n        ├── YES → Add Sensitive: true\n        └── NO → (no additional flag)\n```\n\n### Schema Pattern Reference\n\n| Use Case | Required | Optional | Computed | ForceNew | Sensitive |\n|----------|----------|----------|----------|----------|-----------|\n| User must specify | ✓ | | | | |\n| User may specify, no default | | ✓ | | | |\n| Read-only from API | | | ✓ | | |\n| User may override API default | | ✓ | ✓ | | |\n| Immutable identifier | ✓ | | | ✓ | |\n| Password field | | ✓ | | | ✓ |\n| Generated ID | | | ✓ | | |\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid Attribute Combination**\n   - **Handling:** Terraform SDK validates at init\n   - **User Impact:** Provider fails to load with clear error\n\n2. **State Upgrade Failure**\n   - **Handling:** Return error from StateUpgrader\n   - **User Impact:** terraform apply fails, state preserved\n\n3. **DiffSuppressFunc Panic**\n   - **Handling:** Wrap in recover, log error, return false\n   - **User Impact:** Diff shown (safe fallback)\n\n4. **Zero Value Misinterpretation**\n   - **Handling:** Use GetOk/GetOkExists appropriately\n   - **User Impact:** Prevented by proper implementation\n\n## Testing Strategy\n\n### Unit Testing\n\n- Test DiffSuppressFunc with various inputs\n- Test StateUpgraders with old state formats\n- Test StateFunc normalization\n- Test validation functions\n\n### Integration Testing\n\n- Test schema behavior in acceptance tests\n- Verify ForceNew triggers recreation\n- Verify Sensitive fields are masked\n- Verify state upgrades across versions\n\n## Migration Notes for terraform-plugin-framework\n\nWhen migrating to terraform-plugin-framework:\n\n| SDK v2 | Plugin Framework |\n|--------|------------------|\n| `ForceNew: true` | `RequiresReplace()` plan modifier |\n| `DiffSuppressFunc` | Custom type with `SemanticEquals()` |\n| `StateFunc` | Custom type with normalization in `ValueFromTerraform()` |\n| `Sensitive: true` | `Sensitive: true` (same) |\n| `GetOk()` | `IsNull()` / `IsUnknown()` |\n| N/A | `UseStateForUnknown()` plan modifier |\n| N/A | `WriteOnly: true` |\n\n## Security Considerations\n\n- Never log Sensitive field values\n- Validate all user inputs before use\n- Use Sensitive for any credential fields\n- Consider WriteOnly for passwords when migrating to framework\n",
  "fileStats": {
    "size": 14177,
    "lines": 478,
    "lastModified": "2026-01-24T12:14:41.812Z"
  },
  "comments": []
}