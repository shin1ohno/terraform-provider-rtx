{
  "id": "snapshot_1768800190052_z9xzkjoye",
  "approvalId": "approval_1768799796638_pip5d04hi",
  "approvalTitle": "Design: rtx_nat_static resource",
  "version": 2,
  "timestamp": "2026-01-19T05:23:10.052Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: rtx_nat_static\n\n## Overview\n\nThe `rtx_nat_static` resource enables Terraform-based management of static NAT (1:1 address mapping) on Yamaha RTX series routers. Following Cisco IOS XE Terraform provider naming conventions, this resource manages NAT descriptors configured for one-to-one address translation, including port-based static NAT.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`internal/client/nat_masquerade_service.go`**: Pattern for NAT descriptor service implementation (if created first).\n- **`internal/client/interfaces.go`**: Extend the `Client` interface with static NAT methods.\n- **`internal/rtx/parsers/nat_masquerade.go`**: Reference for NAT parser implementation (if created first).\n- **`internal/provider/resource_rtx_dhcp_scope.go`**: Template for Terraform resource structure.\n\n### Integration Points\n\n- **`rtxClient`**: Add static NAT methods for CRUD operations\n- **`Executor`**: Use existing SSH command execution infrastructure\n- **Interface binding**: Coordinate with interface configuration\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph Provider Layer\n        TFResource[resource_rtx_nat_static.go]\n    end\n\n    subgraph Client Layer\n        Client[client.go - Interface Extension]\n        NATStaticService[nat_static_service.go]\n    end\n\n    subgraph Parser Layer\n        NATStaticParser[nat_static.go]\n        Commands[Command Builders]\n        OutputParser[Output Parsers]\n    end\n\n    TFResource --> Client\n    Client --> NATStaticService\n    NATStaticService --> NATStaticParser\n    NATStaticParser --> Commands\n    NATStaticParser --> OutputParser\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: `NATStaticService` handles all static NAT CRUD operations\n- **Component Isolation**: Parser, service, and resource layers clearly separated\n- **Service Layer Separation**: Service encapsulates all static NAT logic\n- **Utility Modularity**: Shared validation functions for IP/port operations\n\n## Components and Interfaces\n\n### Component 1: NATStaticService (`internal/client/nat_static_service.go`)\n\n- **Purpose:** Handles all static NAT CRUD operations against the RTX router\n- **Interfaces:**\n  ```go\n  type NATStaticService struct {\n      executor Executor\n      client   *rtxClient\n  }\n\n  func (s *NATStaticService) Create(ctx context.Context, nat NATStatic) error\n  func (s *NATStaticService) Get(ctx context.Context, descriptorID int) (*NATStatic, error)\n  func (s *NATStaticService) Update(ctx context.Context, nat NATStatic) error\n  func (s *NATStaticService) Delete(ctx context.Context, descriptorID int) error\n  func (s *NATStaticService) List(ctx context.Context) ([]NATStatic, error)\n  ```\n- **Dependencies:** `Executor`, `rtxClient`, `parsers.NATStaticParser`\n- **Reuses:** Pattern from service layer implementations\n\n### Component 2: NATStaticParser (`internal/rtx/parsers/nat_static.go`)\n\n- **Purpose:** Parses RTX router output for static NAT configuration and builds commands\n- **Interfaces:**\n  ```go\n  type NATStatic struct {\n      DescriptorID  int                 `json:\"descriptor_id\"`\n      StaticEntries []NATStaticEntry    `json:\"static_entries\"`\n      Interface     string              `json:\"interface,omitempty\"`\n  }\n\n  type NATStaticEntry struct {\n      InsideLocal       string `json:\"inside_local\"`\n      InsideLocalPort   int    `json:\"inside_local_port,omitempty\"`\n      OutsideGlobal     string `json:\"outside_global\"`\n      OutsideGlobalPort int    `json:\"outside_global_port,omitempty\"`\n      Protocol          string `json:\"protocol,omitempty\"` // tcp/udp\n  }\n\n  func ParseNATStaticConfig(raw string) ([]NATStatic, error)\n  func BuildNATDescriptorTypeStaticCommand(id int) string\n  func BuildNATStaticMappingCommand(id int, entry NATStaticEntry) string\n  func BuildNATStaticPortMappingCommand(id int, entry NATStaticEntry) string\n  func BuildDeleteNATStaticCommand(id int) string\n  ```\n- **Dependencies:** `regexp`, `strings`, `strconv`\n- **Reuses:** IP validation patterns\n\n### Component 3: Terraform Resource (`internal/provider/resource_rtx_nat_static.go`)\n\n- **Purpose:** Terraform resource definition implementing CRUD lifecycle\n- **Interfaces:**\n  ```go\n  func resourceRTXNATStatic() *schema.Resource\n  func resourceRTXNATStaticCreate(ctx, d, meta) diag.Diagnostics\n  func resourceRTXNATStaticRead(ctx, d, meta) diag.Diagnostics\n  func resourceRTXNATStaticUpdate(ctx, d, meta) diag.Diagnostics\n  func resourceRTXNATStaticDelete(ctx, d, meta) diag.Diagnostics\n  func resourceRTXNATStaticImport(ctx, d, meta) ([]*schema.ResourceData, error)\n  ```\n- **Dependencies:** `Client`, `NATStatic`, Terraform SDK\n- **Reuses:** Resource patterns from other implementations\n\n### Component 4: Client Interface Extension (`internal/client/interfaces.go`)\n\n- **Purpose:** Extend Client interface with static NAT methods\n- **Interfaces:**\n  ```go\n  // Add to existing Client interface:\n  GetNATStatic(ctx context.Context, descriptorID int) (*NATStatic, error)\n  CreateNATStatic(ctx context.Context, nat NATStatic) error\n  UpdateNATStatic(ctx context.Context, nat NATStatic) error\n  DeleteNATStatic(ctx context.Context, descriptorID int) error\n  ListNATStatics(ctx context.Context) ([]NATStatic, error)\n  ```\n- **Dependencies:** Existing Client interface\n- **Reuses:** Pattern from existing methods\n\n## Data Models\n\n### NATStatic\n\n```go\n// NATStatic represents a static NAT descriptor on an RTX router\ntype NATStatic struct {\n    DescriptorID  int              `json:\"descriptor_id\"`   // NAT descriptor ID (1-65535)\n    StaticEntries []NATStaticEntry `json:\"static_entries\"`  // 1:1 mappings\n    Interface     string           `json:\"interface,omitempty\"` // Bound interface\n}\n\n// NATStaticEntry represents a 1:1 NAT mapping\ntype NATStaticEntry struct {\n    InsideLocal       string `json:\"inside_local\"`         // Inside local IP\n    InsideLocalPort   int    `json:\"inside_local_port,omitempty\"`\n    OutsideGlobal     string `json:\"outside_global\"`       // Outside global IP\n    OutsideGlobalPort int    `json:\"outside_global_port,omitempty\"`\n    Protocol          string `json:\"protocol,omitempty\"`   // tcp/udp for port NAT\n}\n```\n\n### Terraform Schema\n\n```hcl\n# Static 1:1 NAT\nresource \"rtx_nat_static\" \"webserver\" {\n  id = 10  # Descriptor ID, Required, ForceNew\n\n  static_entries = [\n    {\n      inside_local   = \"192.168.1.10\"\n      outside_global = \"203.0.113.10\"\n    }\n  ]\n}\n\n# Port-based static NAT\nresource \"rtx_nat_static\" \"port_forward\" {\n  id = 11\n\n  static_entries = [\n    {\n      protocol            = \"tcp\"\n      inside_local        = \"192.168.1.20\"\n      inside_local_port   = 80\n      outside_global      = \"203.0.113.1\"\n      outside_global_port = 8080\n    },\n    {\n      protocol            = \"tcp\"\n      inside_local        = \"192.168.1.21\"\n      inside_local_port   = 443\n      outside_global      = \"203.0.113.1\"\n      outside_global_port = 443\n    }\n  ]\n}\n```\n\n## RTX Command Mapping\n\n### Create Static NAT Descriptor\n\n```\nnat descriptor type <id> static\n```\n\n### Configure 1:1 Mapping\n\n```\nnat descriptor static <id> <outer_ip>=<inner_ip>\n```\n\nExample: `nat descriptor static 10 203.0.113.10=192.168.1.10`\n\n### Configure Port-based Mapping\n\n```\nnat descriptor static <id> <outer_ip>:<port>=<inner_ip>:<port> <protocol>\n```\n\nExample: `nat descriptor static 11 203.0.113.1:8080=192.168.1.20:80 tcp`\n\n### Apply to Interface\n\n```\nip <interface> nat descriptor <id>\n```\n\nExample: `ip pp1 nat descriptor 10`\n\n### Delete Static NAT\n\n```\nno nat descriptor type <id>\n```\n\n### Show NAT Configuration\n\n```\nshow nat descriptor address\nshow config | grep \"nat descriptor\"\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Invalid Descriptor ID**\n   - **Handling:** Validate ID is in range 1-65535\n   - **User Impact:** Clear validation error with valid range\n\n2. **Descriptor Already Exists**\n   - **Handling:** Parse RTX output for existing descriptor\n   - **User Impact:** Error suggesting import or different ID\n\n3. **Invalid IP Address**\n   - **Handling:** Validate IP address format\n   - **User Impact:** Clear error with expected format\n\n4. **Invalid Port**\n   - **Handling:** Validate port is in range 1-65535\n   - **User Impact:** Clear error with valid range\n\n5. **Overlapping Mapping**\n   - **Handling:** Check for conflicts with existing mappings\n   - **User Impact:** Error indicating conflict\n\n6. **Missing Protocol for Port NAT**\n   - **Handling:** Require protocol when ports are specified\n   - **User Impact:** Validation error requiring protocol\n\n7. **Connection/Command Timeout**\n   - **Handling:** Use existing retry logic from `rtxClient`\n   - **User Impact:** Standard Terraform timeout error\n\n## Testing Strategy\n\n### Unit Testing\n\n- **Parser Tests** (`nat_static_test.go`):\n  - Parse various RTX `show nat descriptor` output formats\n  - Test command builder functions with different parameters\n  - Test port-based NAT command building\n\n- **Service Tests** (`nat_static_service_test.go`):\n  - Mock executor for service method testing\n  - Test error handling for various failure scenarios\n  - Test multiple entry handling\n\n### Integration Testing\n\n- **Resource Tests** (`resource_rtx_nat_static_test.go`):\n  - Full CRUD lifecycle with mock client\n  - Import functionality testing\n  - Port-based NAT configuration testing\n\n### End-to-End Testing\n\n- **Acceptance Tests** (with real RTX router):\n  - Create 1:1 static NAT\n  - Create port-based static NAT\n  - Create multiple mappings\n  - Update mappings\n  - Delete static NAT\n  - Import existing configuration\n\n## File Structure\n\n```\ninternal/\n├── provider/\n│   ├── resource_rtx_nat_static.go      # NEW: Terraform resource\n│   └── resource_rtx_nat_static_test.go # NEW: Resource tests\n├── client/\n│   ├── interfaces.go                    # MODIFY: Add NATStatic type and methods\n│   ├── client.go                        # MODIFY: Add NAT static service initialization\n│   ├── nat_static_service.go           # NEW: NAT static service implementation\n│   └── nat_static_service_test.go      # NEW: Service tests\n└── rtx/\n    └── parsers/\n        ├── nat_static.go               # NEW: Parser and command builders\n        └── nat_static_test.go          # NEW: Parser tests\n```\n\n## Implementation Notes\n\n1. **Descriptor Type**: This resource specifically handles `static` type NAT descriptors, distinct from `masquerade` type.\n\n2. **Bidirectional Translation**: Static NAT is bidirectional - traffic can be initiated from either side.\n\n3. **Terraform ID**: Use descriptor ID directly as Terraform resource ID.\n\n4. **ForceNew**: `descriptor_id` is ForceNew. Static entries support in-place updates.\n\n5. **Entry Ordering**: Static entries may need sequence numbers. Consider auto-generation.\n\n6. **Protocol Requirement**: When `inside_local_port` or `outside_global_port` is set, `protocol` must be specified.\n\n7. **IP vs ipcp**: Unlike masquerade NAT, static NAT typically uses specific IP addresses, not interface references.\n\n8. **Configuration Save**: Use existing `SaveConfig()` pattern after modifications.\n\n9. **Provider Registration**: Add `resourceRTXNATStatic` to provider's resource map.\n\n10. **Shared Code**: Consider sharing common NAT parsing code with `rtx_nat_masquerade` resource.\n",
  "fileStats": {
    "size": 11284,
    "lines": 341,
    "lastModified": "2026-01-19T05:08:41.535Z"
  },
  "comments": []
}