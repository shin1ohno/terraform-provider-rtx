{
  "id": "snapshot_1769343415989_ze0873wnb",
  "approvalId": "approval_1769343054990_64fel8sh3",
  "approvalTitle": "SSH Connection Pool Redesign - Design",
  "version": 2,
  "timestamp": "2026-01-25T12:16:55.989Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: SSH Connection Pool Redesign\n\n## Overview\n\nThis design transforms `SSHSessionPool` from a session-based pool (multiple sessions on one connection) to a connection-based pool (multiple independent connections, each with one session). This addresses the RTX router limitation where only one SSH session is allowed per connection.\n\n## Current Architecture (Problem)\n\n```\n┌─────────────────────────────────────────┐\n│           SSHSessionPool                │\n├─────────────────────────────────────────┤\n│  sshClient *ssh.Client  (1 connection)  │\n│                                         │\n│  available []*PooledSSHSession          │\n│     └─> workingSession (ssh.Session #1) │  ← RTX: OK\n│     └─> workingSession (ssh.Session #2) │  ← RTX: REJECTED!\n│     └─> workingSession (ssh.Session #3) │  ← RTX: REJECTED!\n└─────────────────────────────────────────┘\n```\n\n**Problem**: RTX routers reject additional sessions on the same connection with `ssh: rejected: connect failed (open failed)`.\n\n## New Architecture (Solution)\n\n```\n┌─────────────────────────────────────────┐\n│         SSHConnectionPool               │\n├─────────────────────────────────────────┤\n│  sshConfig  *ssh.ClientConfig           │\n│  address    string                      │\n│                                         │\n│  available []*PooledConnection          │\n│     └─> ssh.Client #1 + workingSession  │  ← Own TCP connection\n│     └─> ssh.Client #2 + workingSession  │  ← Own TCP connection\n│                                         │\n│  inUse map[*PooledConnection]bool       │\n│     └─> ssh.Client #3 + workingSession  │  ← Currently executing\n└─────────────────────────────────────────┘\n```\n\nEach `PooledConnection` has its own:\n- TCP connection to the RTX router\n- `ssh.Client` (SSH handshake completed)\n- `workingSession` (single ssh.Session with terminal initialization)\n\n## Data Structures\n\n### PooledConnection (Replaces PooledSSHSession)\n\n```go\n// PooledConnection wraps a complete SSH connection with its session\ntype PooledConnection struct {\n    client         *ssh.Client      // Independent SSH connection\n    session        *workingSession  // Single session on this connection\n    adminMode      bool             // Admin authentication state\n    poolID         string           // Unique identifier for logging\n    lastUsed       time.Time        // For idle timeout tracking\n    useCount       int              // Number of times this connection was used\n}\n```\n\n### SSHConnectionPool (Replaces SSHSessionPool)\n\n```go\n// SSHConnectionPool manages a pool of SSH connections\ntype SSHConnectionPool struct {\n    mu                sync.Mutex\n    cond              *sync.Cond\n\n    // Connection factory\n    sshConfig         *ssh.ClientConfig\n    address           string           // host:port\n\n    // Pool configuration\n    config            SSHPoolConfig\n\n    // Connection tracking\n    available         []*PooledConnection\n    inUse             map[*PooledConnection]bool\n\n    // Statistics\n    totalCreated      int\n    totalAcquisitions int\n    waitCount         int\n\n    // State\n    closed            bool\n\n    // For testing\n    connectionFactory ConnectionFactory\n    skipIdleCleanup   bool\n}\n```\n\n### ConnectionFactory\n\n```go\n// ConnectionFactory creates a new PooledConnection\n// Used for dependency injection in tests\ntype ConnectionFactory func() (*PooledConnection, error)\n```\n\n## Key Changes from Current Implementation\n\n| Aspect | Current (Session Pool) | New (Connection Pool) |\n|--------|----------------------|----------------------|\n| Pool holds | 1 ssh.Client, N sessions | N ssh.Clients, N sessions |\n| Session creation | `newWorkingSession(p.sshClient)` | `ssh.Dial()` + `newWorkingSession(client)` |\n| Connection reuse | Session reused, connection shared | Connection reused, session stays open |\n| RTX compatibility | ❌ Rejected after 1st session | ✅ Each connection has 1 session |\n| Admin state | Per session | Per connection (preserved) |\n| Resource cost | 1 TCP connection, N sessions | N TCP connections, N sessions |\n\n## Component Interactions\n\n```\n┌─────────────────┐      ┌──────────────────────┐\n│PooledExecutor   │──────│ SSHConnectionPool    │\n│                 │      │                      │\n│ Run(cmd)        │      │ Acquire() → conn     │\n│ RunBatch(cmds)  │      │ Release(conn)        │\n│ SetAdminPwd()   │      │ Discard(conn)        │\n│ SetLoginPwd()   │      │ Close()              │\n└─────────────────┘      └──────────────────────┘\n                                   │\n                                   ▼\n                         ┌──────────────────────┐\n                         │ PooledConnection     │\n                         │                      │\n                         │ client (*ssh.Client) │\n                         │ session (*working-   │\n                         │          Session)    │\n                         │ adminMode (bool)     │\n                         └──────────────────────┘\n                                   │\n                                   ▼\n                         ┌──────────────────────┐\n                         │ RTX Router           │\n                         │                      │\n                         │ Accepts N TCP conns  │\n                         │ 1 session per conn   │\n                         └──────────────────────┘\n```\n\n## Connection Lifecycle\n\n### 1. Connection Creation\n\n```go\nfunc (p *SSHConnectionPool) createConnection() (*PooledConnection, error) {\n    // Step 1: Establish new TCP connection + SSH handshake\n    client, err := ssh.Dial(\"tcp\", p.address, p.sshConfig)\n    if err != nil {\n        return nil, err\n    }\n\n    // Step 2: Create working session on the new connection\n    session, err := newWorkingSession(client)\n    if err != nil {\n        client.Close()\n        return nil, err\n    }\n\n    // Step 3: Wrap in PooledConnection\n    return &PooledConnection{\n        client:    client,\n        session:   session,\n        adminMode: false,\n        poolID:    fmt.Sprintf(\"conn-%d\", p.totalCreated),\n        lastUsed:  time.Now(),\n        useCount:  1,\n    }, nil\n}\n```\n\n### 2. Acquire Connection\n\n```go\nfunc (p *SSHConnectionPool) Acquire(ctx context.Context) (*PooledConnection, error) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    // Try available pool first (reuse existing connection)\n    if len(p.available) > 0 {\n        conn := p.available[len(p.available)-1]\n        p.available = p.available[:len(p.available)-1]\n        p.inUse[conn] = true\n        conn.lastUsed = time.Now()\n        conn.useCount++\n        return conn, nil\n    }\n\n    // Create new if under limit\n    if len(p.inUse) < p.config.MaxSessions {\n        conn, err := p.createConnection()\n        if err != nil {\n            return nil, err\n        }\n        p.inUse[conn] = true\n        return conn, nil\n    }\n\n    // Wait for available connection (with timeout)\n    // ...\n}\n```\n\n### 3. Release Connection\n\n```go\nfunc (p *SSHConnectionPool) Release(conn *PooledConnection) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    delete(p.inUse, conn)\n\n    // Return to available pool (session stays open, adminMode preserved)\n    conn.lastUsed = time.Now()\n    p.available = append(p.available, conn)\n    p.cond.Signal()\n}\n```\n\n### 4. Discard Connection\n\n```go\nfunc (p *SSHConnectionPool) Discard(conn *PooledConnection) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    delete(p.inUse, conn)\n\n    // Close session and connection - do not return to pool\n    if conn.session != nil {\n        conn.session.Close()\n    }\n    if conn.client != nil {\n        conn.client.Close()\n    }\n}\n```\n\n### 5. Close Pool\n\n```go\nfunc (p *SSHConnectionPool) Close() error {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    p.closed = true\n\n    // Close all available connections\n    for _, conn := range p.available {\n        conn.session.Close()\n        conn.client.Close()\n    }\n    p.available = nil\n\n    // In-use connections closed on release\n    p.cond.Broadcast()\n    return nil\n}\n```\n\n## Admin State Preservation\n\nSince the `workingSession` stays open across acquisitions, admin authentication state is naturally preserved:\n\n```go\n// PooledExecutor.prepareSession (unchanged)\nfunc (e *PooledExecutor) prepareSession(ctx context.Context, conn *PooledConnection, needsAdmin bool) error {\n    if !needsAdmin {\n        return nil\n    }\n\n    // Check if already authenticated (persists across acquisitions)\n    if conn.adminMode {\n        return nil  // Reuse admin state\n    }\n\n    // Authenticate on the persistent session\n    if err := e.authenticateAsAdmin(ctx, conn); err != nil {\n        return err\n    }\n\n    conn.adminMode = true  // Preserved for future acquisitions\n    return nil\n}\n```\n\n## Migration Strategy\n\n### Phase 1: Rename and Restructure\n\n1. Rename `SSHSessionPool` → `SSHConnectionPool`\n2. Rename `PooledSSHSession` → `PooledConnection`\n3. Add `client *ssh.Client` field to `PooledConnection`\n4. Add `sshConfig` and `address` fields to pool\n\n### Phase 2: Update Connection Creation\n\n1. Remove single `sshClient` field from pool\n2. Update `createConnection()` to dial new connection\n3. Each connection gets its own `ssh.Client`\n\n### Phase 3: Update PooledExecutor\n\n1. Update type references: `*PooledSSHSession` → `*PooledConnection`\n2. Access session via `conn.session` instead of embedding\n3. Access adminMode via `conn.adminMode`\n\n### Phase 4: Update Tests\n\n1. Update mock factory to create full connections\n2. Update test assertions for new structure\n3. Add integration tests verifying multiple connections\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| `internal/client/ssh_session_pool.go` | Major rewrite: rename types, add connection factory |\n| `internal/client/pooled_executor.go` | Update type references, access patterns |\n| `internal/client/pooled_executor_test.go` | Update mocks and assertions |\n| `internal/client/ssh_session_pool_test.go` | Update for new connection model |\n| `internal/client/client.go` | Pass sshConfig and address to pool constructor |\n\n## Interface Compatibility\n\nThe `Executor` interface remains unchanged:\n\n```go\ntype Executor interface {\n    Run(ctx context.Context, cmd string) ([]byte, error)\n    RunBatch(ctx context.Context, cmds []string) ([]byte, error)\n    SetAdministratorPassword(ctx context.Context, oldPassword, newPassword string) error\n    SetLoginPassword(ctx context.Context, newPassword string) error\n}\n```\n\n`PooledExecutor` signature changes:\n- Constructor: `NewPooledExecutor(pool *SSHConnectionPool, ...)` (type change)\n- Internal methods: Use `*PooledConnection` instead of `*PooledSSHSession`\n\n## Configuration\n\nNo changes to `SSHPoolConfig`:\n\n```go\ntype SSHPoolConfig struct {\n    MaxSessions    int           // Max concurrent connections (renamed semantically)\n    IdleTimeout    time.Duration // Close idle connections after this time\n    AcquireTimeout time.Duration // Max wait time for connection acquisition\n}\n```\n\n## Error Handling\n\n### Connection Failure Scenarios\n\n| Scenario | Handling |\n|----------|----------|\n| `ssh.Dial` fails | Return error, don't add to pool |\n| `newWorkingSession` fails | Close client, return error |\n| Command fails | Discard connection, retry with new |\n| Connection lost | Detected on next use, discarded |\n| Idle timeout | Close connection, remove from available |\n\n## Performance Considerations\n\n### Tradeoffs\n\n| Aspect | Impact |\n|--------|--------|\n| Connection establishment | Higher latency per new connection (~100-200ms) |\n| Connection reuse | Eliminates repeated SSH handshakes |\n| Memory per connection | Higher (each has own TCP buffer, SSH state) |\n| RTX connection limit | Uses N connections instead of 1 |\n\n### RTX Connection Limits\n\nRTX routers typically allow 4-8 concurrent SSH connections. With `MaxSessions: 2` (default), this leaves room for other SSH users/tools while still enabling parallelism.\n\n### Recommended Defaults\n\n```go\nDefaultSSHPoolConfig() SSHPoolConfig {\n    return SSHPoolConfig{\n        MaxSessions:    2,              // 2 concurrent connections\n        IdleTimeout:    5 * time.Minute,\n        AcquireTimeout: 30 * time.Second,\n    }\n}\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **Connection creation**: Mock `ssh.Dial`, verify connection wrapping\n2. **Acquire/Release**: Verify pool state transitions\n3. **Discard**: Verify connection cleanup\n4. **Concurrent access**: Verify mutex safety\n5. **Admin state preservation**: Verify state persists across acquisitions\n\n### Integration Tests\n\n1. **Real RTX connection**: Verify multiple connections work\n2. **Connection reuse**: Verify same connection serves multiple commands\n3. **Parallel commands**: Verify concurrent execution uses different connections\n",
  "fileStats": {
    "size": 13764,
    "lines": 412,
    "lastModified": "2026-01-25T12:10:50.031Z"
  },
  "comments": []
}