{
  "id": "snapshot_1769438710157_wf9v5mgw2",
  "approvalId": "approval_1769438689905_ayvwtjiac",
  "approvalTitle": "SSHD Public Key Auth Design - Host Key Existing Server Handling",
  "version": 2,
  "timestamp": "2026-01-26T14:45:10.156Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: SSHD Public Key Authentication\n\n## Overview\n\nThis feature adds comprehensive SSH public key authentication support for Yamaha RTX routers at two levels:\n\n1. **Provider Level**: Enable the Terraform provider to authenticate to RTX routers using SSH keys\n2. **Resource Level**: Manage SSH public key settings on RTX routers (host keys, authorized keys, auth methods)\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- Uses existing `golang.org/x/crypto/ssh` library for public key authentication\n- Follows the parser registry pattern for new SSHD parsers\n- Maintains stateless communication model (each operation uses pooled SSH connections)\n- Uses Zerolog for all logging\n\n### Project Structure (structure.md)\n\n- New files follow naming conventions: `resource_rtx_<feature>.go`, `<feature>_service.go`\n- Extends existing `ServiceManager` for SSHD operations\n- Adds parser methods to existing `parsers/service.go`\n- Provider schema extensions in `provider.go`\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **`ssh_dialer.go`**: Extend to support public key authentication methods\n- **`ServiceManager`**: Extend with host key and authorized keys methods\n- **`resource_rtx_sshd.go`**: Extend schema with `auth_method` attribute\n- **`parsers/service.go`**: Extend with host key and authorized keys parsers\n- **`SSHDConfig` struct**: Extend with `AuthMethod` field\n\n### Integration Points\n\n- **Provider Configuration**: Add `private_key`, `private_key_file`, `private_key_passphrase` to provider schema\n- **Config struct**: Add corresponding fields for SSH key authentication\n- **SSH Connection**: Modify `sshDialer.Dial()` to use public key auth when configured\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Provider Authentication\"\n        P[provider.go] --> C[Config struct]\n        C --> D[ssh_dialer.go]\n        D --> |\"ssh.PublicKeys()\"| R[RTX Router]\n    end\n\n    subgraph \"Resource: rtx_sshd\"\n        S1[resource_rtx_sshd.go] --> SM[ServiceManager]\n        SM --> |\"sshd auth method\"| R\n    end\n\n    subgraph \"Resource: rtx_sshd_host_key\"\n        S2[resource_rtx_sshd_host_key.go] --> SM\n        SM --> |\"sshd host key generate\"| R\n    end\n\n    subgraph \"Resource: rtx_sshd_authorized_keys\"\n        S3[resource_rtx_sshd_authorized_keys.go] --> SM\n        SM --> |\"import sshd authorized-keys\"| R\n    end\n\n    subgraph \"Parsers\"\n        SM --> SP[parsers/service.go]\n        SP --> |\"ParseSSHDHostKey()\"| SM\n        SP --> |\"ParseSSHDAuthorizedKeys()\"| SM\n    end\n```\n\n## Components and Interfaces\n\n### Component 1: Provider SSH Key Authentication\n\n**Purpose:** Enable Terraform provider to connect to RTX routers using SSH public key authentication\n\n**Files to Modify:**\n- `internal/provider/provider.go` - Add schema attributes\n- `internal/client/interfaces.go` - Extend Config struct\n- `internal/client/ssh_dialer.go` - Add public key auth methods\n\n**Config Struct Extension:**\n```go\ntype Config struct {\n    // ... existing fields ...\n\n    // SSH Public Key Authentication\n    PrivateKey           string // PEM-encoded private key content\n    PrivateKeyFile       string // Path to private key file\n    PrivateKeyPassphrase string // Passphrase for encrypted private key\n}\n```\n\n**ssh_dialer.go Changes:**\n```go\nfunc (d *sshDialer) Dial(ctx context.Context, host string, config *Config) (Session, error) {\n    authMethods := d.buildAuthMethods(config)\n\n    sshConfig := &ssh.ClientConfig{\n        User:            config.Username,\n        Auth:            authMethods,\n        HostKeyCallback: hostKeyCallback,\n        Timeout:         time.Duration(config.Timeout) * time.Second,\n    }\n    // ... rest of dial logic\n}\n\nfunc (d *sshDialer) buildAuthMethods(config *Config) []ssh.AuthMethod {\n    var methods []ssh.AuthMethod\n\n    // 1. Try SSH agent first (if no explicit key provided)\n    if config.PrivateKey == \"\" && config.PrivateKeyFile == \"\" {\n        if agentAuth := d.trySSHAgent(); agentAuth != nil {\n            methods = append(methods, agentAuth)\n        }\n    }\n\n    // 2. Try explicit private key\n    if signer := d.loadPrivateKey(config); signer != nil {\n        methods = append(methods, ssh.PublicKeys(signer))\n    }\n\n    // 3. Fallback to password\n    if config.Password != \"\" {\n        methods = append(methods, ssh.Password(config.Password))\n        methods = append(methods, ssh.KeyboardInteractive(...))\n    }\n\n    return methods\n}\n\nfunc (d *sshDialer) loadPrivateKey(config *Config) ssh.Signer {\n    var keyBytes []byte\n    if config.PrivateKey != \"\" {\n        keyBytes = []byte(config.PrivateKey)\n    } else if config.PrivateKeyFile != \"\" {\n        keyBytes, _ = os.ReadFile(expandPath(config.PrivateKeyFile))\n    }\n\n    if config.PrivateKeyPassphrase != \"\" {\n        signer, _ := ssh.ParsePrivateKeyWithPassphrase(keyBytes, []byte(config.PrivateKeyPassphrase))\n        return signer\n    }\n    signer, _ := ssh.ParsePrivateKey(keyBytes)\n    return signer\n}\n\nfunc (d *sshDialer) trySSHAgent() ssh.AuthMethod {\n    socket := os.Getenv(\"SSH_AUTH_SOCK\")\n    if socket == \"\" {\n        return nil\n    }\n    conn, err := net.Dial(\"unix\", socket)\n    if err != nil {\n        return nil\n    }\n    agentClient := agent.NewClient(conn)\n    return ssh.PublicKeysCallback(agentClient.Signers)\n}\n```\n\n**Provider Schema Addition:**\n```go\n\"private_key\": {\n    Type:        schema.TypeString,\n    Optional:    true,\n    Sensitive:   true,\n    DefaultFunc: schema.EnvDefaultFunc(\"RTX_PRIVATE_KEY\", nil),\n    Description: \"SSH private key content (PEM format). Can be set with RTX_PRIVATE_KEY environment variable.\",\n},\n\"private_key_file\": {\n    Type:          schema.TypeString,\n    Optional:      true,\n    ConflictsWith: []string{\"private_key\"},\n    DefaultFunc:   schema.EnvDefaultFunc(\"RTX_PRIVATE_KEY_FILE\", nil),\n    Description:   \"Path to SSH private key file. Can be set with RTX_PRIVATE_KEY_FILE environment variable.\",\n},\n\"private_key_passphrase\": {\n    Type:        schema.TypeString,\n    Optional:    true,\n    Sensitive:   true,\n    DefaultFunc: schema.EnvDefaultFunc(\"RTX_PRIVATE_KEY_PASSPHRASE\", nil),\n    Description: \"Passphrase for encrypted private key. Can be set with RTX_PRIVATE_KEY_PASSPHRASE environment variable.\",\n},\n```\n\n### Component 2: rtx_sshd Auth Method Extension\n\n**Purpose:** Add `auth_method` attribute to existing rtx_sshd resource\n\n**Files to Modify:**\n- `internal/provider/resource_rtx_sshd.go` - Add schema attribute\n- `internal/client/interfaces.go` - Extend SSHDConfig struct\n- `internal/client/service_manager.go` - Add auth method commands\n- `internal/rtx/parsers/service.go` - Parse auth method from config\n\n**SSHDConfig Extension:**\n```go\ntype SSHDConfig struct {\n    Enabled    bool\n    Hosts      []string\n    HostKey    string\n    AuthMethod string // \"password\", \"publickey\", \"any\" (default)\n}\n```\n\n**RTX Commands:**\n```\nsshd auth method password   # Password only\nsshd auth method publickey  # Public key only\nno sshd auth method         # Both (default)\n```\n\n### Component 3: rtx_sshd_host_key Resource\n\n**Purpose:** Manage SSH host key generation on RTX routers\n\n**Files to Create:**\n- `internal/provider/resource_rtx_sshd_host_key.go`\n\n**Terraform Schema:**\n```go\nfunc resourceRTXSSHDHostKey() *schema.Resource {\n    return &schema.Resource{\n        Schema: map[string]*schema.Schema{\n            \"fingerprint\": {\n                Type:        schema.TypeString,\n                Computed:    true,\n                Description: \"SSH host key fingerprint (SHA256)\",\n            },\n            \"algorithm\": {\n                Type:        schema.TypeString,\n                Computed:    true,\n                Description: \"Host key algorithm (e.g., ssh-rsa)\",\n            },\n        },\n    }\n}\n```\n\n**Behavior:**\n- **Create**: Check if host key exists first; only generate if none exists\n- **Read**: Parse `show status sshd` for fingerprint\n- **Update**: No-op (host key attributes are all Computed)\n- **Delete**: No-op (host keys persist for security)\n- **Import**: Read existing host key info\n\n**RTX Commands:**\n```\nsshd host key generate      # Generate host key\nshow status sshd            # Show host key fingerprint\n```\n\n**Existing Server Handling (First Apply):**\n\nWhen `terraform apply` is run on an RTX router that already has a host key configured:\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│ First terraform apply on existing RTX server                    │\n├─────────────────────────────────────────────────────────────────┤\n│ 1. Create is called                                             │\n│ 2. Check: Does host key exist? (show status sshd)               │\n│    ├─ YES: Do NOT regenerate. Read existing key info.           │\n│    │       Set fingerprint/algorithm in state.                  │\n│    │       Return success (idempotent).                         │\n│    └─ NO:  Execute \"sshd host key generate\"                     │\n│            Read new key info. Set in state.                     │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**Implementation Logic:**\n```go\nfunc resourceRTXSSHDHostKeyCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {\n    client := meta.(*apiClient)\n\n    // Check if host key already exists\n    hostKeyInfo, err := client.client.GetSSHDHostKey(ctx)\n    if err != nil {\n        return diag.Errorf(\"Failed to check host key status: %v\", err)\n    }\n\n    if hostKeyInfo.Fingerprint == \"\" {\n        // No existing key - generate new one\n        if err := client.client.GenerateSSHDHostKey(ctx); err != nil {\n            return diag.Errorf(\"Failed to generate host key: %v\", err)\n        }\n        // Re-read to get the new key info\n        hostKeyInfo, err = client.client.GetSSHDHostKey(ctx)\n        if err != nil {\n            return diag.Errorf(\"Failed to read generated host key: %v\", err)\n        }\n    }\n    // else: Key already exists - just adopt it into state\n\n    d.SetId(\"sshd_host_key\")\n    d.Set(\"fingerprint\", hostKeyInfo.Fingerprint)\n    d.Set(\"algorithm\", hostKeyInfo.Algorithm)\n\n    return nil\n}\n```\n\n**Why This Design:**\n- Prevents accidental host key regeneration on existing servers\n- Allows Terraform to \"adopt\" existing infrastructure\n- Maintains SSH client trust (known_hosts won't break)\n- Idempotent: running apply multiple times has no side effects\n\n### Component 4: rtx_sshd_authorized_keys Resource\n\n**Purpose:** Manage SSH authorized keys for RTX router users\n\n**Files to Create:**\n- `internal/provider/resource_rtx_sshd_authorized_keys.go`\n\n**Terraform Schema:**\n```go\nfunc resourceRTXSSHDAuthorizedKeys() *schema.Resource {\n    return &schema.Resource{\n        Schema: map[string]*schema.Schema{\n            \"username\": {\n                Type:        schema.TypeString,\n                Required:    true,\n                ForceNew:    true,\n                Description: \"Username to manage authorized keys for\",\n            },\n            \"keys\": {\n                Type:     schema.TypeList,\n                Required: true,\n                Elem: &schema.Schema{\n                    Type: schema.TypeString,\n                },\n                Description: \"List of SSH public keys in OpenSSH format\",\n            },\n        },\n    }\n}\n```\n\n**Behavior:**\n- **Create**: Register all keys via `import sshd authorized-keys`\n- **Read**: Parse `show sshd authorized-keys <user>` for key list\n- **Update**: Delete all keys, then re-register desired keys (RTX limitation)\n- **Delete**: Execute `delete /ssh/authorized_keys/<user>`\n\n**Service Methods:**\n```go\n// GetSSHDAuthorizedKeys retrieves authorized keys for a user\nfunc (s *ServiceManager) GetSSHDAuthorizedKeys(ctx context.Context, username string) ([]SSHAuthorizedKey, error)\n\n// SetSSHDAuthorizedKeys sets all authorized keys for a user (replaces existing)\nfunc (s *ServiceManager) SetSSHDAuthorizedKeys(ctx context.Context, username string, keys []string) error\n\n// DeleteSSHDAuthorizedKeys removes all authorized keys for a user\nfunc (s *ServiceManager) DeleteSSHDAuthorizedKeys(ctx context.Context, username string) error\n```\n\n**RTX Commands:**\n```\nimport sshd authorized-keys <user>    # Interactive key input\nshow sshd authorized-keys <user>      # List keys (fingerprints)\ndelete /ssh/authorized_keys/<user>    # Delete all keys\n```\n\n**Key Import Challenge:**\nThe `import sshd authorized-keys` command is interactive. Implementation options:\n1. Use `executor.Run()` with key content piped as input\n2. Send key followed by newline and detect prompt return\n\n## Data Models\n\n### SSHAuthorizedKey\n```go\ntype SSHAuthorizedKey struct {\n    Type        string // e.g., \"ssh-ed25519\", \"ssh-rsa\"\n    Fingerprint string // SHA256 fingerprint\n    Comment     string // Key comment (e.g., \"user@host\")\n}\n```\n\n### SSHHostKeyInfo\n```go\ntype SSHHostKeyInfo struct {\n    Fingerprint string // SHA256 fingerprint\n    Algorithm   string // Key algorithm\n    Generated   bool   // Whether key exists\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Private key file not found**\n   - **Handling:** Return clear error with file path\n   - **User Impact:** Terraform plan/apply fails with actionable message\n\n2. **Invalid private key format**\n   - **Handling:** Return error indicating PEM format expected\n   - **User Impact:** User corrects key format\n\n3. **Passphrase required but not provided**\n   - **Handling:** Return error indicating encrypted key needs passphrase\n   - **User Impact:** User provides passphrase\n\n4. **SSH agent not available**\n   - **Handling:** Fall back to password auth silently if available\n   - **User Impact:** None if password is configured\n\n5. **Host key already exists (for rtx_sshd_host_key)**\n   - **Handling:** Read existing key, don't regenerate\n   - **User Impact:** Idempotent behavior\n\n6. **Invalid public key format (for authorized_keys)**\n   - **Handling:** Return validation error before sending to router\n   - **User Impact:** Clear error message about key format\n\n7. **User not found (for authorized_keys)**\n   - **Handling:** Return error from RTX command\n   - **User Impact:** User must create login user first\n\n## Testing Strategy\n\n### Unit Testing\n\n**Provider Authentication:**\n- Test `loadPrivateKey()` with various key formats (RSA, ED25519, encrypted)\n- Test `trySSHAgent()` with mocked agent socket\n- Test `buildAuthMethods()` priority order\n\n**Resource Logic:**\n- Test `rtx_sshd_authorized_keys` key list diffing\n- Test `rtx_sshd_host_key` idempotent behavior\n\n### Integration Testing\n\n**Provider Authentication:**\n- Test SSH connection with key file\n- Test SSH connection with key content\n- Test SSH connection with SSH agent\n- Test fallback to password when key auth fails\n\n**Resources:**\n- Test `rtx_sshd` with `auth_method` changes\n- Test `rtx_sshd_host_key` create/import cycle\n- Test `rtx_sshd_authorized_keys` full CRUD cycle\n- Test key removal triggers full re-registration\n\n### Acceptance Testing\n\n- End-to-end test with real RTX router\n- Test provider authentication with public key\n- Test resource management of authorized keys\n",
  "fileStats": {
    "size": 15468,
    "lines": 458,
    "lastModified": "2026-01-26T14:44:40.296Z"
  },
  "comments": []
}