// Code generated by specgen. DO NOT EDIT.
// Source: specs/l2tp/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestL2TPRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestL2TPRoundTrip_Parse(t *testing.T) {
	parser := NewL2TPParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, configs []L2TPConfig)
	}{
		{
			name: "l2tpv3_basic",
			rtx: `tunnel select 1
tunnel encapsulation l2tpv3
l2tp local router-id 192.168.1.1
l2tp remote router-id 192.168.2.1
tunnel enable 1`,
			checkFunc: func(t *testing.T, configs []L2TPConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				c := configs[0]
				if c.Version != "l2tpv3" {
					t.Errorf("Version = %v, want l2tpv3", c.Version)
				}
				if c.L2TPv3Config == nil {
					t.Errorf("L2TPv3Config should not be nil")
					return
				}
				if c.L2TPv3Config.LocalRouterID != "192.168.1.1" {
					t.Errorf("LocalRouterID = %v, want 192.168.1.1", c.L2TPv3Config.LocalRouterID)
				}
				if c.L2TPv3Config.RemoteRouterID != "192.168.2.1" {
					t.Errorf("RemoteRouterID = %v, want 192.168.2.1", c.L2TPv3Config.RemoteRouterID)
				}
			},
		},
		{
			name: "l2tpv3_with_keepalive",
			rtx: `tunnel select 2
tunnel encapsulation l2tpv3
l2tp local router-id 10.0.0.1
l2tp remote router-id 10.0.0.2
l2tp keepalive use on 30 5
tunnel enable 2`,
			checkFunc: func(t *testing.T, configs []L2TPConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				c := configs[0]
				if !c.KeepaliveEnabled {
					t.Errorf("KeepaliveEnabled = %v, want true", c.KeepaliveEnabled)
				}
				if c.KeepaliveConfig == nil {
					t.Errorf("KeepaliveConfig should not be nil")
					return
				}
				if c.KeepaliveConfig.Interval != 30 {
					t.Errorf("Keepalive Interval = %v, want 30", c.KeepaliveConfig.Interval)
				}
				if c.KeepaliveConfig.Retry != 5 {
					t.Errorf("Keepalive Retry = %v, want 5", c.KeepaliveConfig.Retry)
				}
			},
		},
		{
			name: "l2tpv3_always_on",
			rtx: `tunnel select 3
tunnel encapsulation l2tpv3
l2tp local router-id 172.16.0.1
l2tp remote router-id 172.16.0.2
l2tp always-on on
tunnel enable 3`,
			checkFunc: func(t *testing.T, configs []L2TPConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				if !configs[0].AlwaysOn {
					t.Errorf("AlwaysOn = %v, want true", configs[0].AlwaysOn)
				}
			},
		},
		{
			name: "l2tpv3_remote_end_id",
			rtx: `tunnel select 4
tunnel encapsulation l2tpv3
l2tp local router-id 192.168.10.1
l2tp remote router-id 192.168.10.2
l2tp remote end-id remote-host
tunnel enable 4`,
			checkFunc: func(t *testing.T, configs []L2TPConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				c := configs[0]
				if c.L2TPv3Config == nil || c.L2TPv3Config.RemoteEndID != "remote-host" {
					t.Errorf("RemoteEndID = %v, want remote-host", c.L2TPv3Config.RemoteEndID)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			configs, err := parser.ParseL2TPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseL2TPConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, configs)
		})
	}
}

// TestL2TPRoundTrip_Build tests Terraform value -> RTX command conversion
func TestL2TPRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "l2tp_service_on",
			buildFunc: func() string {
				return BuildL2TPServiceCommand(true)
			},
			expectedRTX: "l2tp service on",
		},
		{
			name: "l2tp_service_off",
			buildFunc: func() string {
				return BuildL2TPServiceCommand(false)
			},
			expectedRTX: "l2tp service off",
		},
		{
			name: "tunnel_encapsulation_l2tpv3",
			buildFunc: func() string {
				return BuildTunnelEncapsulationCommand(1, "l2tpv3")
			},
			expectedRTX: "tunnel encapsulation l2tpv3",
		},
		{
			name: "tunnel_endpoint",
			buildFunc: func() string {
				return BuildTunnelEndpointCommand("192.168.1.1", "192.168.2.1")
			},
			expectedRTX: "tunnel endpoint address 192.168.1.1 192.168.2.1",
		},
		{
			name: "l2tp_local_router_id",
			buildFunc: func() string {
				return BuildL2TPLocalRouterIDCommand("10.0.0.1")
			},
			expectedRTX: "l2tp local router-id 10.0.0.1",
		},
		{
			name: "l2tp_remote_router_id",
			buildFunc: func() string {
				return BuildL2TPRemoteRouterIDCommand("10.0.0.2")
			},
			expectedRTX: "l2tp remote router-id 10.0.0.2",
		},
		{
			name: "l2tp_remote_end_id",
			buildFunc: func() string {
				return BuildL2TPRemoteEndIDCommand("remote-host")
			},
			expectedRTX: "l2tp remote end-id remote-host",
		},
		{
			name: "l2tp_always_on_on",
			buildFunc: func() string {
				return BuildL2TPAlwaysOnCommand(true)
			},
			expectedRTX: "l2tp always-on on",
		},
		{
			name: "l2tp_always_on_off",
			buildFunc: func() string {
				return BuildL2TPAlwaysOnCommand(false)
			},
			expectedRTX: "l2tp always-on off",
		},
		{
			name: "l2tp_keepalive",
			buildFunc: func() string {
				return BuildL2TPKeepaliveCommand(30, 5)
			},
			expectedRTX: "l2tp keepalive use on 30 5",
		},
		{
			name: "l2tp_keepalive_off",
			buildFunc: func() string {
				return BuildL2TPKeepaliveOffCommand()
			},
			expectedRTX: "l2tp keepalive use off",
		},
		{
			name: "l2tp_disconnect_time",
			buildFunc: func() string {
				return BuildL2TPDisconnectTimeCommand(300)
			},
			expectedRTX: "l2tp tunnel disconnect time 300",
		},
		{
			name: "l2tp_disconnect_time_off",
			buildFunc: func() string {
				return BuildL2TPDisconnectTimeCommand(0)
			},
			expectedRTX: "l2tp tunnel disconnect time off",
		},
		{
			name: "delete_l2tp_tunnel",
			buildFunc: func() string {
				return BuildDeleteL2TPTunnelCommand(1)
			},
			expectedRTX: "no tunnel select 1",
		},
		{
			name: "pp_select_anonymous",
			buildFunc: func() string {
				return BuildPPSelectAnonymousCommand()
			},
			expectedRTX: "pp select anonymous",
		},
		{
			name: "pp_bind_tunnel",
			buildFunc: func() string {
				return BuildPPBindTunnelCommand(1)
			},
			expectedRTX: "pp bind tunnel1",
		},
		{
			name: "pp_auth_accept",
			buildFunc: func() string {
				return BuildPPAuthAcceptCommand("chap")
			},
			expectedRTX: "pp auth accept chap",
		},
		{
			name: "pp_auth_myname",
			buildFunc: func() string {
				return BuildPPAuthMynameCommand("user", "pass")
			},
			expectedRTX: "pp auth myname user pass",
		},
		{
			name: "ip_pp_remote_pool",
			buildFunc: func() string {
				return BuildIPPPRemotePoolCommand("192.168.100.10", "192.168.100.20")
			},
			expectedRTX: "ip pp remote address pool 192.168.100.10-192.168.100.20",
		},
		{
			name: "l2tp_service_with_protocols",
			buildFunc: func() string {
				return BuildL2TPServiceCommandWithProtocols(true, []string{"l2tpv3", "l2tp"})
			},
			expectedRTX: "l2tp service on l2tpv3 l2tp",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestL2TPRoundTrip_ParseBuildParse tests full round-trip
func TestL2TPRoundTrip_ParseBuildParse(t *testing.T) {
	testCases := []struct {
		name               string
		localRouterID      string
		remoteRouterID     string
		keepaliveInterval  int
		keepaliveRetry     int
	}{
		{
			name:           "basic_l2tpv3",
			localRouterID:  "192.168.1.1",
			remoteRouterID: "192.168.1.2",
		},
		{
			name:              "l2tpv3_with_keepalive",
			localRouterID:    "10.0.0.1",
			remoteRouterID:   "10.0.0.2",
			keepaliveInterval: 30,
			keepaliveRetry:    5,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Build commands
			localCmd := BuildL2TPLocalRouterIDCommand(tc.localRouterID)
			remoteCmd := BuildL2TPRemoteRouterIDCommand(tc.remoteRouterID)

			// Step 2: Verify command format
			expectedLocal := "l2tp local router-id " + tc.localRouterID
			expectedRemote := "l2tp remote router-id " + tc.remoteRouterID

			if localCmd != expectedLocal {
				t.Errorf("LocalRouterID command = %q, want %q", localCmd, expectedLocal)
			}
			if remoteCmd != expectedRemote {
				t.Errorf("RemoteRouterID command = %q, want %q", remoteCmd, expectedRemote)
			}

			// Step 3: Test keepalive if specified
			if tc.keepaliveInterval > 0 {
				keepaliveCmd := BuildL2TPKeepaliveCommand(tc.keepaliveInterval, tc.keepaliveRetry)
				expectedKeepalive := "l2tp keepalive use on 30 5"
				if keepaliveCmd != expectedKeepalive {
					t.Errorf("Keepalive command = %q, want %q", keepaliveCmd, expectedKeepalive)
				}
			}
		})
	}
}

// TestL2TPServiceRoundTrip tests L2TP service configuration round-trip
func TestL2TPServiceRoundTrip(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		enabled   bool
		protocols []string
	}{
		{
			name:    "service_on",
			rtx:     "l2tp service on",
			enabled: true,
		},
		{
			name:    "service_off",
			rtx:     "l2tp service off",
			enabled: false,
		},
		{
			name:      "service_on_with_protocols",
			rtx:       "l2tp service on l2tpv3 l2tp",
			enabled:   true,
			protocols: []string{"l2tpv3", "l2tp"},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Parse
			service, err := ParseL2TPServiceConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseL2TPServiceConfig error: %v", err)
			}

			// Verify parsed values
			if service.Enabled != tc.enabled {
				t.Errorf("Enabled = %v, want %v", service.Enabled, tc.enabled)
			}

			// Build back
			rebuilt := BuildL2TPServiceCommandWithProtocols(service.Enabled, service.Protocols)

			// For simple on/off without protocols, the rebuild might differ
			// so just verify enabled state matches
			rebuiltService, err := ParseL2TPServiceConfig(rebuilt)
			if err != nil {
				t.Fatalf("ParseL2TPServiceConfig error on rebuilt: %v", err)
			}
			if rebuiltService.Enabled != tc.enabled {
				t.Errorf("Rebuilt Enabled = %v, want %v", rebuiltService.Enabled, tc.enabled)
			}
		})
	}
}
