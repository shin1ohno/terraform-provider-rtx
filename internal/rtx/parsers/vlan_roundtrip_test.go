// Code generated by specgen. DO NOT EDIT.
// Source: specs/vlan/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"strconv"
	"strings"
	"testing"
)

// TestVLANRoundTrip_Parse tests RTX command -> Terraform value conversion
// using the actual VLANParser
func TestVLANRoundTrip_Parse(t *testing.T) {
	parser := NewVLANParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, vlans []VLAN)
	}{
		{
			name: "vlan_basic",
			rtx:  "vlan lan1/1 802.1q vid=10",
			checkFunc: func(t *testing.T, vlans []VLAN) {
				// Expected terraform: vlan_id: 10, interface: "lan1"
				if len(vlans) != 1 {
					t.Errorf("VLAN count = %v, want 1", len(vlans))
					return
				}
				v := vlans[0]
				if v.VlanID != 10 {
					t.Errorf("VlanID = %v, want 10", v.VlanID)
				}
				if v.Interface != "lan1" {
					t.Errorf("Interface = %v, want lan1", v.Interface)
				}
				if v.VlanInterface != "lan1/1" {
					t.Errorf("VlanInterface = %v, want lan1/1", v.VlanInterface)
				}
			},
		},
		{
			name: "vlan_with_ip_cidr",
			rtx: `vlan lan1/1 802.1q vid=10
ip lan1/1 address 192.168.10.1/24`,
			checkFunc: func(t *testing.T, vlans []VLAN) {
				// Expected terraform: vlan_id: 10, ip_address: "192.168.10.1", ip_mask: "255.255.255.0"
				if len(vlans) != 1 {
					t.Errorf("VLAN count = %v, want 1", len(vlans))
					return
				}
				v := vlans[0]
				if v.IPAddress != "192.168.10.1" {
					t.Errorf("IPAddress = %v, want 192.168.10.1", v.IPAddress)
				}
				if v.IPMask != "255.255.255.0" {
					t.Errorf("IPMask = %v, want 255.255.255.0", v.IPMask)
				}
			},
		},
		{
			name: "vlan_with_description",
			rtx: `vlan lan1/1 802.1q vid=10
description lan1/1 Management VLAN`,
			checkFunc: func(t *testing.T, vlans []VLAN) {
				// Expected terraform: name: "Management VLAN"
				if len(vlans) != 1 {
					t.Errorf("VLAN count = %v, want 1", len(vlans))
					return
				}
				if vlans[0].Name != "Management VLAN" {
					t.Errorf("Name = %v, want 'Management VLAN'", vlans[0].Name)
				}
			},
		},
		{
			name: "vlan_shutdown",
			rtx: `vlan lan1/1 802.1q vid=10
no lan1/1 enable`,
			checkFunc: func(t *testing.T, vlans []VLAN) {
				// Expected terraform: shutdown: true
				if len(vlans) != 1 {
					t.Errorf("VLAN count = %v, want 1", len(vlans))
					return
				}
				if vlans[0].Shutdown != true {
					t.Errorf("Shutdown = %v, want true", vlans[0].Shutdown)
				}
			},
		},
		{
			name: "vlan_enabled",
			rtx: `vlan lan1/1 802.1q vid=10
lan1/1 enable`,
			checkFunc: func(t *testing.T, vlans []VLAN) {
				// Expected terraform: shutdown: false
				if len(vlans) != 1 {
					t.Errorf("VLAN count = %v, want 1", len(vlans))
					return
				}
				if vlans[0].Shutdown != false {
					t.Errorf("Shutdown = %v, want false", vlans[0].Shutdown)
				}
			},
		},
		{
			name: "vlan_on_lan2",
			rtx:  "vlan lan2/1 802.1q vid=20",
			checkFunc: func(t *testing.T, vlans []VLAN) {
				// Expected terraform: vlan_id: 20, interface: "lan2"
				if len(vlans) != 1 {
					t.Errorf("VLAN count = %v, want 1", len(vlans))
					return
				}
				v := vlans[0]
				if v.VlanID != 20 {
					t.Errorf("VlanID = %v, want 20", v.VlanID)
				}
				if v.Interface != "lan2" {
					t.Errorf("Interface = %v, want lan2", v.Interface)
				}
			},
		},
		{
			name: "vlan_second_slot",
			rtx:  "vlan lan1/2 802.1q vid=30",
			checkFunc: func(t *testing.T, vlans []VLAN) {
				// Expected terraform: vlan_id: 30, vlan_interface: "lan1/2"
				if len(vlans) != 1 {
					t.Errorf("VLAN count = %v, want 1", len(vlans))
					return
				}
				if vlans[0].VlanInterface != "lan1/2" {
					t.Errorf("VlanInterface = %v, want lan1/2", vlans[0].VlanInterface)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			vlans, err := parser.ParseVLANConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseVLANConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, vlans)
		})
	}
}

// TestVLANRoundTrip_Build tests Terraform value -> RTX command conversion
// using the actual Build* functions
func TestVLANRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "vlan_basic",
			buildFunc: func() string {
				return BuildVLANCommand("lan1", 1, 10)
			},
			expectedRTX: "vlan lan1/1 802.1q vid=10",
		},
		{
			name: "vlan_on_lan2",
			buildFunc: func() string {
				return BuildVLANCommand("lan2", 1, 20)
			},
			expectedRTX: "vlan lan2/1 802.1q vid=20",
		},
		{
			name: "vlan_second_slot",
			buildFunc: func() string {
				return BuildVLANCommand("lan1", 2, 30)
			},
			expectedRTX: "vlan lan1/2 802.1q vid=30",
		},
		{
			name: "vlan_ip_24bit",
			buildFunc: func() string {
				return BuildVLANIPCommand("lan1/1", "192.168.10.1", "255.255.255.0")
			},
			expectedRTX: "ip lan1/1 address 192.168.10.1/24",
		},
		{
			name: "vlan_ip_16bit",
			buildFunc: func() string {
				return BuildVLANIPCommand("lan1/1", "172.16.0.1", "255.255.0.0")
			},
			expectedRTX: "ip lan1/1 address 172.16.0.1/16",
		},
		{
			name: "vlan_description",
			buildFunc: func() string {
				return BuildVLANDescriptionCommand("lan1/1", "Management VLAN")
			},
			expectedRTX: "description lan1/1 Management VLAN",
		},
		{
			name: "vlan_enable",
			buildFunc: func() string {
				return BuildVLANEnableCommand("lan1/1")
			},
			expectedRTX: "lan1/1 enable",
		},
		{
			name: "vlan_disable",
			buildFunc: func() string {
				return BuildVLANDisableCommand("lan1/1")
			},
			expectedRTX: "no lan1/1 enable",
		},
		{
			name: "delete_vlan",
			buildFunc: func() string {
				return BuildDeleteVLANCommand("lan1/1")
			},
			expectedRTX: "no vlan lan1/1",
		},
		{
			name: "delete_vlan_ip",
			buildFunc: func() string {
				return BuildDeleteVLANIPCommand("lan1/1")
			},
			expectedRTX: "no ip lan1/1 address",
		},
		{
			name: "delete_vlan_description",
			buildFunc: func() string {
				return BuildDeleteVLANDescriptionCommand("lan1/1")
			},
			expectedRTX: "no description lan1/1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestVLANRoundTrip_ParseBuildParse tests full round-trip:
// RTX command -> Parse -> Build -> RTX command (should match original)
func TestVLANRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewVLANParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "vlan_basic",
			rtx:  "vlan lan1/1 802.1q vid=10",
		},
		{
			name: "vlan_on_lan2",
			rtx:  "vlan lan2/1 802.1q vid=20",
		},
		{
			name: "vlan_second_slot",
			rtx:  "vlan lan1/2 802.1q vid=30",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			vlans, err := parser.ParseVLANConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseVLANConfig(%q) error = %v", tc.rtx, err)
			}
			if len(vlans) != 1 {
				t.Fatalf("Expected 1 VLAN, got %d", len(vlans))
			}
			vlan := vlans[0]

			// Step 2: Extract slot number from vlan interface (e.g., "lan1/1" -> 1)
			parts := strings.Split(vlan.VlanInterface, "/")
			if len(parts) != 2 {
				t.Fatalf("Invalid vlan interface format: %s", vlan.VlanInterface)
			}
			slot, err := strconv.Atoi(parts[1])
			if err != nil {
				t.Fatalf("Failed to parse slot from %s: %v", vlan.VlanInterface, err)
			}

			// Step 3: Build back to RTX command
			rebuiltRTX := BuildVLANCommand(vlan.Interface, slot, vlan.VlanID)

			// Step 4: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}

			// Step 5: Parse the rebuilt command and verify it produces the same config
			vlans2, err := parser.ParseVLANConfig(rebuiltRTX)
			if err != nil {
				t.Fatalf("ParseVLANConfig(%q) error = %v", rebuiltRTX, err)
			}
			if len(vlans2) != 1 {
				t.Fatalf("Expected 1 VLAN, got %d", len(vlans2))
			}
			vlan2 := vlans2[0]

			// Verify key fields match
			if vlan.VlanID != vlan2.VlanID {
				t.Errorf("VlanID mismatch: %v != %v", vlan.VlanID, vlan2.VlanID)
			}
			if vlan.Interface != vlan2.Interface {
				t.Errorf("Interface mismatch: %v != %v", vlan.Interface, vlan2.Interface)
			}
			if vlan.VlanInterface != vlan2.VlanInterface {
				t.Errorf("VlanInterface mismatch: %v != %v", vlan.VlanInterface, vlan2.VlanInterface)
			}
		})
	}
}
