// Code generated by specgen. DO NOT EDIT.
// Source: specs/tunnel/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestTunnelRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestTunnelRoundTrip_Parse(t *testing.T) {
	parser := NewTunnelParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, tunnels []Tunnel)
	}{
		{
			name: "ipsec_tunnel_basic",
			rtx: `tunnel select 1
 ipsec tunnel 1
 ipsec ike local address 1 192.168.1.1
 ipsec ike remote address 1 203.0.113.1
 ipsec ike pre-shared-key 1 text secretkey
tunnel enable 1`,
			checkFunc: func(t *testing.T, tunnels []Tunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if tunnel.ID != 1 {
					t.Errorf("ID = %v, want 1", tunnel.ID)
				}
				if tunnel.IPsec == nil {
					t.Errorf("IPsec should not be nil")
					return
				}
				if tunnel.IPsec.LocalAddress != "192.168.1.1" {
					t.Errorf("LocalAddress = %v, want 192.168.1.1", tunnel.IPsec.LocalAddress)
				}
				if tunnel.IPsec.RemoteAddress != "203.0.113.1" {
					t.Errorf("RemoteAddress = %v, want 203.0.113.1", tunnel.IPsec.RemoteAddress)
				}
			},
		},
		{
			name: "l2tpv3_tunnel",
			rtx: `tunnel select 2
 tunnel encapsulation l2tpv3
 l2tp local router-id 10.0.0.1
 l2tp remote router-id 10.0.0.2
 l2tp hostname myhost
 l2tp always-on on
tunnel enable 2`,
			checkFunc: func(t *testing.T, tunnels []Tunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if tunnel.Encapsulation != "l2tpv3" {
					t.Errorf("Encapsulation = %v, want l2tpv3", tunnel.Encapsulation)
				}
				if tunnel.L2TP == nil {
					t.Errorf("L2TP should not be nil")
					return
				}
				if tunnel.L2TP.LocalRouterID != "10.0.0.1" {
					t.Errorf("LocalRouterID = %v, want 10.0.0.1", tunnel.L2TP.LocalRouterID)
				}
				if tunnel.L2TP.RemoteRouterID != "10.0.0.2" {
					t.Errorf("RemoteRouterID = %v, want 10.0.0.2", tunnel.L2TP.RemoteRouterID)
				}
				if tunnel.L2TP.Hostname != "myhost" {
					t.Errorf("Hostname = %v, want myhost", tunnel.L2TP.Hostname)
				}
				if !tunnel.L2TP.AlwaysOn {
					t.Errorf("AlwaysOn = %v, want true", tunnel.L2TP.AlwaysOn)
				}
			},
		},
		{
			name: "ipsec_with_keepalive",
			rtx: `tunnel select 3
 ipsec tunnel 3
 ipsec ike local address 3 192.168.10.1
 ipsec ike remote address 3 192.168.20.1
 ipsec ike pre-shared-key 3 text mykey
 ipsec ike keepalive use 3 on dpd 30 5
tunnel enable 3`,
			checkFunc: func(t *testing.T, tunnels []Tunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if tunnel.IPsec == nil || tunnel.IPsec.Keepalive == nil {
					t.Errorf("IPsec.Keepalive should not be nil")
					return
				}
				if !tunnel.IPsec.Keepalive.Enabled {
					t.Errorf("Keepalive.Enabled = %v, want true", tunnel.IPsec.Keepalive.Enabled)
				}
				if tunnel.IPsec.Keepalive.Mode != "dpd" {
					t.Errorf("Keepalive.Mode = %v, want dpd", tunnel.IPsec.Keepalive.Mode)
				}
				if tunnel.IPsec.Keepalive.Interval != 30 {
					t.Errorf("Keepalive.Interval = %v, want 30", tunnel.IPsec.Keepalive.Interval)
				}
			},
		},
		{
			name: "tunnel_endpoint_name",
			rtx: `tunnel select 4
 tunnel endpoint name vpn.example.com fqdn
tunnel enable 4`,
			checkFunc: func(t *testing.T, tunnels []Tunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if tunnel.EndpointName != "vpn.example.com" {
					t.Errorf("EndpointName = %v, want vpn.example.com", tunnel.EndpointName)
				}
				if tunnel.EndpointNameType != "fqdn" {
					t.Errorf("EndpointNameType = %v, want fqdn", tunnel.EndpointNameType)
				}
			},
		},
		{
			name: "l2tp_with_keepalive",
			rtx: `tunnel select 5
 tunnel encapsulation l2tpv3
 l2tp local router-id 172.16.0.1
 l2tp remote router-id 172.16.0.2
 l2tp keepalive use on 30 5
tunnel enable 5`,
			checkFunc: func(t *testing.T, tunnels []Tunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if tunnel.L2TP == nil || tunnel.L2TP.Keepalive == nil {
					t.Errorf("L2TP.Keepalive should not be nil")
					return
				}
				if !tunnel.L2TP.Keepalive.Enabled {
					t.Errorf("Keepalive.Enabled = %v, want true", tunnel.L2TP.Keepalive.Enabled)
				}
				if tunnel.L2TP.Keepalive.Interval != 30 {
					t.Errorf("Keepalive.Interval = %v, want 30", tunnel.L2TP.Keepalive.Interval)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			tunnels, err := parser.ParseTunnelConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseTunnelConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, tunnels)
		})
	}
}

// TestTunnelRoundTrip_Build tests Terraform value -> RTX command conversion
func TestTunnelRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "tunnel_select",
			buildFunc: func() string {
				return BuildTunnelSelectCommand(1)
			},
			expectedRTX: "tunnel select 1",
		},
		{
			name: "tunnel_enable",
			buildFunc: func() string {
				return BuildTunnelEnableCommand(1)
			},
			expectedRTX: "tunnel enable 1",
		},
		{
			name: "tunnel_disable",
			buildFunc: func() string {
				return BuildTunnelDisableCommand(1)
			},
			expectedRTX: "tunnel disable 1",
		},
		{
			name: "tunnel_endpoint_name",
			buildFunc: func() string {
				return BuildTunnelEndpointNameCommand("vpn.example.com", "fqdn")
			},
			expectedRTX: "tunnel endpoint name vpn.example.com fqdn",
		},
		{
			name: "tunnel_endpoint_name_no_type",
			buildFunc: func() string {
				return BuildTunnelEndpointNameCommand("192.168.1.1", "")
			},
			expectedRTX: "tunnel endpoint name 192.168.1.1",
		},
		{
			name: "ipsec_ike_nat_traversal_on",
			buildFunc: func() string {
				return BuildIPsecIKENATTraversalCommand(1, true)
			},
			expectedRTX: "ipsec ike nat-traversal 1 on",
		},
		{
			name: "ipsec_ike_nat_traversal_off",
			buildFunc: func() string {
				return BuildIPsecIKENATTraversalCommand(1, false)
			},
			expectedRTX: "ipsec ike nat-traversal 1 off",
		},
		{
			name: "ipsec_ike_remote_name",
			buildFunc: func() string {
				return BuildIPsecIKERemoteNameCommand(1, "remote.example.com", "fqdn")
			},
			expectedRTX: "ipsec ike remote name 1 remote.example.com fqdn",
		},
		{
			name: "ipsec_ike_keepalive_log_on",
			buildFunc: func() string {
				return BuildIPsecIKEKeepaliveLogCommand(1, true)
			},
			expectedRTX: "ipsec ike keepalive log 1 on",
		},
		{
			name: "ipsec_ike_log",
			buildFunc: func() string {
				return BuildIPsecIKELogCommand(1, "key-info message-info")
			},
			expectedRTX: "ipsec ike log 1 key-info message-info",
		},
		{
			name: "l2tp_hostname",
			buildFunc: func() string {
				return BuildL2TPHostnameCommand("myhost")
			},
			expectedRTX: "l2tp hostname myhost",
		},
		{
			name: "l2tp_tunnel_auth_on",
			buildFunc: func() string {
				return BuildL2TPTunnelAuthCommand("secretpass")
			},
			expectedRTX: "l2tp tunnel auth on secretpass",
		},
		{
			name: "l2tp_tunnel_auth_no_password",
			buildFunc: func() string {
				return BuildL2TPTunnelAuthCommand("")
			},
			expectedRTX: "l2tp tunnel auth on",
		},
		{
			name: "l2tp_syslog_on",
			buildFunc: func() string {
				return BuildL2TPSyslogCommand(true)
			},
			expectedRTX: "l2tp syslog on",
		},
		{
			name: "l2tp_syslog_off",
			buildFunc: func() string {
				return BuildL2TPSyslogCommand(false)
			},
			expectedRTX: "l2tp syslog off",
		},
		{
			name: "l2tp_keepalive_log_on",
			buildFunc: func() string {
				return BuildL2TPKeepaliveLogCommand(true)
			},
			expectedRTX: "l2tp keepalive log on",
		},
		{
			name: "l2tp_keepalive_log_off",
			buildFunc: func() string {
				return BuildL2TPKeepaliveLogCommand(false)
			},
			expectedRTX: "l2tp keepalive log off",
		},
		{
			name: "delete_tunnel_select",
			buildFunc: func() string {
				return BuildDeleteTunnelSelectCommand(1)
			},
			expectedRTX: "no tunnel select 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestTunnelRoundTrip_BuildCommands tests full tunnel command building
func TestTunnelRoundTrip_BuildCommands(t *testing.T) {
	testCases := []struct {
		name   string
		tunnel Tunnel
		check  func(t *testing.T, commands []string)
	}{
		{
			name: "ipsec_tunnel",
			tunnel: Tunnel{
				ID:            1,
				Encapsulation: "ipsec",
				Enabled:       true,
				IPsec: &TunnelIPsec{
					IPsecTunnelID: 1,
					LocalAddress:  "192.168.1.1",
					RemoteAddress: "203.0.113.1",
					PreSharedKey:  "secretkey",
				},
			},
			check: func(t *testing.T, commands []string) {
				if len(commands) == 0 {
					t.Errorf("Expected commands, got empty")
					return
				}
				// Check that tunnel select is first
				if commands[0] != "tunnel select 1" {
					t.Errorf("First command = %q, want 'tunnel select 1'", commands[0])
				}
				// Check tunnel enable is present
				foundEnable := false
				for _, cmd := range commands {
					if cmd == "tunnel enable 1" {
						foundEnable = true
						break
					}
				}
				if !foundEnable {
					t.Errorf("Expected 'tunnel enable 1' command")
				}
			},
		},
		{
			name: "l2tpv3_tunnel",
			tunnel: Tunnel{
				ID:            2,
				Encapsulation: "l2tpv3",
				Enabled:       true,
				L2TP: &TunnelL2TP{
					LocalRouterID:  "10.0.0.1",
					RemoteRouterID: "10.0.0.2",
					Hostname:       "myhost",
					AlwaysOn:       true,
				},
			},
			check: func(t *testing.T, commands []string) {
				if len(commands) == 0 {
					t.Errorf("Expected commands, got empty")
					return
				}
				// Check that tunnel encapsulation l2tpv3 is present
				foundEncap := false
				for _, cmd := range commands {
					if cmd == "tunnel encapsulation l2tpv3" {
						foundEncap = true
						break
					}
				}
				if !foundEncap {
					t.Errorf("Expected 'tunnel encapsulation l2tpv3' command")
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			commands := BuildTunnelCommands(tc.tunnel)
			tc.check(t, commands)
		})
	}
}

// TestTunnelRoundTrip_Delete tests delete command generation
func TestTunnelRoundTrip_Delete(t *testing.T) {
	commands := BuildDeleteTunnelCommands(1)

	if len(commands) == 0 {
		t.Errorf("Expected delete commands, got empty slice")
		return
	}

	// Verify key commands are present
	foundTunnelSelect := false
	foundNoTunnel := false

	for _, cmd := range commands {
		if cmd == "tunnel select 1" {
			foundTunnelSelect = true
		}
		if cmd == "no tunnel select 1" {
			foundNoTunnel = true
		}
	}

	if !foundTunnelSelect {
		t.Errorf("Expected 'tunnel select 1' command")
	}
	if !foundNoTunnel {
		t.Errorf("Expected 'no tunnel select 1' command")
	}
}
