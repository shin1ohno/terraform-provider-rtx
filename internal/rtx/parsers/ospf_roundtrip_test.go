// Code generated by specgen. DO NOT EDIT.
// Source: specs/ospf/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestOSPFRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestOSPFRoundTrip_Parse(t *testing.T) {
	parser := NewOSPFParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *OSPFConfig)
	}{
		{
			name: "ospf_use_on",
			rtx:  "ospf use on",
			checkFunc: func(t *testing.T, config *OSPFConfig) {
				if config.Enabled != true {
					t.Errorf("Enabled = %v, want true", config.Enabled)
				}
			},
		},
		{
			name: "ospf_use_off",
			rtx:  "ospf use off",
			checkFunc: func(t *testing.T, config *OSPFConfig) {
				if config.Enabled != false {
					t.Errorf("Enabled = %v, want false", config.Enabled)
				}
			},
		},
		{
			name: "ospf_router_id",
			rtx:  "ospf router id 10.0.0.1",
			checkFunc: func(t *testing.T, config *OSPFConfig) {
				if config.RouterID != "10.0.0.1" {
					t.Errorf("RouterID = %v, want 10.0.0.1", config.RouterID)
				}
			},
		},
		{
			name: "ospf_area_normal",
			rtx:  "ospf area 0",
			checkFunc: func(t *testing.T, config *OSPFConfig) {
				if len(config.Areas) != 1 {
					t.Errorf("Areas count = %v, want 1", len(config.Areas))
					return
				}
				if config.Areas[0].ID != "0" {
					t.Errorf("Areas[0].ID = %v, want 0", config.Areas[0].ID)
				}
				if config.Areas[0].Type != "normal" {
					t.Errorf("Areas[0].Type = %v, want normal", config.Areas[0].Type)
				}
			},
		},
		{
			name: "ospf_area_stub",
			rtx:  "ospf area 1 stub",
			checkFunc: func(t *testing.T, config *OSPFConfig) {
				if len(config.Areas) != 1 {
					t.Errorf("Areas count = %v, want 1", len(config.Areas))
					return
				}
				if config.Areas[0].Type != "stub" {
					t.Errorf("Areas[0].Type = %v, want stub", config.Areas[0].Type)
				}
			},
		},
		{
			name: "ospf_area_stub_no_summary",
			rtx:  "ospf area 1 stub no-summary",
			checkFunc: func(t *testing.T, config *OSPFConfig) {
				if len(config.Areas) != 1 {
					t.Errorf("Areas count = %v, want 1", len(config.Areas))
					return
				}
				if config.Areas[0].Type != "stub" {
					t.Errorf("Areas[0].Type = %v, want stub", config.Areas[0].Type)
				}
				if config.Areas[0].NoSummary != true {
					t.Errorf("Areas[0].NoSummary = %v, want true", config.Areas[0].NoSummary)
				}
			},
		},
		// Note: NSSA is NOT supported on RTX routers according to reference
		// ospf_area_nssa test case removed
		{
			name: "ospf_import_static",
			rtx:  "ospf import from static",
			checkFunc: func(t *testing.T, config *OSPFConfig) {
				if config.RedistributeStatic != true {
					t.Errorf("RedistributeStatic = %v, want true", config.RedistributeStatic)
				}
			},
		},
		// Note: 'connected' is NOT a valid protocol for ospf import from
		// Reference only supports: static, rip, bgp
		// ospf_import_connected test case removed
		{
			name: "ip_interface_ospf_area",
			rtx:  "ip lan1 ospf area 0",
			checkFunc: func(t *testing.T, config *OSPFConfig) {
				if len(config.Networks) != 1 {
					t.Errorf("Networks count = %v, want 1", len(config.Networks))
					return
				}
				if config.Networks[0].IP != "lan1" {
					t.Errorf("Networks[0].IP = %v, want lan1", config.Networks[0].IP)
				}
				if config.Networks[0].Area != "0" {
					t.Errorf("Networks[0].Area = %v, want 0", config.Networks[0].Area)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseOSPFConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseOSPFConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestOSPFRoundTrip_Build tests Terraform value -> RTX command conversion
func TestOSPFRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "ospf_enable",
			buildFunc: func() string {
				return BuildOSPFEnableCommand()
			},
			expectedRTX: "ospf use on",
		},
		{
			name: "ospf_disable",
			buildFunc: func() string {
				return BuildOSPFDisableCommand()
			},
			expectedRTX: "ospf use off",
		},
		{
			name: "ospf_router_id",
			buildFunc: func() string {
				return BuildOSPFRouterIDCommand("10.0.0.1")
			},
			expectedRTX: "ospf router id 10.0.0.1",
		},
		{
			name: "ospf_area_normal",
			buildFunc: func() string {
				return BuildOSPFAreaCommand(OSPFArea{ID: "0", Type: "normal"})
			},
			expectedRTX: "ospf area 0",
		},
		{
			name: "ospf_area_stub",
			buildFunc: func() string {
				return BuildOSPFAreaCommand(OSPFArea{ID: "1", Type: "stub"})
			},
			expectedRTX: "ospf area 1 stub",
		},
		{
			name: "ospf_area_stub_no_summary",
			buildFunc: func() string {
				return BuildOSPFAreaCommand(OSPFArea{ID: "1", Type: "stub", NoSummary: true})
			},
			expectedRTX: "ospf area 1 stub no-summary",
		},
		// Note: NSSA is NOT supported on RTX routers according to reference
		// ospf_area_nssa and ospf_area_nssa_no_summary test cases removed
		{
			name: "ip_ospf_area",
			buildFunc: func() string {
				return BuildIPOSPFAreaCommand("lan1", "0")
			},
			expectedRTX: "ip lan1 ospf area 0",
		},
		{
			name: "ospf_import_static",
			buildFunc: func() string {
				return BuildOSPFImportCommand("static")
			},
			expectedRTX: "ospf import from static",
		},
		// Note: 'connected' is NOT a valid protocol for ospf import from
		// ospf_import_connected test case removed
		{
			name: "delete_ospf_area",
			buildFunc: func() string {
				return BuildDeleteOSPFAreaCommand("1")
			},
			expectedRTX: "no ospf area 1",
		},
		{
			name: "delete_ip_ospf_area",
			buildFunc: func() string {
				return BuildDeleteIPOSPFAreaCommand("lan1")
			},
			expectedRTX: "no ip lan1 ospf area",
		},
		{
			name: "delete_ospf_import",
			buildFunc: func() string {
				return BuildDeleteOSPFImportCommand("static")
			},
			expectedRTX: "no ospf import from static",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestOSPFRoundTrip_ParseBuildParse tests full round-trip
func TestOSPFRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewOSPFParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "ospf_use_on",
			rtx:  "ospf use on",
		},
		{
			name: "ospf_use_off",
			rtx:  "ospf use off",
		},
		{
			name: "ospf_router_id",
			rtx:  "ospf router id 10.0.0.1",
		},
		{
			name: "ospf_import_static",
			rtx:  "ospf import from static",
		},
		// Note: 'connected' is NOT a valid protocol for ospf import from
		// ospf_import_connected test case removed
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			config, err := parser.ParseOSPFConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseOSPFConfig(%q) error = %v", tc.rtx, err)
			}

			// Step 2: Build back to RTX command
			var rebuiltRTX string
			switch tc.name {
			case "ospf_use_on":
				if config.Enabled {
					rebuiltRTX = BuildOSPFEnableCommand()
				} else {
					rebuiltRTX = BuildOSPFDisableCommand()
				}
			case "ospf_use_off":
				if config.Enabled {
					rebuiltRTX = BuildOSPFEnableCommand()
				} else {
					rebuiltRTX = BuildOSPFDisableCommand()
				}
			case "ospf_router_id":
				rebuiltRTX = BuildOSPFRouterIDCommand(config.RouterID)
			case "ospf_import_static":
				rebuiltRTX = BuildOSPFImportCommand("static")
			}

			// Step 3: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}
		})
	}
}
