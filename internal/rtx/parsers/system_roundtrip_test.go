// Code generated by specgen. DO NOT EDIT.
// Source: specs/system/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestSystemRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestSystemRoundTrip_Parse(t *testing.T) {
	parser := NewSystemParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *SystemConfig)
	}{
		{
			name: "timezone",
			rtx:  "timezone +09:00",
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if config.Timezone != "+09:00" {
					t.Errorf("Timezone = %v, want +09:00", config.Timezone)
				}
			},
		},
		{
			name: "console_character",
			rtx:  "console character ja.utf8",
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if config.Console == nil {
					t.Errorf("Console should not be nil")
					return
				}
				if config.Console.Character != "ja.utf8" {
					t.Errorf("Console.Character = %v, want ja.utf8", config.Console.Character)
				}
			},
		},
		{
			name: "console_lines_infinity",
			rtx:  "console lines infinity",
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if config.Console == nil {
					t.Errorf("Console should not be nil")
					return
				}
				if config.Console.Lines != "infinity" {
					t.Errorf("Console.Lines = %v, want infinity", config.Console.Lines)
				}
			},
		},
		{
			name: "console_lines_number",
			rtx:  "console lines 24",
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if config.Console == nil {
					t.Errorf("Console should not be nil")
					return
				}
				if config.Console.Lines != "24" {
					t.Errorf("Console.Lines = %v, want 24", config.Console.Lines)
				}
			},
		},
		{
			name: "console_prompt",
			rtx:  "console prompt MyRouter",
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if config.Console == nil {
					t.Errorf("Console should not be nil")
					return
				}
				if config.Console.Prompt != "MyRouter" {
					t.Errorf("Console.Prompt = %v, want MyRouter", config.Console.Prompt)
				}
			},
		},
		{
			name: "packet_buffer",
			rtx:  "system packet-buffer small max-buffer=5000 max-free=1300",
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if len(config.PacketBuffers) != 1 {
					t.Errorf("PacketBuffers count = %v, want 1", len(config.PacketBuffers))
					return
				}
				pb := config.PacketBuffers[0]
				if pb.Size != "small" {
					t.Errorf("PacketBuffer Size = %v, want small", pb.Size)
				}
				if pb.MaxBuffer != 5000 {
					t.Errorf("PacketBuffer MaxBuffer = %v, want 5000", pb.MaxBuffer)
				}
				if pb.MaxFree != 1300 {
					t.Errorf("PacketBuffer MaxFree = %v, want 1300", pb.MaxFree)
				}
			},
		},
		{
			name: "statistics_traffic_on",
			rtx:  "statistics traffic on",
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if config.Statistics == nil {
					t.Errorf("Statistics should not be nil")
					return
				}
				if !config.Statistics.Traffic {
					t.Errorf("Statistics.Traffic = %v, want true", config.Statistics.Traffic)
				}
			},
		},
		{
			name: "statistics_nat_on",
			rtx:  "statistics nat on",
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if config.Statistics == nil {
					t.Errorf("Statistics should not be nil")
					return
				}
				if !config.Statistics.NAT {
					t.Errorf("Statistics.NAT = %v, want true", config.Statistics.NAT)
				}
			},
		},
		{
			name: "full_config",
			rtx: `timezone +09:00
console character ja.utf8
console lines infinity
system packet-buffer small max-buffer=5000 max-free=1300
statistics traffic on
statistics nat on`,
			checkFunc: func(t *testing.T, config *SystemConfig) {
				if config.Timezone != "+09:00" {
					t.Errorf("Timezone = %v, want +09:00", config.Timezone)
				}
				if config.Console == nil {
					t.Errorf("Console should not be nil")
					return
				}
				if config.Console.Character != "ja.utf8" {
					t.Errorf("Console.Character = %v, want ja.utf8", config.Console.Character)
				}
				if len(config.PacketBuffers) != 1 {
					t.Errorf("PacketBuffers count = %v, want 1", len(config.PacketBuffers))
				}
				if config.Statistics == nil {
					t.Errorf("Statistics should not be nil")
					return
				}
				if !config.Statistics.Traffic || !config.Statistics.NAT {
					t.Errorf("Statistics Traffic/NAT should both be true")
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseSystemConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseSystemConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestSystemRoundTrip_Build tests Terraform value -> RTX command conversion
func TestSystemRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "timezone",
			buildFunc: func() string {
				return BuildTimezoneCommand("+09:00")
			},
			expectedRTX: "timezone +09:00",
		},
		{
			name: "console_character",
			buildFunc: func() string {
				return BuildConsoleCharacterCommand("ja.utf8")
			},
			expectedRTX: "console character ja.utf8",
		},
		{
			name: "console_lines_infinity",
			buildFunc: func() string {
				return BuildConsoleLinesCommand("infinity")
			},
			expectedRTX: "console lines infinity",
		},
		{
			name: "console_lines_number",
			buildFunc: func() string {
				return BuildConsoleLinesCommand("24")
			},
			expectedRTX: "console lines 24",
		},
		{
			name: "console_prompt_simple",
			buildFunc: func() string {
				return BuildConsolePromptCommand("MyRouter")
			},
			expectedRTX: "console prompt MyRouter",
		},
		{
			name: "console_prompt_with_space",
			buildFunc: func() string {
				return BuildConsolePromptCommand("My Router")
			},
			expectedRTX: `console prompt "My Router"`,
		},
		{
			name: "packet_buffer",
			buildFunc: func() string {
				return BuildPacketBufferCommand(PacketBufferConfig{
					Size:      "small",
					MaxBuffer: 5000,
					MaxFree:   1300,
				})
			},
			expectedRTX: "system packet-buffer small max-buffer=5000 max-free=1300",
		},
		{
			name: "statistics_traffic_on",
			buildFunc: func() string {
				return BuildStatisticsTrafficCommand(true)
			},
			expectedRTX: "statistics traffic on",
		},
		{
			name: "statistics_traffic_off",
			buildFunc: func() string {
				return BuildStatisticsTrafficCommand(false)
			},
			expectedRTX: "statistics traffic off",
		},
		{
			name: "statistics_nat_on",
			buildFunc: func() string {
				return BuildStatisticsNATCommand(true)
			},
			expectedRTX: "statistics nat on",
		},
		{
			name: "statistics_nat_off",
			buildFunc: func() string {
				return BuildStatisticsNATCommand(false)
			},
			expectedRTX: "statistics nat off",
		},
		{
			name: "delete_timezone",
			buildFunc: func() string {
				return BuildDeleteTimezoneCommand()
			},
			expectedRTX: "no timezone",
		},
		{
			name: "delete_console_character",
			buildFunc: func() string {
				return BuildDeleteConsoleCharacterCommand()
			},
			expectedRTX: "no console character",
		},
		{
			name: "delete_console_lines",
			buildFunc: func() string {
				return BuildDeleteConsoleLinesCommand()
			},
			expectedRTX: "no console lines",
		},
		{
			name: "delete_console_prompt",
			buildFunc: func() string {
				return BuildDeleteConsolePromptCommand()
			},
			expectedRTX: "no console prompt",
		},
		{
			name: "delete_packet_buffer",
			buildFunc: func() string {
				return BuildDeletePacketBufferCommand("small")
			},
			expectedRTX: "no system packet-buffer small",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestSystemRoundTrip_ParseBuildParse tests full round-trip
func TestSystemRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewSystemParser()

	t.Run("timezone_round_trip", func(t *testing.T) {
		rtx := "timezone +09:00"

		// Parse
		config, err := parser.ParseSystemConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSystemConfig error: %v", err)
		}

		// Build
		rebuilt := BuildTimezoneCommand(config.Timezone)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("console_character_round_trip", func(t *testing.T) {
		rtx := "console character ja.utf8"

		// Parse
		config, err := parser.ParseSystemConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSystemConfig error: %v", err)
		}

		// Build
		rebuilt := BuildConsoleCharacterCommand(config.Console.Character)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("packet_buffer_round_trip", func(t *testing.T) {
		rtx := "system packet-buffer small max-buffer=5000 max-free=1300"

		// Parse
		config, err := parser.ParseSystemConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSystemConfig error: %v", err)
		}

		if len(config.PacketBuffers) != 1 {
			t.Fatalf("Expected 1 packet buffer, got %d", len(config.PacketBuffers))
		}

		// Build
		rebuilt := BuildPacketBufferCommand(config.PacketBuffers[0])

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestSystemRoundTrip_Validation tests system validation functions
func TestSystemRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		config    *SystemConfig
		wantError bool
	}{
		{
			name: "valid_timezone",
			config: &SystemConfig{
				Timezone: "+09:00",
			},
			wantError: false,
		},
		{
			name: "invalid_timezone",
			config: &SystemConfig{
				Timezone: "invalid",
			},
			wantError: true,
		},
		{
			name: "valid_console_character",
			config: &SystemConfig{
				Console: &ConsoleConfig{
					Character: "ja.utf8",
				},
			},
			wantError: false,
		},
		{
			name: "invalid_console_character",
			config: &SystemConfig{
				Console: &ConsoleConfig{
					Character: "invalid",
				},
			},
			wantError: true,
		},
		{
			name: "valid_console_lines_infinity",
			config: &SystemConfig{
				Console: &ConsoleConfig{
					Lines: "infinity",
				},
			},
			wantError: false,
		},
		{
			name: "valid_console_lines_number",
			config: &SystemConfig{
				Console: &ConsoleConfig{
					Lines: "24",
				},
			},
			wantError: false,
		},
		{
			name: "invalid_console_lines",
			config: &SystemConfig{
				Console: &ConsoleConfig{
					Lines: "invalid",
				},
			},
			wantError: true,
		},
		{
			name: "valid_packet_buffer",
			config: &SystemConfig{
				PacketBuffers: []PacketBufferConfig{
					{Size: "small", MaxBuffer: 5000, MaxFree: 1300},
				},
			},
			wantError: false,
		},
		{
			name: "invalid_packet_buffer_size",
			config: &SystemConfig{
				PacketBuffers: []PacketBufferConfig{
					{Size: "invalid", MaxBuffer: 5000, MaxFree: 1300},
				},
			},
			wantError: true,
		},
		{
			name: "invalid_packet_buffer_max_free_exceeds_max_buffer",
			config: &SystemConfig{
				PacketBuffers: []PacketBufferConfig{
					{Size: "small", MaxBuffer: 1000, MaxFree: 2000},
				},
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateSystemConfig(tc.config)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateSystemConfig() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}

// TestSystemRoundTrip_Delete tests delete command generation
func TestSystemRoundTrip_Delete(t *testing.T) {
	config := &SystemConfig{
		Timezone: "+09:00",
		Console: &ConsoleConfig{
			Character: "ja.utf8",
			Lines:     "infinity",
			Prompt:    "MyRouter",
		},
		PacketBuffers: []PacketBufferConfig{
			{Size: "small", MaxBuffer: 5000, MaxFree: 1300},
		},
		Statistics: &StatisticsConfig{
			Traffic: true,
			NAT:     true,
		},
	}

	commands := BuildDeleteSystemCommands(config)

	if len(commands) == 0 {
		t.Errorf("Expected delete commands, got empty slice")
		return
	}

	// Verify timezone delete is present
	foundTimezone := false
	for _, cmd := range commands {
		if cmd == "no timezone" {
			foundTimezone = true
			break
		}
	}
	if !foundTimezone {
		t.Errorf("Expected 'no timezone' in delete commands")
	}

	// Verify packet buffer delete is present
	foundPacketBuffer := false
	for _, cmd := range commands {
		if cmd == "no system packet-buffer small" {
			foundPacketBuffer = true
			break
		}
	}
	if !foundPacketBuffer {
		t.Errorf("Expected 'no system packet-buffer small' in delete commands")
	}
}
