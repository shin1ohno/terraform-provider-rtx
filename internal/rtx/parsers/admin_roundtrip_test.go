// Code generated by specgen. DO NOT EDIT.
// Source: specs/admin/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"strings"
	"testing"
)

// TestAdminRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestAdminRoundTrip_Parse(t *testing.T) {
	parser := NewAdminParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *AdminConfig)
	}{
		{
			name: "login_user_plaintext",
			rtx:  "login user admin mypassword",
			checkFunc: func(t *testing.T, config *AdminConfig) {
				if len(config.Users) != 1 {
					t.Errorf("Users count = %v, want 1", len(config.Users))
					return
				}
				u := config.Users[0]
				if u.Username != "admin" {
					t.Errorf("Username = %v, want admin", u.Username)
				}
				if u.Password != "mypassword" {
					t.Errorf("Password = %v, want mypassword", u.Password)
				}
				if u.Encrypted != false {
					t.Errorf("Encrypted = %v, want false", u.Encrypted)
				}
			},
		},
		{
			name: "login_user_encrypted",
			rtx:  "login user admin encrypted abc123hash",
			checkFunc: func(t *testing.T, config *AdminConfig) {
				if len(config.Users) != 1 {
					t.Errorf("Users count = %v, want 1", len(config.Users))
					return
				}
				u := config.Users[0]
				if u.Username != "admin" {
					t.Errorf("Username = %v, want admin", u.Username)
				}
				if u.Password != "abc123hash" {
					t.Errorf("Password = %v, want abc123hash", u.Password)
				}
				if u.Encrypted != true {
					t.Errorf("Encrypted = %v, want true", u.Encrypted)
				}
			},
		},
		{
			name: "user_attribute_admin_on",
			rtx:  "user attribute admin administrator=on",
			checkFunc: func(t *testing.T, config *AdminConfig) {
				if len(config.Users) != 1 {
					t.Errorf("Users count = %v, want 1", len(config.Users))
					return
				}
				attrs := config.Users[0].Attributes
				if attrs.Administrator == nil || *attrs.Administrator != true {
					t.Errorf("Administrator = %v, want true", attrs.Administrator)
				}
			},
		},
		{
			name: "user_attribute_admin_off",
			rtx:  "user attribute testuser administrator=off",
			checkFunc: func(t *testing.T, config *AdminConfig) {
				if len(config.Users) != 1 {
					t.Errorf("Users count = %v, want 1", len(config.Users))
					return
				}
				attrs := config.Users[0].Attributes
				if attrs.Administrator == nil || *attrs.Administrator != false {
					t.Errorf("Administrator = %v, want false", attrs.Administrator)
				}
			},
		},
		{
			name: "user_attribute_connection",
			rtx:  "user attribute admin connection=ssh,telnet",
			checkFunc: func(t *testing.T, config *AdminConfig) {
				if len(config.Users) != 1 {
					t.Errorf("Users count = %v, want 1", len(config.Users))
					return
				}
				attrs := config.Users[0].Attributes
				if len(attrs.Connection) != 2 {
					t.Errorf("Connection count = %v, want 2", len(attrs.Connection))
					return
				}
				if attrs.Connection[0] != "ssh" || attrs.Connection[1] != "telnet" {
					t.Errorf("Connection = %v, want [ssh, telnet]", attrs.Connection)
				}
			},
		},
		{
			name: "user_attribute_login_timer",
			rtx:  "user attribute admin login-timer=300",
			checkFunc: func(t *testing.T, config *AdminConfig) {
				if len(config.Users) != 1 {
					t.Errorf("Users count = %v, want 1", len(config.Users))
					return
				}
				attrs := config.Users[0].Attributes
				if attrs.LoginTimer == nil || *attrs.LoginTimer != 300 {
					t.Errorf("LoginTimer = %v, want 300", attrs.LoginTimer)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseAdminConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseAdminConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestAdminRoundTrip_Build tests Terraform value -> RTX command conversion
func TestAdminRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "login_password",
			buildFunc: func() string {
				return BuildLoginPasswordCommand("mypassword")
			},
			expectedRTX: "login password mypassword",
		},
		{
			name: "admin_password",
			buildFunc: func() string {
				return BuildAdminPasswordCommand("adminpass")
			},
			expectedRTX: "administrator password adminpass",
		},
		{
			name: "login_user_plaintext",
			buildFunc: func() string {
				return BuildUserCommand(UserConfig{
					Username:  "admin",
					Password:  "mypassword",
					Encrypted: false,
				})
			},
			expectedRTX: "login user admin mypassword",
		},
		{
			name: "login_user_encrypted",
			buildFunc: func() string {
				return BuildUserCommand(UserConfig{
					Username:  "admin",
					Password:  "abc123hash",
					Encrypted: true,
				})
			},
			expectedRTX: "login user admin encrypted abc123hash",
		},
		{
			name: "user_attribute_admin_on",
			buildFunc: func() string {
				isAdmin := true
				return BuildUserAttributeCommand("admin", UserAttributes{
					Administrator: &isAdmin,
				})
			},
			expectedRTX: "user attribute admin administrator=on",
		},
		{
			name: "user_attribute_admin_off",
			buildFunc: func() string {
				isAdmin := false
				return BuildUserAttributeCommand("testuser", UserAttributes{
					Administrator: &isAdmin,
				})
			},
			expectedRTX: "user attribute testuser administrator=off",
		},
		{
			name: "user_attribute_connection",
			buildFunc: func() string {
				return BuildUserAttributeCommand("admin", UserAttributes{
					Connection: []string{"ssh", "telnet"},
				})
			},
			expectedRTX: "user attribute admin connection=ssh,telnet",
		},
		{
			name: "user_attribute_login_timer",
			buildFunc: func() string {
				timer := 300
				return BuildUserAttributeCommand("admin", UserAttributes{
					LoginTimer: &timer,
				})
			},
			expectedRTX: "user attribute admin login-timer=300",
		},
		{
			name: "delete_user",
			buildFunc: func() string {
				return BuildDeleteUserCommand("testuser")
			},
			expectedRTX: "no login user testuser",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestAdminRoundTrip_ParseBuildParse tests full round-trip
func TestAdminRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewAdminParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "login_user_plaintext",
			rtx:  "login user admin mypassword",
		},
		{
			name: "login_user_encrypted",
			rtx:  "login user admin encrypted abc123hash",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			config, err := parser.ParseAdminConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseAdminConfig(%q) error = %v", tc.rtx, err)
			}
			if len(config.Users) != 1 {
				t.Fatalf("Expected 1 user, got %d", len(config.Users))
			}
			user := config.Users[0]

			// Step 2: Build back to RTX command
			rebuiltRTX := BuildUserCommand(user)

			// Step 3: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}

			// Step 4: Parse the rebuilt command
			config2, err := parser.ParseAdminConfig(rebuiltRTX)
			if err != nil {
				t.Fatalf("ParseAdminConfig(%q) error = %v", rebuiltRTX, err)
			}
			if len(config2.Users) != 1 {
				t.Fatalf("Expected 1 user, got %d", len(config2.Users))
			}
			user2 := config2.Users[0]

			// Verify key fields match
			if user.Username != user2.Username {
				t.Errorf("Username mismatch: %v != %v", user.Username, user2.Username)
			}
			if user.Password != user2.Password {
				t.Errorf("Password mismatch: %v != %v", user.Password, user2.Password)
			}
			if user.Encrypted != user2.Encrypted {
				t.Errorf("Encrypted mismatch: %v != %v", user.Encrypted, user2.Encrypted)
			}
		})
	}
}

// TestAdminRoundTrip_UserAttribute tests user attribute round-trip
func TestAdminRoundTrip_UserAttribute(t *testing.T) {
	parser := NewAdminParser()

	testCases := []struct {
		name           string
		rtx            string
		buildAttrs     func(username string, attrs UserAttributes) string
		validateParsed func(t *testing.T, attrs UserAttributes)
	}{
		{
			name: "administrator_on",
			rtx:  "user attribute admin administrator=on",
			buildAttrs: func(username string, attrs UserAttributes) string {
				return BuildUserAttributeCommand(username, attrs)
			},
			validateParsed: func(t *testing.T, attrs UserAttributes) {
				if attrs.Administrator == nil || *attrs.Administrator != true {
					t.Errorf("Administrator should be true")
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Parse
			config, err := parser.ParseAdminConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseAdminConfig error: %v", err)
			}
			if len(config.Users) != 1 {
				t.Fatalf("Expected 1 user")
			}

			// Validate parsed result
			tc.validateParsed(t, config.Users[0].Attributes)

			// Build and compare
			rebuilt := tc.buildAttrs(config.Users[0].Username, config.Users[0].Attributes)
			if !strings.Contains(rebuilt, "administrator=on") && strings.Contains(tc.rtx, "administrator=on") {
				t.Logf("Note: Built command may differ in attribute ordering")
			}
		})
	}
}
