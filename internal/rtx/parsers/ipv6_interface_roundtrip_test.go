// Code generated by specgen. DO NOT EDIT.
// Source: specs/ipv6/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestIPv6InterfaceRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestIPv6InterfaceRoundTrip_Parse(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		iface     string
		checkFunc func(t *testing.T, config *IPv6InterfaceConfig)
	}{
		{
			name:  "ipv6_address_static",
			rtx:   "ipv6 lan1 address 2001:db8::1/64",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *IPv6InterfaceConfig) {
				if len(config.Addresses) != 1 {
					t.Errorf("Addresses count = %v, want 1", len(config.Addresses))
					return
				}
				if config.Addresses[0].Address != "2001:db8::1/64" {
					t.Errorf("Address = %v, want 2001:db8::1/64", config.Addresses[0].Address)
				}
			},
		},
		{
			name:  "ipv6_address_prefix_ref",
			rtx:   "ipv6 lan1 address ra-prefix@lan2::1/64",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *IPv6InterfaceConfig) {
				if len(config.Addresses) != 1 {
					t.Errorf("Addresses count = %v, want 1", len(config.Addresses))
					return
				}
				if config.Addresses[0].PrefixRef != "ra-prefix@lan2" {
					t.Errorf("PrefixRef = %v, want ra-prefix@lan2", config.Addresses[0].PrefixRef)
				}
				if config.Addresses[0].InterfaceID != "::1/64" {
					t.Errorf("InterfaceID = %v, want ::1/64", config.Addresses[0].InterfaceID)
				}
			},
		},
		{
			name:  "rtadv_send",
			rtx:   "ipv6 lan1 rtadv send 1 o_flag=on m_flag=off",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *IPv6InterfaceConfig) {
				if config.RTADV == nil {
					t.Errorf("RTADV should not be nil")
					return
				}
				if !config.RTADV.Enabled {
					t.Errorf("RTADV.Enabled = %v, want true", config.RTADV.Enabled)
				}
				if config.RTADV.PrefixID != 1 {
					t.Errorf("RTADV.PrefixID = %v, want 1", config.RTADV.PrefixID)
				}
				if !config.RTADV.OFlag {
					t.Errorf("RTADV.OFlag = %v, want true", config.RTADV.OFlag)
				}
				if config.RTADV.MFlag {
					t.Errorf("RTADV.MFlag = %v, want false", config.RTADV.MFlag)
				}
			},
		},
		{
			name:  "dhcpv6_service_server",
			rtx:   "ipv6 lan1 dhcp service server",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *IPv6InterfaceConfig) {
				if config.DHCPv6Service != "server" {
					t.Errorf("DHCPv6Service = %v, want server", config.DHCPv6Service)
				}
			},
		},
		{
			name:  "dhcpv6_service_client",
			rtx:   "ipv6 lan1 dhcp service client",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *IPv6InterfaceConfig) {
				if config.DHCPv6Service != "client" {
					t.Errorf("DHCPv6Service = %v, want client", config.DHCPv6Service)
				}
			},
		},
		{
			name:  "mtu",
			rtx:   "ipv6 lan1 mtu 1280",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *IPv6InterfaceConfig) {
				if config.MTU != 1280 {
					t.Errorf("MTU = %v, want 1280", config.MTU)
				}
			},
		},
		{
			name:  "secure_filter_in",
			rtx:   "ipv6 lan1 secure filter in 100 200",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *IPv6InterfaceConfig) {
				if len(config.SecureFilterIn) != 2 {
					t.Errorf("SecureFilterIn count = %v, want 2", len(config.SecureFilterIn))
				}
			},
		},
		{
			name: "full_config",
			rtx: `ipv6 lan1 address 2001:db8::1/64
ipv6 lan1 rtadv send 1 o_flag=on m_flag=off
ipv6 lan1 dhcp service server
ipv6 lan1 mtu 1400
ipv6 lan1 secure filter in 100 200`,
			iface: "lan1",
			checkFunc: func(t *testing.T, config *IPv6InterfaceConfig) {
				if len(config.Addresses) != 1 {
					t.Errorf("Addresses count = %v, want 1", len(config.Addresses))
				}
				if config.RTADV == nil {
					t.Errorf("RTADV should not be nil")
				}
				if config.DHCPv6Service != "server" {
					t.Errorf("DHCPv6Service = %v, want server", config.DHCPv6Service)
				}
				if config.MTU != 1400 {
					t.Errorf("MTU = %v, want 1400", config.MTU)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := ParseIPv6InterfaceConfig(tc.rtx, tc.iface)
			if err != nil {
				t.Fatalf("ParseIPv6InterfaceConfig(%q, %q) error = %v", tc.rtx, tc.iface, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestIPv6InterfaceRoundTrip_Build tests Terraform value -> RTX command conversion
func TestIPv6InterfaceRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "ipv6_address_static",
			buildFunc: func() string {
				return BuildIPv6AddressCommand("lan1", IPv6Address{
					Address: "2001:db8::1/64",
				})
			},
			expectedRTX: "ipv6 lan1 address 2001:db8::1/64",
		},
		{
			name: "ipv6_address_prefix_ref",
			buildFunc: func() string {
				return BuildIPv6AddressCommand("lan1", IPv6Address{
					PrefixRef:   "ra-prefix@lan2",
					InterfaceID: "::1/64",
				})
			},
			expectedRTX: "ipv6 lan1 address ra-prefix@lan2::1/64",
		},
		{
			name: "rtadv_send",
			buildFunc: func() string {
				return BuildIPv6RTADVCommand("lan1", RTADVConfig{
					Enabled:  true,
					PrefixID: 1,
					OFlag:    true,
					MFlag:    false,
				})
			},
			expectedRTX: "ipv6 lan1 rtadv send 1 o_flag=on m_flag=off",
		},
		{
			name: "rtadv_with_lifetime",
			buildFunc: func() string {
				return BuildIPv6RTADVCommand("lan1", RTADVConfig{
					Enabled:  true,
					PrefixID: 1,
					OFlag:    true,
					MFlag:    true,
					Lifetime: 1800,
				})
			},
			expectedRTX: "ipv6 lan1 rtadv send 1 o_flag=on m_flag=on lifetime=1800",
		},
		{
			name: "dhcpv6_server",
			buildFunc: func() string {
				return BuildIPv6DHCPv6Command("lan1", "server")
			},
			expectedRTX: "ipv6 lan1 dhcp service server",
		},
		{
			name: "dhcpv6_client",
			buildFunc: func() string {
				return BuildIPv6DHCPv6Command("lan1", "client")
			},
			expectedRTX: "ipv6 lan1 dhcp service client",
		},
		{
			name: "mtu",
			buildFunc: func() string {
				return BuildIPv6MTUCommand("lan1", 1400)
			},
			expectedRTX: "ipv6 lan1 mtu 1400",
		},
		{
			name: "secure_filter_in",
			buildFunc: func() string {
				return BuildIPv6SecureFilterInCommand("lan1", []int{100, 200})
			},
			expectedRTX: "ipv6 lan1 secure filter in 100 200",
		},
		{
			name: "secure_filter_out_with_dynamic",
			buildFunc: func() string {
				return BuildIPv6SecureFilterOutCommand("lan1", []int{100, 200}, []int{10, 20})
			},
			expectedRTX: "ipv6 lan1 secure filter out 100 200 dynamic 10 20",
		},
		{
			name: "delete_ipv6_address",
			buildFunc: func() string {
				return BuildDeleteIPv6AddressCommand("lan1", nil)
			},
			expectedRTX: "no ipv6 lan1 address",
		},
		{
			name: "delete_rtadv",
			buildFunc: func() string {
				return BuildDeleteIPv6RTADVCommand("lan1")
			},
			expectedRTX: "no ipv6 lan1 rtadv send",
		},
		{
			name: "delete_dhcpv6",
			buildFunc: func() string {
				return BuildDeleteIPv6DHCPv6Command("lan1")
			},
			expectedRTX: "no ipv6 lan1 dhcp service",
		},
		{
			name: "delete_mtu",
			buildFunc: func() string {
				return BuildDeleteIPv6MTUCommand("lan1")
			},
			expectedRTX: "no ipv6 lan1 mtu",
		},
		{
			name: "delete_secure_filter",
			buildFunc: func() string {
				return BuildDeleteIPv6SecureFilterCommand("lan1", "in")
			},
			expectedRTX: "no ipv6 lan1 secure filter in",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestIPv6InterfaceRoundTrip_ParseBuildParse tests full round-trip
func TestIPv6InterfaceRoundTrip_ParseBuildParse(t *testing.T) {
	t.Run("ipv6_address_round_trip", func(t *testing.T) {
		rtx := "ipv6 lan1 address 2001:db8::1/64"
		iface := "lan1"

		// Parse
		config, err := ParseIPv6InterfaceConfig(rtx, iface)
		if err != nil {
			t.Fatalf("ParseIPv6InterfaceConfig error: %v", err)
		}

		if len(config.Addresses) != 1 {
			t.Fatalf("Expected 1 address, got %d", len(config.Addresses))
		}

		// Build
		rebuilt := BuildIPv6AddressCommand(iface, config.Addresses[0])

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestIPv6InterfaceRoundTrip_Validation tests IPv6 interface config validation functions
func TestIPv6InterfaceRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		config    IPv6InterfaceConfig
		wantError bool
	}{
		{
			name: "valid_config",
			config: IPv6InterfaceConfig{
				Interface: "lan1",
				Addresses: []IPv6Address{
					{Address: "2001:db8::1/64"},
				},
			},
			wantError: false,
		},
		{
			name: "invalid_interface_name",
			config: IPv6InterfaceConfig{
				Interface: "invalid",
			},
			wantError: true,
		},
		{
			name: "address_without_prefix_length",
			config: IPv6InterfaceConfig{
				Interface: "lan1",
				Addresses: []IPv6Address{
					{Address: "2001:db8::1"}, // Missing /prefix
				},
			},
			wantError: true,
		},
		{
			name: "prefix_ref_without_at",
			config: IPv6InterfaceConfig{
				Interface: "lan1",
				Addresses: []IPv6Address{
					{PrefixRef: "ra-prefix-lan2", InterfaceID: "::1/64"}, // Missing @
				},
			},
			wantError: true,
		},
		{
			name: "interface_id_without_colons",
			config: IPv6InterfaceConfig{
				Interface: "lan1",
				Addresses: []IPv6Address{
					{PrefixRef: "ra-prefix@lan2", InterfaceID: "1/64"}, // Missing ::
				},
			},
			wantError: true,
		},
		{
			name: "invalid_rtadv_prefix_id",
			config: IPv6InterfaceConfig{
				Interface: "lan1",
				RTADV: &RTADVConfig{
					Enabled:  true,
					PrefixID: 0,
				},
			},
			wantError: true,
		},
		{
			name: "invalid_dhcpv6_service",
			config: IPv6InterfaceConfig{
				Interface:     "lan1",
				DHCPv6Service: "invalid",
			},
			wantError: true,
		},
		{
			name: "invalid_mtu_too_small",
			config: IPv6InterfaceConfig{
				Interface: "lan1",
				MTU:       1000, // IPv6 minimum is 1280
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateIPv6InterfaceConfig(tc.config)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateIPv6InterfaceConfig() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}

// TestIPv6InterfaceRoundTrip_Delete tests delete command generation
func TestIPv6InterfaceRoundTrip_Delete(t *testing.T) {
	commands := BuildDeleteIPv6InterfaceCommands("lan1")

	if len(commands) == 0 {
		t.Errorf("Expected delete commands, got empty slice")
		return
	}

	// Verify address delete is present
	foundAddress := false
	for _, cmd := range commands {
		if cmd == "no ipv6 lan1 address" {
			foundAddress = true
			break
		}
	}
	if !foundAddress {
		t.Errorf("Expected 'no ipv6 lan1 address' in delete commands")
	}
}
