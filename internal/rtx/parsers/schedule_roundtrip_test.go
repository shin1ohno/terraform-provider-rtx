// Code generated by specgen. DO NOT EDIT.
// Source: specs/schedule/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestScheduleRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestScheduleRoundTrip_Parse(t *testing.T) {
	parser := NewScheduleParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, schedules []Schedule)
	}{
		{
			name: "schedule_at_time",
			rtx:  "schedule at 1 12:00 restart",
			checkFunc: func(t *testing.T, schedules []Schedule) {
				if len(schedules) != 1 {
					t.Errorf("Schedules count = %v, want 1", len(schedules))
					return
				}
				s := schedules[0]
				if s.ID != 1 {
					t.Errorf("ID = %v, want 1", s.ID)
				}
				if s.AtTime != "12:00" {
					t.Errorf("AtTime = %v, want 12:00", s.AtTime)
				}
				if len(s.Commands) != 1 || s.Commands[0] != "restart" {
					t.Errorf("Commands = %v, want [restart]", s.Commands)
				}
			},
		},
		{
			name: "schedule_at_startup",
			rtx:  "schedule at 2 startup show config",
			checkFunc: func(t *testing.T, schedules []Schedule) {
				if len(schedules) != 1 {
					t.Errorf("Schedules count = %v, want 1", len(schedules))
					return
				}
				s := schedules[0]
				if s.ID != 2 {
					t.Errorf("ID = %v, want 2", s.ID)
				}
				if !s.OnStartup {
					t.Errorf("OnStartup = %v, want true", s.OnStartup)
				}
			},
		},
		{
			name: "schedule_at_date_time",
			rtx:  "schedule at 3 2024/01/15 10:30 restart",
			checkFunc: func(t *testing.T, schedules []Schedule) {
				if len(schedules) != 1 {
					t.Errorf("Schedules count = %v, want 1", len(schedules))
					return
				}
				s := schedules[0]
				if s.ID != 3 {
					t.Errorf("ID = %v, want 3", s.ID)
				}
				if s.Date != "2024/01/15" {
					t.Errorf("Date = %v, want 2024/01/15", s.Date)
				}
				if s.AtTime != "10:30" {
					t.Errorf("AtTime = %v, want 10:30", s.AtTime)
				}
			},
		},
		{
			name: "schedule_pp",
			rtx:  "schedule pp 1 mon-fri 8:00 connect",
			checkFunc: func(t *testing.T, schedules []Schedule) {
				if len(schedules) != 1 {
					t.Errorf("Schedules count = %v, want 1", len(schedules))
					return
				}
				s := schedules[0]
				// PP schedules use negative IDs
				if s.ID != -1 {
					t.Errorf("ID = %v, want -1", s.ID)
				}
				if s.DayOfWeek != "mon-fri" {
					t.Errorf("DayOfWeek = %v, want mon-fri", s.DayOfWeek)
				}
				if s.AtTime != "8:00" {
					t.Errorf("AtTime = %v, want 8:00", s.AtTime)
				}
			},
		},
		{
			name: "multiple_schedules",
			rtx: `schedule at 1 12:00 restart
schedule at 2 startup show status
schedule at 3 18:00 save`,
			checkFunc: func(t *testing.T, schedules []Schedule) {
				if len(schedules) != 3 {
					t.Errorf("Schedules count = %v, want 3", len(schedules))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			schedules, err := parser.ParseScheduleConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseScheduleConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, schedules)
		})
	}
}

// TestScheduleRoundTrip_Build tests Terraform value -> RTX command conversion
func TestScheduleRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "schedule_at_time",
			buildFunc: func() string {
				return BuildScheduleAtCommand(1, "12:00", "restart")
			},
			expectedRTX: "schedule at 1 12:00 restart",
		},
		{
			name: "schedule_at_startup",
			buildFunc: func() string {
				return BuildScheduleAtStartupCommand(2, "show config")
			},
			expectedRTX: "schedule at 2 startup show config",
		},
		{
			name: "schedule_at_date_time",
			buildFunc: func() string {
				return BuildScheduleAtDateTimeCommand(3, "2024/01/15", "10:30", "restart")
			},
			expectedRTX: "schedule at 3 2024/01/15 10:30 restart",
		},
		{
			name: "schedule_pp",
			buildFunc: func() string {
				return BuildSchedulePPCommand(1, "mon-fri", "8:00", "connect")
			},
			expectedRTX: "schedule pp 1 mon-fri 8:00 connect",
		},
		{
			name: "delete_schedule",
			buildFunc: func() string {
				return BuildDeleteScheduleCommand(1)
			},
			expectedRTX: "no schedule at 1",
		},
		{
			name: "delete_schedule_pp",
			buildFunc: func() string {
				return BuildDeleteSchedulePPCommand(1, "mon-fri", "8:00")
			},
			expectedRTX: "no schedule pp 1 mon-fri 8:00",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestScheduleRoundTrip_ParseBuildParse tests full round-trip
func TestScheduleRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewScheduleParser()

	t.Run("schedule_at_time_round_trip", func(t *testing.T) {
		rtx := "schedule at 1 12:00 restart"

		// Parse
		schedules, err := parser.ParseScheduleConfig(rtx)
		if err != nil {
			t.Fatalf("ParseScheduleConfig error: %v", err)
		}

		if len(schedules) != 1 {
			t.Fatalf("Expected 1 schedule, got %d", len(schedules))
		}
		s := schedules[0]

		// Build
		rebuilt := BuildScheduleAtCommand(s.ID, s.AtTime, s.Commands[0])

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("schedule_at_startup_round_trip", func(t *testing.T) {
		rtx := "schedule at 2 startup show config"

		// Parse
		schedules, err := parser.ParseScheduleConfig(rtx)
		if err != nil {
			t.Fatalf("ParseScheduleConfig error: %v", err)
		}

		if len(schedules) != 1 {
			t.Fatalf("Expected 1 schedule, got %d", len(schedules))
		}
		s := schedules[0]

		// Build
		rebuilt := BuildScheduleAtStartupCommand(s.ID, s.Commands[0])

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestScheduleRoundTrip_Validation tests schedule validation functions
func TestScheduleRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		schedule  Schedule
		wantError bool
	}{
		{
			name: "valid_schedule_at_time",
			schedule: Schedule{
				ID:       1,
				AtTime:   "12:00",
				Commands: []string{"restart"},
			},
			wantError: false,
		},
		{
			name: "valid_schedule_startup",
			schedule: Schedule{
				ID:        2,
				OnStartup: true,
				Commands:  []string{"show config"},
			},
			wantError: false,
		},
		{
			name: "invalid_id_zero",
			schedule: Schedule{
				ID:       0,
				AtTime:   "12:00",
				Commands: []string{"restart"},
			},
			wantError: true,
		},
		{
			name: "invalid_id_too_large",
			schedule: Schedule{
				ID:       100000,
				AtTime:   "12:00",
				Commands: []string{"restart"},
			},
			wantError: true,
		},
		{
			name: "invalid_time_format",
			schedule: Schedule{
				ID:       1,
				AtTime:   "25:00",
				Commands: []string{"restart"},
			},
			wantError: true,
		},
		{
			name: "invalid_date_format",
			schedule: Schedule{
				ID:       1,
				Date:     "2024-01-15",
				AtTime:   "12:00",
				Commands: []string{"restart"},
			},
			wantError: true,
		},
		{
			name: "invalid_day_of_week",
			schedule: Schedule{
				ID:        1,
				DayOfWeek: "invalid",
				AtTime:    "12:00",
				Commands:  []string{"restart"},
			},
			wantError: true,
		},
		{
			name: "valid_day_range",
			schedule: Schedule{
				ID:        1,
				DayOfWeek: "mon-fri",
				AtTime:    "12:00",
				Commands:  []string{"restart"},
			},
			wantError: false,
		},
		{
			name: "valid_day_list",
			schedule: Schedule{
				ID:        1,
				DayOfWeek: "mon,wed,fri",
				AtTime:    "12:00",
				Commands:  []string{"restart"},
			},
			wantError: false,
		},
		{
			name: "no_time_or_startup",
			schedule: Schedule{
				ID:       1,
				Commands: []string{"restart"},
			},
			wantError: true,
		},
		{
			name: "startup_with_time_conflict",
			schedule: Schedule{
				ID:        1,
				OnStartup: true,
				AtTime:    "12:00",
				Commands:  []string{"restart"},
			},
			wantError: true,
		},
		{
			name: "no_commands",
			schedule: Schedule{
				ID:       1,
				AtTime:   "12:00",
				Commands: []string{},
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateSchedule(tc.schedule)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateSchedule() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}

// TestScheduleRoundTrip_TimeValidation tests time format validation
func TestScheduleRoundTrip_TimeValidation(t *testing.T) {
	testCases := []struct {
		time      string
		wantError bool
	}{
		{"12:00", false},
		{"0:00", false},
		{"23:59", false},
		{"24:00", true},
		{"12:60", true},
		{"invalid", true},
		{"12:0", true},
	}

	for _, tc := range testCases {
		t.Run(tc.time, func(t *testing.T) {
			err := ValidateTimeFormat(tc.time)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateTimeFormat(%q) error = %v, wantError %v", tc.time, err, tc.wantError)
			}
		})
	}
}

// TestScheduleRoundTrip_DateValidation tests date format validation
func TestScheduleRoundTrip_DateValidation(t *testing.T) {
	testCases := []struct {
		date      string
		wantError bool
	}{
		{"2024/01/15", false},
		{"2024/12/31", false},
		{"2024-01-15", true},
		{"2024/13/01", true},
		{"2024/01/32", true},
		{"1999/01/01", true},
		{"invalid", true},
	}

	for _, tc := range testCases {
		t.Run(tc.date, func(t *testing.T) {
			err := ValidateDateFormat(tc.date)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateDateFormat(%q) error = %v, wantError %v", tc.date, err, tc.wantError)
			}
		})
	}
}

// TestScheduleRoundTrip_DayOfWeekValidation tests day of week validation
func TestScheduleRoundTrip_DayOfWeekValidation(t *testing.T) {
	testCases := []struct {
		day       string
		wantError bool
	}{
		{"mon", false},
		{"tue", false},
		{"wed", false},
		{"thu", false},
		{"fri", false},
		{"sat", false},
		{"sun", false},
		{"mon-fri", false},
		{"sat,sun", false},
		{"mon,wed,fri", false},
		{"invalid", true},
		{"mon-invalid", true},
	}

	for _, tc := range testCases {
		t.Run(tc.day, func(t *testing.T) {
			err := ValidateDayOfWeek(tc.day)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateDayOfWeek(%q) error = %v, wantError %v", tc.day, err, tc.wantError)
			}
		})
	}
}
