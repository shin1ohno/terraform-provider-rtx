// Code generated by specgen. DO NOT EDIT.
// Source: specs/qos/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestQoSRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestQoSRoundTrip_Parse(t *testing.T) {
	parser := NewQoSParser()

	testCases := []struct {
		name      string
		rtx       string
		iface     string
		checkFunc func(t *testing.T, config *QoSConfig)
	}{
		{
			name:  "queue_type_priority",
			rtx:   "queue lan1 type priority",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *QoSConfig) {
				if config.QueueType != "priority" {
					t.Errorf("QueueType = %v, want priority", config.QueueType)
				}
			},
		},
		{
			name:  "queue_class_filter",
			rtx:   "queue lan1 class filter 1 100",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *QoSConfig) {
				if len(config.Classes) != 1 {
					t.Errorf("Classes count = %v, want 1", len(config.Classes))
					return
				}
				if config.Classes[0].Filter != 100 {
					t.Errorf("Class Filter = %v, want 100", config.Classes[0].Filter)
				}
			},
		},
		{
			name:  "queue_class_priority",
			rtx:   "queue lan1 class priority 1 high",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *QoSConfig) {
				if len(config.Classes) != 1 {
					t.Errorf("Classes count = %v, want 1", len(config.Classes))
					return
				}
				if config.Classes[0].Priority != "high" {
					t.Errorf("Class Priority = %v, want high", config.Classes[0].Priority)
				}
			},
		},
		{
			name:  "speed",
			rtx:   "speed lan1 100000000",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *QoSConfig) {
				if config.Speed != 100000000 {
					t.Errorf("Speed = %v, want 100000000", config.Speed)
				}
			},
		},
		{
			name: "full_qos_config",
			rtx: `queue lan1 type priority
queue lan1 class filter 1 100
queue lan1 class filter 2 200
queue lan1 class priority 1 high
queue lan1 class priority 2 low
speed lan1 100000000`,
			iface: "lan1",
			checkFunc: func(t *testing.T, config *QoSConfig) {
				if config.QueueType != "priority" {
					t.Errorf("QueueType = %v, want priority", config.QueueType)
				}
				if config.Speed != 100000000 {
					t.Errorf("Speed = %v, want 100000000", config.Speed)
				}
				if len(config.Classes) < 2 {
					t.Errorf("Classes count = %v, want at least 2", len(config.Classes))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseQoSConfig(tc.rtx, tc.iface)
			if err != nil {
				t.Fatalf("ParseQoSConfig(%q, %q) error = %v", tc.rtx, tc.iface, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestQoSRoundTrip_Build tests Terraform value -> RTX command conversion
func TestQoSRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "queue_type",
			buildFunc: func() string {
				return BuildQueueTypeCommand("lan1", "priority")
			},
			expectedRTX: "queue lan1 type priority",
		},
		{
			name: "queue_class_filter",
			buildFunc: func() string {
				return BuildQueueClassFilterCommand("lan1", 1, 100)
			},
			expectedRTX: "queue lan1 class filter 1 100",
		},
		{
			name: "queue_class_priority",
			buildFunc: func() string {
				return BuildQueueClassPriorityCommand("lan1", 1, "high")
			},
			expectedRTX: "queue lan1 class priority 1 high",
		},
		{
			name: "queue_length",
			buildFunc: func() string {
				return BuildQueueLengthCommand("lan1", 1, 50)
			},
			expectedRTX: "queue lan1 length 1 50",
		},
		{
			name: "speed",
			buildFunc: func() string {
				return BuildSpeedCommand("lan1", 100000000)
			},
			expectedRTX: "speed lan1 100000000",
		},
		{
			name: "delete_queue_type",
			buildFunc: func() string {
				return BuildDeleteQueueTypeCommand("lan1")
			},
			expectedRTX: "no queue lan1 type",
		},
		{
			name: "delete_queue_class_filter",
			buildFunc: func() string {
				return BuildDeleteQueueClassFilterCommand("lan1", 1)
			},
			expectedRTX: "no queue lan1 class filter 1",
		},
		{
			name: "delete_queue_class_priority",
			buildFunc: func() string {
				return BuildDeleteQueueClassPriorityCommand("lan1", 1)
			},
			expectedRTX: "no queue lan1 class priority 1",
		},
		{
			name: "delete_speed",
			buildFunc: func() string {
				return BuildDeleteSpeedCommand("lan1")
			},
			expectedRTX: "no speed lan1",
		},
		{
			name: "delete_queue_length",
			buildFunc: func() string {
				return BuildDeleteQueueLengthCommand("lan1", 1)
			},
			expectedRTX: "no queue lan1 length 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestQoSRoundTrip_ParseBuildParse tests full round-trip
func TestQoSRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewQoSParser()

	t.Run("queue_type_round_trip", func(t *testing.T) {
		rtx := "queue lan1 type priority"
		iface := "lan1"

		// Parse
		config, err := parser.ParseQoSConfig(rtx, iface)
		if err != nil {
			t.Fatalf("ParseQoSConfig error: %v", err)
		}

		// Build
		rebuilt := BuildQueueTypeCommand(iface, config.QueueType)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("speed_round_trip", func(t *testing.T) {
		rtx := "speed lan1 100000000"
		iface := "lan1"

		// Parse
		config, err := parser.ParseQoSConfig(rtx, iface)
		if err != nil {
			t.Fatalf("ParseQoSConfig error: %v", err)
		}

		// Build
		rebuilt := BuildSpeedCommand(iface, config.Speed)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestQoSRoundTrip_Validation tests QoS validation functions
func TestQoSRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		config    QoSConfig
		wantError bool
	}{
		{
			name: "valid_config",
			config: QoSConfig{
				Interface: "lan1",
				QueueType: "priority",
				Speed:     100000000,
			},
			wantError: false,
		},
		{
			name: "empty_interface",
			config: QoSConfig{
				Interface: "",
				QueueType: "priority",
			},
			wantError: true,
		},
		{
			name: "invalid_queue_type",
			config: QoSConfig{
				Interface: "lan1",
				QueueType: "invalid",
			},
			wantError: true,
		},
		{
			name: "valid_class_priority",
			config: QoSConfig{
				Interface: "lan1",
				QueueType: "priority",
				Classes: []QoSClass{
					{Name: "class1", Priority: "high"},
				},
			},
			wantError: false,
		},
		{
			name: "invalid_class_priority",
			config: QoSConfig{
				Interface: "lan1",
				QueueType: "priority",
				Classes: []QoSClass{
					{Name: "class1", Priority: "invalid"},
				},
			},
			wantError: true,
		},
		{
			name: "bandwidth_exceeds_100",
			config: QoSConfig{
				Interface: "lan1",
				QueueType: "priority",
				Classes: []QoSClass{
					{Name: "class1", BandwidthPercent: 60},
					{Name: "class2", BandwidthPercent: 50},
				},
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateQoSConfig(tc.config)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateQoSConfig() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}

// TestQoSRoundTrip_Delete tests delete command generation
func TestQoSRoundTrip_Delete(t *testing.T) {
	commands := BuildDeleteQoSCommand("lan1")

	if len(commands) == 0 {
		t.Errorf("Expected delete commands, got empty slice")
		return
	}

	// Verify queue type delete is present
	foundQueueType := false
	foundSpeed := false
	for _, cmd := range commands {
		if cmd == "no queue lan1 type" {
			foundQueueType = true
		}
		if cmd == "no speed lan1" {
			foundSpeed = true
		}
	}

	if !foundQueueType {
		t.Errorf("Expected 'no queue lan1 type' in delete commands")
	}
	if !foundSpeed {
		t.Errorf("Expected 'no speed lan1' in delete commands")
	}
}
