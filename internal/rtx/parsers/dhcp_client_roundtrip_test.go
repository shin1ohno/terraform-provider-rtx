// Code generated by specgen. DO NOT EDIT.
// Source: specs/dhcp/client.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestDHCPClientRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestDHCPClientRoundTrip_Parse(t *testing.T) {
	parser := NewDHCPClientParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, configs []DHCPClientConfig)
	}{
		{
			name: "hostname",
			rtx:  "dhcp client hostname lan1 myrouter",
			checkFunc: func(t *testing.T, configs []DHCPClientConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].Interface != "lan1" {
					t.Errorf("Interface = %v, want lan1", configs[0].Interface)
				}
				if configs[0].Hostname != "myrouter" {
					t.Errorf("Hostname = %v, want myrouter", configs[0].Hostname)
				}
			},
		},
		{
			name: "client_identifier",
			rtx:  "dhcp client client-identifier lan1 01:00:11:22:33:44:55",
			checkFunc: func(t *testing.T, configs []DHCPClientConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].ClientID != "01:00:11:22:33:44:55" {
					t.Errorf("ClientID = %v, want 01:00:11:22:33:44:55", configs[0].ClientID)
				}
			},
		},
		{
			name: "vendor_class_identifier",
			rtx:  "dhcp client vendor-class-identifier lan1 YAMAHA-RTX",
			checkFunc: func(t *testing.T, configs []DHCPClientConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].VendorID != "YAMAHA-RTX" {
					t.Errorf("VendorID = %v, want YAMAHA-RTX", configs[0].VendorID)
				}
			},
		},
		{
			name: "require_dns_on",
			rtx:  "dhcp client require-dns lan1 on",
			checkFunc: func(t *testing.T, configs []DHCPClientConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if !configs[0].RequireDNS {
					t.Errorf("RequireDNS = %v, want true", configs[0].RequireDNS)
				}
			},
		},
		{
			name: "require_dns_off",
			rtx:  "dhcp client require-dns lan1 off",
			checkFunc: func(t *testing.T, configs []DHCPClientConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].RequireDNS {
					t.Errorf("RequireDNS = %v, want false", configs[0].RequireDNS)
				}
			},
		},
		{
			name: "release_linkdown",
			rtx:  "dhcp client release linkdown lan1",
			checkFunc: func(t *testing.T, configs []DHCPClientConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].ReleaseOn != "linkdown" {
					t.Errorf("ReleaseOn = %v, want linkdown", configs[0].ReleaseOn)
				}
			},
		},
		{
			name: "full_config",
			rtx: `dhcp client hostname lan1 myrouter
dhcp client client-identifier lan1 01:00:11:22:33:44:55
dhcp client vendor-class-identifier lan1 YAMAHA-RTX
dhcp client require-dns lan1 on
dhcp client release linkdown lan1`,
			checkFunc: func(t *testing.T, configs []DHCPClientConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				c := configs[0]
				if c.Hostname != "myrouter" {
					t.Errorf("Hostname = %v, want myrouter", c.Hostname)
				}
				if c.ClientID != "01:00:11:22:33:44:55" {
					t.Errorf("ClientID = %v, want 01:00:11:22:33:44:55", c.ClientID)
				}
				if c.VendorID != "YAMAHA-RTX" {
					t.Errorf("VendorID = %v, want YAMAHA-RTX", c.VendorID)
				}
				if !c.RequireDNS {
					t.Errorf("RequireDNS = %v, want true", c.RequireDNS)
				}
				if c.ReleaseOn != "linkdown" {
					t.Errorf("ReleaseOn = %v, want linkdown", c.ReleaseOn)
				}
			},
		},
		{
			name: "empty_config",
			rtx:  "",
			checkFunc: func(t *testing.T, configs []DHCPClientConfig) {
				if len(configs) != 0 {
					t.Errorf("Configs count = %v, want 0", len(configs))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			configs, err := parser.ParseClientConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseClientConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, configs)
		})
	}
}

// TestDHCPClientRoundTrip_Build tests Terraform value -> RTX command conversion
func TestDHCPClientRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "hostname",
			buildFunc: func() string {
				return BuildDHCPClientHostnameCommand("lan1", "myrouter")
			},
			expectedRTX: "dhcp client hostname lan1 myrouter",
		},
		{
			name: "client_identifier",
			buildFunc: func() string {
				return BuildDHCPClientClientIDCommand("lan1", "01:00:11:22:33:44:55")
			},
			expectedRTX: "dhcp client client-identifier lan1 01:00:11:22:33:44:55",
		},
		{
			name: "vendor_class_identifier",
			buildFunc: func() string {
				return BuildDHCPClientVendorIDCommand("lan1", "YAMAHA-RTX")
			},
			expectedRTX: "dhcp client vendor-class-identifier lan1 YAMAHA-RTX",
		},
		{
			name: "require_dns_on",
			buildFunc: func() string {
				return BuildDHCPClientRequireDNSCommand("lan1", true)
			},
			expectedRTX: "dhcp client require-dns lan1 on",
		},
		{
			name: "require_dns_off",
			buildFunc: func() string {
				return BuildDHCPClientRequireDNSCommand("lan1", false)
			},
			expectedRTX: "dhcp client require-dns lan1 off",
		},
		{
			name: "release_linkdown",
			buildFunc: func() string {
				return BuildDHCPClientReleaseLinkdownCommand("lan1")
			},
			expectedRTX: "dhcp client release linkdown lan1",
		},
		{
			name: "delete_hostname",
			buildFunc: func() string {
				return BuildDeleteDHCPClientHostnameCommand("lan1")
			},
			expectedRTX: "no dhcp client hostname lan1",
		},
		{
			name: "delete_client_identifier",
			buildFunc: func() string {
				return BuildDeleteDHCPClientClientIDCommand("lan1")
			},
			expectedRTX: "no dhcp client client-identifier lan1",
		},
		{
			name: "delete_vendor_class_identifier",
			buildFunc: func() string {
				return BuildDeleteDHCPClientVendorIDCommand("lan1")
			},
			expectedRTX: "no dhcp client vendor-class-identifier lan1",
		},
		{
			name: "delete_release_linkdown",
			buildFunc: func() string {
				return BuildDeleteDHCPClientReleaseLinkdownCommand("lan1")
			},
			expectedRTX: "no dhcp client release linkdown lan1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestDHCPClientRoundTrip_ParseBuildParse tests full round-trip
func TestDHCPClientRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewDHCPClientParser()

	t.Run("hostname_round_trip", func(t *testing.T) {
		rtx := "dhcp client hostname lan1 myrouter"

		// Parse
		configs, err := parser.ParseClientConfig(rtx)
		if err != nil {
			t.Fatalf("ParseClientConfig error: %v", err)
		}

		if len(configs) != 1 {
			t.Fatalf("Expected 1 config, got %d", len(configs))
		}

		// Build
		rebuilt := BuildDHCPClientHostnameCommand(configs[0].Interface, configs[0].Hostname)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("client_identifier_round_trip", func(t *testing.T) {
		rtx := "dhcp client client-identifier lan1 01:00:11:22:33:44:55"

		// Parse
		configs, err := parser.ParseClientConfig(rtx)
		if err != nil {
			t.Fatalf("ParseClientConfig error: %v", err)
		}

		if len(configs) != 1 {
			t.Fatalf("Expected 1 config, got %d", len(configs))
		}

		// Build
		rebuilt := BuildDHCPClientClientIDCommand(configs[0].Interface, configs[0].ClientID)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("require_dns_round_trip", func(t *testing.T) {
		rtx := "dhcp client require-dns lan1 on"

		// Parse
		configs, err := parser.ParseClientConfig(rtx)
		if err != nil {
			t.Fatalf("ParseClientConfig error: %v", err)
		}

		if len(configs) != 1 {
			t.Fatalf("Expected 1 config, got %d", len(configs))
		}

		// Build
		rebuilt := BuildDHCPClientRequireDNSCommand(configs[0].Interface, configs[0].RequireDNS)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestDHCPClientRoundTrip_MultipleInterfaces tests parsing multiple interfaces
func TestDHCPClientRoundTrip_MultipleInterfaces(t *testing.T) {
	parser := NewDHCPClientParser()

	rtx := `dhcp client hostname lan1 router1
dhcp client hostname lan2 router2`

	configs, err := parser.ParseClientConfig(rtx)
	if err != nil {
		t.Fatalf("ParseClientConfig error: %v", err)
	}

	if len(configs) != 2 {
		t.Errorf("Expected 2 configs, got %d", len(configs))
	}
}
