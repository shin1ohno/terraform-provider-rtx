// Code generated by specgen. DO NOT EDIT.
// Source: specs/dhcp/scope.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"strings"
	"testing"
)

// TestDHCPScopeRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestDHCPScopeRoundTrip_Parse(t *testing.T) {
	parser := NewDHCPScopeParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, scopes []DHCPScope)
	}{
		{
			name: "scope_basic",
			rtx:  "dhcp scope 1 192.168.1.0/24",
			checkFunc: func(t *testing.T, scopes []DHCPScope) {
				if len(scopes) != 1 {
					t.Errorf("Scopes count = %v, want 1", len(scopes))
					return
				}
				s := scopes[0]
				if s.ScopeID != 1 {
					t.Errorf("ScopeID = %v, want 1", s.ScopeID)
				}
				if s.Network != "192.168.1.0/24" {
					t.Errorf("Network = %v, want 192.168.1.0/24", s.Network)
				}
			},
		},
		{
			name: "scope_with_expire",
			rtx:  "dhcp scope 1 192.168.1.0/24 expire 24:00",
			checkFunc: func(t *testing.T, scopes []DHCPScope) {
				if len(scopes) != 1 {
					t.Errorf("Scopes count = %v, want 1", len(scopes))
					return
				}
				s := scopes[0]
				if s.LeaseTime != "24h" {
					t.Errorf("LeaseTime = %v, want 24h", s.LeaseTime)
				}
			},
		},
		{
			name: "scope_with_gateway",
			rtx:  "dhcp scope 1 192.168.1.0/24 gateway 192.168.1.1",
			checkFunc: func(t *testing.T, scopes []DHCPScope) {
				if len(scopes) != 1 {
					t.Errorf("Scopes count = %v, want 1", len(scopes))
					return
				}
				s := scopes[0]
				if len(s.Options.Routers) != 1 || s.Options.Routers[0] != "192.168.1.1" {
					t.Errorf("Routers = %v, want [192.168.1.1]", s.Options.Routers)
				}
			},
		},
		{
			name: "scope_option_dns",
			rtx:  "dhcp scope option 1 dns=8.8.8.8,8.8.4.4",
			checkFunc: func(t *testing.T, scopes []DHCPScope) {
				if len(scopes) != 1 {
					t.Errorf("Scopes count = %v, want 1", len(scopes))
					return
				}
				s := scopes[0]
				if len(s.Options.DNSServers) != 2 {
					t.Errorf("DNSServers count = %v, want 2", len(s.Options.DNSServers))
					return
				}
				if s.Options.DNSServers[0] != "8.8.8.8" {
					t.Errorf("DNSServers[0] = %v, want 8.8.8.8", s.Options.DNSServers[0])
				}
			},
		},
		{
			name: "scope_option_router",
			rtx:  "dhcp scope option 1 router=192.168.1.1",
			checkFunc: func(t *testing.T, scopes []DHCPScope) {
				if len(scopes) != 1 {
					t.Errorf("Scopes count = %v, want 1", len(scopes))
					return
				}
				s := scopes[0]
				if len(s.Options.Routers) != 1 || s.Options.Routers[0] != "192.168.1.1" {
					t.Errorf("Routers = %v, want [192.168.1.1]", s.Options.Routers)
				}
			},
		},
		{
			name: "scope_option_domain",
			rtx:  "dhcp scope option 1 domain=example.com",
			checkFunc: func(t *testing.T, scopes []DHCPScope) {
				if len(scopes) != 1 {
					t.Errorf("Scopes count = %v, want 1", len(scopes))
					return
				}
				s := scopes[0]
				if s.Options.DomainName != "example.com" {
					t.Errorf("DomainName = %v, want example.com", s.Options.DomainName)
				}
			},
		},
		{
			name: "scope_except",
			rtx:  "dhcp scope 1 except 192.168.1.1-192.168.1.10",
			checkFunc: func(t *testing.T, scopes []DHCPScope) {
				if len(scopes) != 1 {
					t.Errorf("Scopes count = %v, want 1", len(scopes))
					return
				}
				s := scopes[0]
				if len(s.ExcludeRanges) != 1 {
					t.Errorf("ExcludeRanges count = %v, want 1", len(s.ExcludeRanges))
					return
				}
				if s.ExcludeRanges[0].Start != "192.168.1.1" {
					t.Errorf("ExcludeRanges[0].Start = %v, want 192.168.1.1", s.ExcludeRanges[0].Start)
				}
				if s.ExcludeRanges[0].End != "192.168.1.10" {
					t.Errorf("ExcludeRanges[0].End = %v, want 192.168.1.10", s.ExcludeRanges[0].End)
				}
			},
		},
		{
			name: "scope_range_format",
			rtx:  "dhcp scope 1 192.168.1.20-192.168.1.99/24 gateway 192.168.1.1 expire 12:00",
			checkFunc: func(t *testing.T, scopes []DHCPScope) {
				if len(scopes) != 1 {
					t.Errorf("Scopes count = %v, want 1", len(scopes))
					return
				}
				s := scopes[0]
				if s.RangeStart != "192.168.1.20" {
					t.Errorf("RangeStart = %v, want 192.168.1.20", s.RangeStart)
				}
				if s.RangeEnd != "192.168.1.99" {
					t.Errorf("RangeEnd = %v, want 192.168.1.99", s.RangeEnd)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			scopes, err := parser.ParseScopeConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseScopeConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, scopes)
		})
	}
}

// TestDHCPScopeRoundTrip_Build tests Terraform value -> RTX command conversion
func TestDHCPScopeRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "scope_basic",
			buildFunc: func() string {
				return BuildDHCPScopeCommand(DHCPScope{
					ScopeID: 1,
					Network: "192.168.1.0/24",
				})
			},
			expectedRTX: "dhcp scope 1 192.168.1.0/24",
		},
		{
			name: "scope_with_expire",
			buildFunc: func() string {
				return BuildDHCPScopeCommand(DHCPScope{
					ScopeID:   1,
					Network:   "192.168.1.0/24",
					LeaseTime: "24h",
				})
			},
			expectedRTX: "dhcp scope 1 192.168.1.0/24 expire 24:00",
		},
		{
			name: "scope_with_maxexpire",
			buildFunc: func() string {
				return BuildDHCPScopeCommand(DHCPScope{
					ScopeID:      1,
					Network:      "192.168.1.0/24",
					LeaseTime:    "24h",
					MaxLeaseTime: "48h",
				})
			},
			expectedRTX: "dhcp scope 1 192.168.1.0/24 expire 24:00 maxexpire 48:00",
		},
		{
			name: "scope_option_dns",
			buildFunc: func() string {
				return BuildDHCPScopeOptionsCommand(1, DHCPScopeOptions{
					DNSServers: []string{"8.8.8.8", "8.8.4.4"},
				})
			},
			expectedRTX: "dhcp scope option 1 dns=8.8.8.8,8.8.4.4",
		},
		{
			name: "scope_option_router",
			buildFunc: func() string {
				return BuildDHCPScopeOptionsCommand(1, DHCPScopeOptions{
					Routers: []string{"192.168.1.1"},
				})
			},
			expectedRTX: "dhcp scope option 1 router=192.168.1.1",
		},
		{
			name: "scope_option_domain",
			buildFunc: func() string {
				return BuildDHCPScopeOptionsCommand(1, DHCPScopeOptions{
					DomainName: "example.com",
				})
			},
			expectedRTX: "dhcp scope option 1 domain=example.com",
		},
		{
			name: "scope_option_combined",
			buildFunc: func() string {
				return BuildDHCPScopeOptionsCommand(1, DHCPScopeOptions{
					DNSServers: []string{"8.8.8.8"},
					Routers:    []string{"192.168.1.1"},
					DomainName: "example.com",
				})
			},
			expectedRTX: "dhcp scope option 1 dns=8.8.8.8 router=192.168.1.1 domain=example.com",
		},
		{
			name: "scope_except",
			buildFunc: func() string {
				return BuildDHCPScopeExceptCommand(1, ExcludeRange{
					Start: "192.168.1.1",
					End:   "192.168.1.10",
				})
			},
			expectedRTX: "dhcp scope 1 except 192.168.1.1-192.168.1.10",
		},
		{
			name: "scope_range_format",
			buildFunc: func() string {
				return BuildDHCPScopeCommand(DHCPScope{
					ScopeID:    1,
					Network:    "192.168.1.0/24",
					RangeStart: "192.168.1.20",
					RangeEnd:   "192.168.1.99",
					LeaseTime:  "12h",
				})
			},
			expectedRTX: "dhcp scope 1 192.168.1.20-192.168.1.99/24 expire 12:00",
		},
		{
			name: "delete_scope",
			buildFunc: func() string {
				return BuildDeleteDHCPScopeCommand(1)
			},
			expectedRTX: "no dhcp scope 1",
		},
		{
			name: "delete_scope_options",
			buildFunc: func() string {
				return BuildDeleteDHCPScopeOptionsCommand(1)
			},
			expectedRTX: "no dhcp scope option 1",
		},
		{
			name: "delete_scope_except",
			buildFunc: func() string {
				return BuildDeleteDHCPScopeExceptCommand(1, ExcludeRange{
					Start: "192.168.1.1",
					End:   "192.168.1.10",
				})
			},
			expectedRTX: "no dhcp scope 1 except 192.168.1.1-192.168.1.10",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestDHCPScopeRoundTrip_ParseBuildParse tests full round-trip
func TestDHCPScopeRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewDHCPScopeParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "scope_basic",
			rtx:  "dhcp scope 1 192.168.1.0/24",
		},
		{
			name: "scope_with_expire",
			rtx:  "dhcp scope 1 192.168.1.0/24 expire 24:00",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			scopes, err := parser.ParseScopeConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseScopeConfig(%q) error = %v", tc.rtx, err)
			}
			if len(scopes) != 1 {
				t.Fatalf("Expected 1 scope, got %d", len(scopes))
			}
			scope := scopes[0]

			// Step 2: Build back to RTX command
			rebuiltRTX := BuildDHCPScopeCommand(scope)

			// Step 3: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}

			// Step 4: Parse the rebuilt command
			scopes2, err := parser.ParseScopeConfig(rebuiltRTX)
			if err != nil {
				t.Fatalf("ParseScopeConfig(%q) error = %v", rebuiltRTX, err)
			}
			if len(scopes2) != 1 {
				t.Fatalf("Expected 1 scope, got %d", len(scopes2))
			}
			scope2 := scopes2[0]

			// Verify key fields match
			if scope.ScopeID != scope2.ScopeID {
				t.Errorf("ScopeID mismatch: %v != %v", scope.ScopeID, scope2.ScopeID)
			}
			if scope.Network != scope2.Network {
				t.Errorf("Network mismatch: %v != %v", scope.Network, scope2.Network)
			}
			if scope.LeaseTime != scope2.LeaseTime {
				t.Errorf("LeaseTime mismatch: %v != %v", scope.LeaseTime, scope2.LeaseTime)
			}
		})
	}
}

// TestDHCPScopeRoundTrip_LeaseTimeConversion tests lease time format conversion
func TestDHCPScopeRoundTrip_LeaseTimeConversion(t *testing.T) {
	testCases := []struct {
		goFormat  string
		rtxFormat string
	}{
		{"24h", "24:00"},
		{"12h", "12:00"},
		{"1h", "1:00"},
		{"72h", "72:00"},
		{"infinite", "infinite"},
	}

	for _, tc := range testCases {
		t.Run(tc.goFormat, func(t *testing.T) {
			// Build a scope command with Go format lease time
			cmd := BuildDHCPScopeCommand(DHCPScope{
				ScopeID:   1,
				Network:   "192.168.1.0/24",
				LeaseTime: tc.goFormat,
			})

			// Check that the RTX format is used in the command
			if !strings.Contains(cmd, "expire "+tc.rtxFormat) {
				t.Errorf("Expected RTX format %q in command %q", tc.rtxFormat, cmd)
			}
		})
	}
}
