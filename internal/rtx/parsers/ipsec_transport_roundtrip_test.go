// Code generated by specgen. DO NOT EDIT.
// Source: specs/ipsec/transport.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestIPsecTransportRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestIPsecTransportRoundTrip_Parse(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, transports []IPsecTransport)
	}{
		{
			name: "ipsec_transport_l2tp",
			rtx:  "ipsec transport 1 1 udp 1701",
			checkFunc: func(t *testing.T, transports []IPsecTransport) {
				if len(transports) != 1 {
					t.Errorf("Transports count = %v, want 1", len(transports))
					return
				}
				if transports[0].TransportID != 1 {
					t.Errorf("TransportID = %v, want 1", transports[0].TransportID)
				}
				if transports[0].TunnelID != 1 {
					t.Errorf("TunnelID = %v, want 1", transports[0].TunnelID)
				}
				if transports[0].Protocol != "udp" {
					t.Errorf("Protocol = %v, want udp", transports[0].Protocol)
				}
				if transports[0].Port != 1701 {
					t.Errorf("Port = %v, want 1701", transports[0].Port)
				}
			},
		},
		{
			name: "ipsec_transport_custom_port",
			rtx:  "ipsec transport 2 3 udp 4500",
			checkFunc: func(t *testing.T, transports []IPsecTransport) {
				if len(transports) != 1 {
					t.Errorf("Transports count = %v, want 1", len(transports))
					return
				}
				if transports[0].TransportID != 2 {
					t.Errorf("TransportID = %v, want 2", transports[0].TransportID)
				}
				if transports[0].TunnelID != 3 {
					t.Errorf("TunnelID = %v, want 3", transports[0].TunnelID)
				}
				if transports[0].Port != 4500 {
					t.Errorf("Port = %v, want 4500", transports[0].Port)
				}
			},
		},
		{
			name: "multiple_transports",
			rtx: `ipsec transport 1 1 udp 1701
ipsec transport 2 2 udp 4500`,
			checkFunc: func(t *testing.T, transports []IPsecTransport) {
				if len(transports) != 2 {
					t.Errorf("Transports count = %v, want 2", len(transports))
				}
			},
		},
		{
			name: "empty_config",
			rtx:  "",
			checkFunc: func(t *testing.T, transports []IPsecTransport) {
				if len(transports) != 0 {
					t.Errorf("Transports count = %v, want 0", len(transports))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			transports, err := ParseIPsecTransportConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseIPsecTransportConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, transports)
		})
	}
}

// TestIPsecTransportRoundTrip_Build tests Terraform value -> RTX command conversion
func TestIPsecTransportRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "ipsec_transport_l2tp",
			buildFunc: func() string {
				return BuildIPsecTransportCommand(IPsecTransport{
					TransportID: 1,
					TunnelID:    1,
					Protocol:    "udp",
					Port:        1701,
				})
			},
			expectedRTX: "ipsec transport 1 1 udp 1701",
		},
		{
			name: "ipsec_transport_custom",
			buildFunc: func() string {
				return BuildIPsecTransportCommand(IPsecTransport{
					TransportID: 2,
					TunnelID:    3,
					Protocol:    "udp",
					Port:        4500,
				})
			},
			expectedRTX: "ipsec transport 2 3 udp 4500",
		},
		{
			name: "delete_ipsec_transport",
			buildFunc: func() string {
				return BuildDeleteIPsecTransportCommand(1)
			},
			expectedRTX: "no ipsec transport 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestIPsecTransportRoundTrip_ParseBuildParse tests full round-trip
func TestIPsecTransportRoundTrip_ParseBuildParse(t *testing.T) {
	testCases := []struct {
		name      string
		transport IPsecTransport
	}{
		{
			name: "l2tp_transport",
			transport: IPsecTransport{
				TransportID: 1,
				TunnelID:    1,
				Protocol:    "udp",
				Port:        1701,
			},
		},
		{
			name: "custom_transport",
			transport: IPsecTransport{
				TransportID: 2,
				TunnelID:    3,
				Protocol:    "udp",
				Port:        4500,
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Build command
			rtx := BuildIPsecTransportCommand(tc.transport)

			// Parse command
			transports, err := ParseIPsecTransportConfig(rtx)
			if err != nil {
				t.Fatalf("ParseIPsecTransportConfig error: %v", err)
			}

			if len(transports) != 1 {
				t.Fatalf("Expected 1 transport, got %d", len(transports))
			}

			// Verify parsed values match original
			if transports[0].TransportID != tc.transport.TransportID {
				t.Errorf("TransportID = %d, want %d", transports[0].TransportID, tc.transport.TransportID)
			}
			if transports[0].TunnelID != tc.transport.TunnelID {
				t.Errorf("TunnelID = %d, want %d", transports[0].TunnelID, tc.transport.TunnelID)
			}
			if transports[0].Protocol != tc.transport.Protocol {
				t.Errorf("Protocol = %q, want %q", transports[0].Protocol, tc.transport.Protocol)
			}
			if transports[0].Port != tc.transport.Port {
				t.Errorf("Port = %d, want %d", transports[0].Port, tc.transport.Port)
			}

			// Rebuild command
			rebuilt := BuildIPsecTransportCommand(transports[0])

			// Verify
			if rebuilt != rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
			}
		})
	}
}

// TestIPsecTransportRoundTrip_Validation tests validation functions
func TestIPsecTransportRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		transport IPsecTransport
		wantError bool
	}{
		{
			name: "valid_transport",
			transport: IPsecTransport{
				TransportID: 1,
				TunnelID:    1,
				Protocol:    "udp",
				Port:        1701,
			},
			wantError: false,
		},
		{
			name: "valid_tcp",
			transport: IPsecTransport{
				TransportID: 1,
				TunnelID:    1,
				Protocol:    "tcp",
				Port:        443,
			},
			wantError: false,
		},
		{
			name: "invalid_transport_id",
			transport: IPsecTransport{
				TransportID: 0,
				TunnelID:    1,
				Protocol:    "udp",
				Port:        1701,
			},
			wantError: true,
		},
		{
			name: "invalid_tunnel_id",
			transport: IPsecTransport{
				TransportID: 1,
				TunnelID:    0,
				Protocol:    "udp",
				Port:        1701,
			},
			wantError: true,
		},
		{
			name: "invalid_protocol",
			transport: IPsecTransport{
				TransportID: 1,
				TunnelID:    1,
				Protocol:    "invalid",
				Port:        1701,
			},
			wantError: true,
		},
		{
			name: "empty_protocol",
			transport: IPsecTransport{
				TransportID: 1,
				TunnelID:    1,
				Protocol:    "",
				Port:        1701,
			},
			wantError: true,
		},
		{
			name: "invalid_port_zero",
			transport: IPsecTransport{
				TransportID: 1,
				TunnelID:    1,
				Protocol:    "udp",
				Port:        0,
			},
			wantError: true,
		},
		{
			name: "invalid_port_too_high",
			transport: IPsecTransport{
				TransportID: 1,
				TunnelID:    1,
				Protocol:    "udp",
				Port:        65536,
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateIPsecTransport(tc.transport)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateIPsecTransport() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}
