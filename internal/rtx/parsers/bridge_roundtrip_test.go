// Code generated by specgen. DO NOT EDIT.
// Source: specs/bridge/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestBridgeRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestBridgeRoundTrip_Parse(t *testing.T) {
	parser := NewBridgeParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, bridges []BridgeConfig)
	}{
		{
			name: "bridge_single_member",
			rtx:  "bridge member bridge1 lan1",
			checkFunc: func(t *testing.T, bridges []BridgeConfig) {
				if len(bridges) != 1 {
					t.Errorf("Bridges count = %v, want 1", len(bridges))
					return
				}
				if bridges[0].Name != "bridge1" {
					t.Errorf("Name = %v, want bridge1", bridges[0].Name)
				}
				if len(bridges[0].Members) != 1 {
					t.Errorf("Members count = %v, want 1", len(bridges[0].Members))
					return
				}
				if bridges[0].Members[0] != "lan1" {
					t.Errorf("Members[0] = %v, want lan1", bridges[0].Members[0])
				}
			},
		},
		{
			name: "bridge_multiple_members",
			rtx:  "bridge member bridge1 lan1 tunnel1",
			checkFunc: func(t *testing.T, bridges []BridgeConfig) {
				if len(bridges) != 1 {
					t.Errorf("Bridges count = %v, want 1", len(bridges))
					return
				}
				if len(bridges[0].Members) != 2 {
					t.Errorf("Members count = %v, want 2", len(bridges[0].Members))
					return
				}
				if bridges[0].Members[0] != "lan1" {
					t.Errorf("Members[0] = %v, want lan1", bridges[0].Members[0])
				}
				if bridges[0].Members[1] != "tunnel1" {
					t.Errorf("Members[1] = %v, want tunnel1", bridges[0].Members[1])
				}
			},
		},
		{
			name: "bridge_three_members",
			rtx:  "bridge member bridge2 lan1 lan2 tunnel1",
			checkFunc: func(t *testing.T, bridges []BridgeConfig) {
				if len(bridges) != 1 {
					t.Errorf("Bridges count = %v, want 1", len(bridges))
					return
				}
				if bridges[0].Name != "bridge2" {
					t.Errorf("Name = %v, want bridge2", bridges[0].Name)
				}
				if len(bridges[0].Members) != 3 {
					t.Errorf("Members count = %v, want 3", len(bridges[0].Members))
				}
			},
		},
		{
			name: "multiple_bridges",
			rtx: `bridge member bridge1 lan1
bridge member bridge2 lan2`,
			checkFunc: func(t *testing.T, bridges []BridgeConfig) {
				if len(bridges) != 2 {
					t.Errorf("Bridges count = %v, want 2", len(bridges))
				}
			},
		},
		{
			name: "empty_config",
			rtx:  "",
			checkFunc: func(t *testing.T, bridges []BridgeConfig) {
				if len(bridges) != 0 {
					t.Errorf("Bridges count = %v, want 0", len(bridges))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			bridges, err := parser.ParseBridgeConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseBridgeConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, bridges)
		})
	}
}

// TestBridgeRoundTrip_Build tests Terraform value -> RTX command conversion
func TestBridgeRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "bridge_single_member",
			buildFunc: func() string {
				return BuildBridgeMemberCommand("bridge1", []string{"lan1"})
			},
			expectedRTX: "bridge member bridge1 lan1",
		},
		{
			name: "bridge_multiple_members",
			buildFunc: func() string {
				return BuildBridgeMemberCommand("bridge1", []string{"lan1", "tunnel1"})
			},
			expectedRTX: "bridge member bridge1 lan1 tunnel1",
		},
		{
			name: "bridge_three_members",
			buildFunc: func() string {
				return BuildBridgeMemberCommand("bridge2", []string{"lan1", "lan2", "tunnel1"})
			},
			expectedRTX: "bridge member bridge2 lan1 lan2 tunnel1",
		},
		{
			name: "bridge_no_members",
			buildFunc: func() string {
				return BuildBridgeMemberCommand("bridge1", []string{})
			},
			expectedRTX: "bridge member bridge1",
		},
		{
			name: "delete_bridge",
			buildFunc: func() string {
				return BuildDeleteBridgeCommand("bridge1")
			},
			expectedRTX: "no bridge member bridge1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestBridgeRoundTrip_ParseBuildParse tests full round-trip
func TestBridgeRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewBridgeParser()

	testCases := []struct {
		name    string
		bridge  string
		members []string
	}{
		{
			name:    "bridge1_single",
			bridge:  "bridge1",
			members: []string{"lan1"},
		},
		{
			name:    "bridge1_multiple",
			bridge:  "bridge1",
			members: []string{"lan1", "tunnel1"},
		},
		{
			name:    "bridge2_three",
			bridge:  "bridge2",
			members: []string{"lan1", "lan2", "pp1"},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Build command
			rtx := BuildBridgeMemberCommand(tc.bridge, tc.members)

			// Parse command
			bridges, err := parser.ParseBridgeConfig(rtx)
			if err != nil {
				t.Fatalf("ParseBridgeConfig error: %v", err)
			}

			if len(bridges) != 1 {
				t.Fatalf("Expected 1 bridge, got %d", len(bridges))
			}

			// Verify parsed values
			if bridges[0].Name != tc.bridge {
				t.Errorf("Name = %q, want %q", bridges[0].Name, tc.bridge)
			}

			if len(bridges[0].Members) != len(tc.members) {
				t.Errorf("Members count = %d, want %d", len(bridges[0].Members), len(tc.members))
			}

			// Rebuild command
			rebuilt := BuildBridgeMemberCommand(bridges[0].Name, bridges[0].Members)

			// Verify
			if rebuilt != rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
			}
		})
	}
}

// TestBridgeRoundTrip_Validation tests bridge validation functions
func TestBridgeRoundTrip_Validation(t *testing.T) {
	t.Run("valid_bridge_names", func(t *testing.T) {
		validNames := []string{"bridge1", "bridge2", "bridge10", "bridge99"}
		for _, name := range validNames {
			if err := ValidateBridgeName(name); err != nil {
				t.Errorf("ValidateBridgeName(%q) unexpected error: %v", name, err)
			}
		}
	})

	t.Run("invalid_bridge_names", func(t *testing.T) {
		invalidNames := []string{"", "bridge", "lan1", "BRIDGE1", "bridge-1", "bridge_1"}
		for _, name := range invalidNames {
			if err := ValidateBridgeName(name); err == nil {
				t.Errorf("ValidateBridgeName(%q) expected error, got nil", name)
			}
		}
	})

	t.Run("valid_members", func(t *testing.T) {
		validMembers := []string{"lan1", "lan2", "tunnel1", "pp1", "loopback1", "lan1/1"}
		for _, member := range validMembers {
			if err := ValidateBridgeMember(member); err != nil {
				t.Errorf("ValidateBridgeMember(%q) unexpected error: %v", member, err)
			}
		}
	})

	t.Run("invalid_members", func(t *testing.T) {
		invalidMembers := []string{"", "invalid", "eth0", "wan1"}
		for _, member := range invalidMembers {
			if err := ValidateBridgeMember(member); err == nil {
				t.Errorf("ValidateBridgeMember(%q) expected error, got nil", member)
			}
		}
	})

	t.Run("valid_bridge_config", func(t *testing.T) {
		config := BridgeConfig{
			Name:    "bridge1",
			Members: []string{"lan1", "tunnel1"},
		}
		if err := ValidateBridge(config); err != nil {
			t.Errorf("ValidateBridge() unexpected error: %v", err)
		}
	})

	t.Run("duplicate_members", func(t *testing.T) {
		config := BridgeConfig{
			Name:    "bridge1",
			Members: []string{"lan1", "lan1"},
		}
		if err := ValidateBridge(config); err == nil {
			t.Errorf("ValidateBridge() expected error for duplicate members, got nil")
		}
	})
}
