// Code generated by specgen. DO NOT EDIT.
// Source: specs/ipsec/tunnel.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestIPsecTunnelRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestIPsecTunnelRoundTrip_Parse(t *testing.T) {
	parser := NewIPsecTunnelParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, tunnels []IPsecTunnel)
	}{
		{
			name: "ipsec_basic",
			rtx: `tunnel select 1
ipsec tunnel 1
ipsec ike local address 1 192.168.1.1
ipsec ike remote address 1 203.0.113.1
ipsec ike pre-shared-key 1 text secretkey
tunnel enable 1`,
			checkFunc: func(t *testing.T, tunnels []IPsecTunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if tunnel.ID != 1 {
					t.Errorf("ID = %v, want 1", tunnel.ID)
				}
				if tunnel.LocalAddress != "192.168.1.1" {
					t.Errorf("LocalAddress = %v, want 192.168.1.1", tunnel.LocalAddress)
				}
				if tunnel.RemoteAddress != "203.0.113.1" {
					t.Errorf("RemoteAddress = %v, want 203.0.113.1", tunnel.RemoteAddress)
				}
				if tunnel.PreSharedKey != "secretkey" {
					t.Errorf("PreSharedKey = %v, want secretkey", tunnel.PreSharedKey)
				}
			},
		},
		{
			name: "ipsec_with_encryption_aes256",
			rtx: `tunnel select 2
ipsec tunnel 2
ipsec ike local address 2 10.0.0.1
ipsec ike remote address 2 10.0.0.2
ipsec ike pre-shared-key 2 text mykey
ipsec ike encryption 2 aes-cbc-256
ipsec ike hash 2 sha256
ipsec ike group 2 modp2048
tunnel enable 2`,
			checkFunc: func(t *testing.T, tunnels []IPsecTunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if !tunnel.IKEv2Proposal.EncryptionAES256 {
					t.Errorf("EncryptionAES256 = %v, want true", tunnel.IKEv2Proposal.EncryptionAES256)
				}
				if !tunnel.IKEv2Proposal.IntegritySHA256 {
					t.Errorf("IntegritySHA256 = %v, want true", tunnel.IKEv2Proposal.IntegritySHA256)
				}
				if !tunnel.IKEv2Proposal.GroupFourteen {
					t.Errorf("GroupFourteen = %v, want true", tunnel.IKEv2Proposal.GroupFourteen)
				}
			},
		},
		{
			name: "ipsec_with_dpd",
			rtx: `tunnel select 3
ipsec tunnel 3
ipsec ike local address 3 172.16.0.1
ipsec ike remote address 3 172.16.0.2
ipsec ike pre-shared-key 3 text dpdkey
ipsec ike keepalive use 3 on dpd 30 5
tunnel enable 3`,
			checkFunc: func(t *testing.T, tunnels []IPsecTunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if !tunnel.DPDEnabled {
					t.Errorf("DPDEnabled = %v, want true", tunnel.DPDEnabled)
				}
				if tunnel.KeepaliveMode != "dpd" {
					t.Errorf("KeepaliveMode = %v, want dpd", tunnel.KeepaliveMode)
				}
				if tunnel.DPDInterval != 30 {
					t.Errorf("DPDInterval = %v, want 30", tunnel.DPDInterval)
				}
				if tunnel.DPDRetry != 5 {
					t.Errorf("DPDRetry = %v, want 5", tunnel.DPDRetry)
				}
			},
		},
		{
			name: "ipsec_with_heartbeat",
			rtx: `tunnel select 4
ipsec tunnel 4
ipsec ike local address 4 192.168.10.1
ipsec ike remote address 4 192.168.10.2
ipsec ike pre-shared-key 4 text hbkey
ipsec ike keepalive use 4 on heartbeat 60 3
tunnel enable 4`,
			checkFunc: func(t *testing.T, tunnels []IPsecTunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if tunnel.KeepaliveMode != "heartbeat" {
					t.Errorf("KeepaliveMode = %v, want heartbeat", tunnel.KeepaliveMode)
				}
				if tunnel.DPDInterval != 60 {
					t.Errorf("DPDInterval = %v, want 60", tunnel.DPDInterval)
				}
				if tunnel.DPDRetry != 3 {
					t.Errorf("DPDRetry = %v, want 3", tunnel.DPDRetry)
				}
			},
		},
		{
			name: "ipsec_with_sa_policy",
			rtx: `tunnel select 5
ipsec tunnel 5
ipsec sa policy 5 1 esp aes-cbc-256 sha256-hmac
ipsec ike local address 5 10.10.10.1
ipsec ike remote address 5 10.10.10.2
ipsec ike pre-shared-key 5 text sakey
tunnel enable 5`,
			checkFunc: func(t *testing.T, tunnels []IPsecTunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if tunnel.IPsecTransform.Protocol != "esp" {
					t.Errorf("Protocol = %v, want esp", tunnel.IPsecTransform.Protocol)
				}
				if !tunnel.IPsecTransform.EncryptionAES256 {
					t.Errorf("Transform EncryptionAES256 = %v, want true", tunnel.IPsecTransform.EncryptionAES256)
				}
				if !tunnel.IPsecTransform.IntegritySHA256 {
					t.Errorf("Transform IntegritySHA256 = %v, want true", tunnel.IPsecTransform.IntegritySHA256)
				}
			},
		},
		{
			name: "ipsec_with_secure_filter",
			rtx: `tunnel select 6
ipsec tunnel 6
ipsec ike local address 6 192.168.100.1
ipsec ike remote address 6 192.168.100.2
ipsec ike pre-shared-key 6 text filterkey
ip tunnel secure filter in 100 101 102
ip tunnel secure filter out 200 201
tunnel enable 6`,
			checkFunc: func(t *testing.T, tunnels []IPsecTunnel) {
				if len(tunnels) != 1 {
					t.Errorf("Tunnel count = %v, want 1", len(tunnels))
					return
				}
				tunnel := tunnels[0]
				if len(tunnel.SecureFilterIn) != 3 {
					t.Errorf("SecureFilterIn count = %v, want 3", len(tunnel.SecureFilterIn))
				}
				if len(tunnel.SecureFilterOut) != 2 {
					t.Errorf("SecureFilterOut count = %v, want 2", len(tunnel.SecureFilterOut))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			tunnels, err := parser.ParseIPsecTunnelConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseIPsecTunnelConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, tunnels)
		})
	}
}

// TestIPsecTunnelRoundTrip_Build tests Terraform value -> RTX command conversion
func TestIPsecTunnelRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "tunnel_select",
			buildFunc: func() string {
				return BuildTunnelSelectCommand(1)
			},
			expectedRTX: "tunnel select 1",
		},
		{
			name: "ipsec_tunnel",
			buildFunc: func() string {
				return BuildIPsecTunnelCommand(1)
			},
			expectedRTX: "ipsec tunnel 1",
		},
		{
			name: "ipsec_ike_local_address",
			buildFunc: func() string {
				return BuildIPsecIKELocalAddressCommand(1, "192.168.1.1")
			},
			expectedRTX: "ipsec ike local address 1 192.168.1.1",
		},
		{
			name: "ipsec_ike_remote_address",
			buildFunc: func() string {
				return BuildIPsecIKERemoteAddressCommand(1, "203.0.113.1")
			},
			expectedRTX: "ipsec ike remote address 1 203.0.113.1",
		},
		{
			name: "ipsec_ike_pre_shared_key",
			buildFunc: func() string {
				return BuildIPsecIKEPreSharedKeyCommand(1, "secretkey")
			},
			expectedRTX: "ipsec ike pre-shared-key 1 text secretkey",
		},
		{
			name: "ipsec_ike_encryption_aes256",
			buildFunc: func() string {
				return BuildIPsecIKEEncryptionCommand(1, IKEv2Proposal{EncryptionAES256: true})
			},
			expectedRTX: "ipsec ike encryption 1 aes-cbc-256",
		},
		{
			name: "ipsec_ike_encryption_aes128",
			buildFunc: func() string {
				return BuildIPsecIKEEncryptionCommand(1, IKEv2Proposal{EncryptionAES128: true})
			},
			expectedRTX: "ipsec ike encryption 1 aes-cbc",
		},
		{
			name: "ipsec_ike_encryption_3des",
			buildFunc: func() string {
				return BuildIPsecIKEEncryptionCommand(1, IKEv2Proposal{Encryption3DES: true})
			},
			expectedRTX: "ipsec ike encryption 1 3des-cbc",
		},
		{
			name: "ipsec_ike_hash_sha256",
			buildFunc: func() string {
				return BuildIPsecIKEHashCommand(1, IKEv2Proposal{IntegritySHA256: true})
			},
			expectedRTX: "ipsec ike hash 1 sha256",
		},
		{
			name: "ipsec_ike_hash_sha1",
			buildFunc: func() string {
				return BuildIPsecIKEHashCommand(1, IKEv2Proposal{IntegritySHA1: true})
			},
			expectedRTX: "ipsec ike hash 1 sha",
		},
		{
			name: "ipsec_ike_hash_md5",
			buildFunc: func() string {
				return BuildIPsecIKEHashCommand(1, IKEv2Proposal{IntegrityMD5: true})
			},
			expectedRTX: "ipsec ike hash 1 md5",
		},
		{
			name: "ipsec_ike_group_14",
			buildFunc: func() string {
				return BuildIPsecIKEGroupCommand(1, IKEv2Proposal{GroupFourteen: true})
			},
			expectedRTX: "ipsec ike group 1 modp2048",
		},
		{
			name: "ipsec_ike_group_5",
			buildFunc: func() string {
				return BuildIPsecIKEGroupCommand(1, IKEv2Proposal{GroupFive: true})
			},
			expectedRTX: "ipsec ike group 1 modp1536",
		},
		{
			name: "ipsec_ike_group_2",
			buildFunc: func() string {
				return BuildIPsecIKEGroupCommand(1, IKEv2Proposal{GroupTwo: true})
			},
			expectedRTX: "ipsec ike group 1 modp1024",
		},
		{
			name: "ipsec_sa_policy",
			buildFunc: func() string {
				return BuildIPsecSAPolicyCommand(1, 1, IPsecTransform{
					Protocol:         "esp",
					EncryptionAES256: true,
					IntegritySHA256:  true,
				})
			},
			expectedRTX: "ipsec sa policy 1 1 esp aes-cbc-256 sha256-hmac",
		},
		{
			name: "ipsec_ike_keepalive_dpd",
			buildFunc: func() string {
				return BuildIPsecIKEKeepaliveCommand(1, 30, 5)
			},
			expectedRTX: "ipsec ike keepalive use 1 on dpd 30 5",
		},
		{
			name: "ipsec_ike_keepalive_dpd_no_retry",
			buildFunc: func() string {
				return BuildIPsecIKEKeepaliveCommand(1, 30, 0)
			},
			expectedRTX: "ipsec ike keepalive use 1 on dpd 30",
		},
		{
			name: "ipsec_ike_keepalive_heartbeat",
			buildFunc: func() string {
				return BuildIPsecIKEKeepaliveHeartbeatCommand(1, 60, 3)
			},
			expectedRTX: "ipsec ike keepalive use 1 on heartbeat 60 3",
		},
		{
			name: "ipsec_ike_keepalive_off",
			buildFunc: func() string {
				return BuildIPsecIKEKeepaliveOffCommand(1)
			},
			expectedRTX: "ipsec ike keepalive use 1 off",
		},
		{
			name: "tunnel_enable",
			buildFunc: func() string {
				return BuildTunnelEnableCommand(1)
			},
			expectedRTX: "tunnel enable 1",
		},
		{
			name: "tunnel_disable",
			buildFunc: func() string {
				return BuildTunnelDisableCommand(1)
			},
			expectedRTX: "tunnel disable 1",
		},
		{
			name: "delete_ipsec_tunnel",
			buildFunc: func() string {
				return BuildDeleteIPsecTunnelCommand(1)
			},
			expectedRTX: "no ipsec tunnel 1",
		},
		{
			name: "delete_tunnel_select",
			buildFunc: func() string {
				return BuildDeleteTunnelSelectCommand(1)
			},
			expectedRTX: "no tunnel select 1",
		},
		{
			name: "ip_tunnel_secure_filter_in",
			buildFunc: func() string {
				return BuildIPTunnelSecureFilterCommand("in", []int{100, 101, 102})
			},
			expectedRTX: "ip tunnel secure filter in 100 101 102",
		},
		{
			name: "ip_tunnel_secure_filter_out",
			buildFunc: func() string {
				return BuildIPTunnelSecureFilterCommand("out", []int{200, 201})
			},
			expectedRTX: "ip tunnel secure filter out 200 201",
		},
		{
			name: "delete_ip_tunnel_secure_filter_in",
			buildFunc: func() string {
				return BuildDeleteIPTunnelSecureFilterCommand("in")
			},
			expectedRTX: "no ip tunnel secure filter in",
		},
		{
			name: "ip_tunnel_tcp_mss_limit",
			buildFunc: func() string {
				return BuildIPTunnelTCPMSSLimitCommand("auto")
			},
			expectedRTX: "ip tunnel tcp mss limit auto",
		},
		{
			name: "delete_ip_tunnel_tcp_mss_limit",
			buildFunc: func() string {
				return BuildDeleteIPTunnelTCPMSSLimitCommand()
			},
			expectedRTX: "no ip tunnel tcp mss limit",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestIPsecTunnelRoundTrip_ParseBuildParse tests full round-trip
func TestIPsecTunnelRoundTrip_ParseBuildParse(t *testing.T) {
	testCases := []struct {
		name          string
		tunnelID      int
		localAddress  string
		remoteAddress string
		preSharedKey  string
	}{
		{
			name:          "basic_ipsec",
			tunnelID:      1,
			localAddress:  "192.168.1.1",
			remoteAddress: "203.0.113.1",
			preSharedKey:  "secretkey",
		},
		{
			name:          "second_tunnel",
			tunnelID:      2,
			localAddress:  "10.0.0.1",
			remoteAddress: "10.0.0.2",
			preSharedKey:  "anotherkey",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Build commands
			selectCmd := BuildTunnelSelectCommand(tc.tunnelID)
			ipsecCmd := BuildIPsecTunnelCommand(tc.tunnelID)
			localCmd := BuildIPsecIKELocalAddressCommand(tc.tunnelID, tc.localAddress)
			remoteCmd := BuildIPsecIKERemoteAddressCommand(tc.tunnelID, tc.remoteAddress)
			pskCmd := BuildIPsecIKEPreSharedKeyCommand(tc.tunnelID, tc.preSharedKey)

			// Step 2: Verify command format
			expectedSelect := "tunnel select 1"
			if tc.tunnelID != 1 {
				expectedSelect = "tunnel select 2"
			}
			if selectCmd != expectedSelect {
				t.Errorf("Select command = %q, want %q", selectCmd, expectedSelect)
			}

			expectedIPsec := "ipsec tunnel 1"
			if tc.tunnelID != 1 {
				expectedIPsec = "ipsec tunnel 2"
			}
			if ipsecCmd != expectedIPsec {
				t.Errorf("IPsec command = %q, want %q", ipsecCmd, expectedIPsec)
			}

			expectedLocal := "ipsec ike local address 1 " + tc.localAddress
			if tc.tunnelID != 1 {
				expectedLocal = "ipsec ike local address 2 " + tc.localAddress
			}
			if localCmd != expectedLocal {
				t.Errorf("Local command = %q, want %q", localCmd, expectedLocal)
			}

			expectedRemote := "ipsec ike remote address 1 " + tc.remoteAddress
			if tc.tunnelID != 1 {
				expectedRemote = "ipsec ike remote address 2 " + tc.remoteAddress
			}
			if remoteCmd != expectedRemote {
				t.Errorf("Remote command = %q, want %q", remoteCmd, expectedRemote)
			}

			expectedPSK := "ipsec ike pre-shared-key 1 text " + tc.preSharedKey
			if tc.tunnelID != 1 {
				expectedPSK = "ipsec ike pre-shared-key 2 text " + tc.preSharedKey
			}
			if pskCmd != expectedPSK {
				t.Errorf("PSK command = %q, want %q", pskCmd, expectedPSK)
			}
		})
	}
}
