// Code generated by specgen. DO NOT EDIT.
// Source: specs/snmp/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestSNMPRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestSNMPRoundTrip_Parse(t *testing.T) {
	parser := NewSNMPParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *SNMPConfig)
	}{
		{
			name: "snmp_sysname",
			rtx:  "snmp sysname MyRouter",
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if config.SysName != "MyRouter" {
					t.Errorf("SysName = %v, want MyRouter", config.SysName)
				}
			},
		},
		{
			name: "snmp_syslocation",
			rtx:  "snmp syslocation Tokyo Office",
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if config.SysLocation != "Tokyo Office" {
					t.Errorf("SysLocation = %v, want Tokyo Office", config.SysLocation)
				}
			},
		},
		{
			name: "snmp_syscontact",
			rtx:  "snmp syscontact admin@example.com",
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if config.SysContact != "admin@example.com" {
					t.Errorf("SysContact = %v, want admin@example.com", config.SysContact)
				}
			},
		},
		{
			name: "snmp_community_read_only",
			rtx:  "snmp community read-only public",
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if len(config.Communities) != 1 {
					t.Errorf("Communities count = %v, want 1", len(config.Communities))
					return
				}
				if config.Communities[0].Name != "public" {
					t.Errorf("Community Name = %v, want public", config.Communities[0].Name)
				}
				if config.Communities[0].Permission != "ro" {
					t.Errorf("Community Permission = %v, want ro", config.Communities[0].Permission)
				}
			},
		},
		{
			name: "snmp_community_read_write",
			rtx:  "snmp community read-write private",
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if len(config.Communities) != 1 {
					t.Errorf("Communities count = %v, want 1", len(config.Communities))
					return
				}
				if config.Communities[0].Name != "private" {
					t.Errorf("Community Name = %v, want private", config.Communities[0].Name)
				}
				if config.Communities[0].Permission != "rw" {
					t.Errorf("Community Permission = %v, want rw", config.Communities[0].Permission)
				}
			},
		},
		{
			name: "snmp_community_with_acl",
			rtx:  "snmp community read-only public 100",
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if len(config.Communities) != 1 {
					t.Errorf("Communities count = %v, want 1", len(config.Communities))
					return
				}
				if config.Communities[0].ACL != "100" {
					t.Errorf("Community ACL = %v, want 100", config.Communities[0].ACL)
				}
			},
		},
		{
			name: "snmp_host",
			rtx:  "snmp host 192.168.1.100",
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if len(config.Hosts) != 1 {
					t.Errorf("Hosts count = %v, want 1", len(config.Hosts))
					return
				}
				if config.Hosts[0].Address != "192.168.1.100" {
					t.Errorf("Host Address = %v, want 192.168.1.100", config.Hosts[0].Address)
				}
			},
		},
		{
			name: "snmp_trap_enable",
			rtx:  "snmp trap enable snmp all",
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if len(config.TrapEnable) != 1 {
					t.Errorf("TrapEnable count = %v, want 1", len(config.TrapEnable))
					return
				}
				if config.TrapEnable[0] != "all" {
					t.Errorf("TrapEnable = %v, want all", config.TrapEnable[0])
				}
			},
		},
		{
			name: "snmp_full_config",
			rtx: `snmp sysname RTX1210
snmp syslocation Server Room
snmp syscontact network@example.com
snmp community read-only public
snmp community read-write private
snmp host 192.168.1.100
snmp trap enable snmp all`,
			checkFunc: func(t *testing.T, config *SNMPConfig) {
				if config.SysName != "RTX1210" {
					t.Errorf("SysName = %v, want RTX1210", config.SysName)
				}
				if config.SysLocation != "Server Room" {
					t.Errorf("SysLocation = %v, want Server Room", config.SysLocation)
				}
				if len(config.Communities) != 2 {
					t.Errorf("Communities count = %v, want 2", len(config.Communities))
				}
				if len(config.Hosts) != 1 {
					t.Errorf("Hosts count = %v, want 1", len(config.Hosts))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseSNMPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseSNMPConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestSNMPRoundTrip_Build tests Terraform value -> RTX command conversion
func TestSNMPRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "snmp_sysname",
			buildFunc: func() string {
				return BuildSNMPSysNameCommand("MyRouter")
			},
			expectedRTX: "snmp sysname MyRouter",
		},
		{
			name: "snmp_syslocation",
			buildFunc: func() string {
				return BuildSNMPSysLocationCommand("Tokyo Office")
			},
			expectedRTX: "snmp syslocation Tokyo Office",
		},
		{
			name: "snmp_syscontact",
			buildFunc: func() string {
				return BuildSNMPSysContactCommand("admin@example.com")
			},
			expectedRTX: "snmp syscontact admin@example.com",
		},
		{
			name: "snmp_community_read_only",
			buildFunc: func() string {
				return BuildSNMPCommunityCommand(SNMPCommunity{
					Name:       "public",
					Permission: "ro",
				})
			},
			expectedRTX: "snmp community read-only public",
		},
		{
			name: "snmp_community_read_write",
			buildFunc: func() string {
				return BuildSNMPCommunityCommand(SNMPCommunity{
					Name:       "private",
					Permission: "rw",
				})
			},
			expectedRTX: "snmp community read-write private",
		},
		{
			name: "snmp_community_with_acl",
			buildFunc: func() string {
				return BuildSNMPCommunityCommand(SNMPCommunity{
					Name:       "public",
					Permission: "ro",
					ACL:        "100",
				})
			},
			expectedRTX: "snmp community read-only public 100",
		},
		{
			name: "snmp_host",
			buildFunc: func() string {
				return BuildSNMPHostCommand(SNMPHost{
					Address: "192.168.1.100",
				})
			},
			expectedRTX: "snmp host 192.168.1.100",
		},
		{
			name: "snmp_trap_community",
			buildFunc: func() string {
				return BuildSNMPTrapCommunityCommand("public")
			},
			expectedRTX: "snmp trap community public",
		},
		{
			name: "snmp_trap_enable",
			buildFunc: func() string {
				return BuildSNMPTrapEnableCommand([]string{"all"})
			},
			expectedRTX: "snmp trap enable snmp all",
		},
		{
			name: "delete_snmp_sysname",
			buildFunc: func() string {
				return BuildDeleteSNMPSysNameCommand()
			},
			expectedRTX: "no snmp sysname",
		},
		{
			name: "delete_snmp_syslocation",
			buildFunc: func() string {
				return BuildDeleteSNMPSysLocationCommand()
			},
			expectedRTX: "no snmp syslocation",
		},
		{
			name: "delete_snmp_syscontact",
			buildFunc: func() string {
				return BuildDeleteSNMPSysContactCommand()
			},
			expectedRTX: "no snmp syscontact",
		},
		{
			name: "delete_snmp_community",
			buildFunc: func() string {
				return BuildDeleteSNMPCommunityCommand(SNMPCommunity{
					Name:       "public",
					Permission: "ro",
				})
			},
			expectedRTX: "no snmp community read-only public",
		},
		{
			name: "delete_snmp_host",
			buildFunc: func() string {
				return BuildDeleteSNMPHostCommand("192.168.1.100")
			},
			expectedRTX: "no snmp host 192.168.1.100",
		},
		{
			name: "delete_snmp_trap_community",
			buildFunc: func() string {
				return BuildDeleteSNMPTrapCommunityCommand()
			},
			expectedRTX: "no snmp trap community",
		},
		{
			name: "delete_snmp_trap_enable",
			buildFunc: func() string {
				return BuildDeleteSNMPTrapEnableCommand()
			},
			expectedRTX: "no snmp trap enable snmp",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestSNMPRoundTrip_ParseBuildParse tests full round-trip
func TestSNMPRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewSNMPParser()

	t.Run("snmp_sysname_round_trip", func(t *testing.T) {
		rtx := "snmp sysname MyRouter"

		// Parse
		config, err := parser.ParseSNMPConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSNMPConfig error: %v", err)
		}

		// Build
		rebuilt := BuildSNMPSysNameCommand(config.SysName)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}

		// Parse again
		config2, err := parser.ParseSNMPConfig(rebuilt)
		if err != nil {
			t.Fatalf("ParseSNMPConfig error on rebuilt: %v", err)
		}

		if config.SysName != config2.SysName {
			t.Errorf("SysName mismatch: %v != %v", config.SysName, config2.SysName)
		}
	})

	t.Run("snmp_community_round_trip", func(t *testing.T) {
		rtx := "snmp community read-only public"

		// Parse
		config, err := parser.ParseSNMPConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSNMPConfig error: %v", err)
		}

		if len(config.Communities) != 1 {
			t.Fatalf("Expected 1 community, got %d", len(config.Communities))
		}

		// Build
		rebuilt := BuildSNMPCommunityCommand(config.Communities[0])

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestSNMPRoundTrip_Validation tests SNMP validation functions
func TestSNMPRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		config    SNMPConfig
		wantError bool
	}{
		{
			name: "valid_community",
			config: SNMPConfig{
				Communities: []SNMPCommunity{
					{Name: "public", Permission: "ro"},
				},
			},
			wantError: false,
		},
		{
			name: "invalid_community_permission",
			config: SNMPConfig{
				Communities: []SNMPCommunity{
					{Name: "public", Permission: "invalid"},
				},
			},
			wantError: true,
		},
		{
			name: "empty_community_name",
			config: SNMPConfig{
				Communities: []SNMPCommunity{
					{Name: "", Permission: "ro"},
				},
			},
			wantError: true,
		},
		{
			name: "valid_host",
			config: SNMPConfig{
				Hosts: []SNMPHost{
					{Address: "192.168.1.100"},
				},
			},
			wantError: false,
		},
		{
			name: "invalid_host_address",
			config: SNMPConfig{
				Hosts: []SNMPHost{
					{Address: "invalid-ip"},
				},
			},
			wantError: true,
		},
		{
			name: "invalid_snmp_version",
			config: SNMPConfig{
				Hosts: []SNMPHost{
					{Address: "192.168.1.100", Version: "3"},
				},
			},
			wantError: true,
		},
		{
			name: "valid_trap_type",
			config: SNMPConfig{
				TrapEnable: []string{"all"},
			},
			wantError: false,
		},
		{
			name: "invalid_trap_type",
			config: SNMPConfig{
				TrapEnable: []string{"invalid"},
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateSNMPConfig(tc.config)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateSNMPConfig() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}
