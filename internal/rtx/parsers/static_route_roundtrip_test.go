// Code generated by specgen. DO NOT EDIT.
// Source: specs/ip/route.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestStaticRouteRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestStaticRouteRoundTrip_Parse(t *testing.T) {
	parser := NewStaticRouteParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, routes []StaticRoute)
	}{
		{
			name: "default_route",
			rtx:  "ip route default gateway 192.168.1.1",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				r := routes[0]
				if r.Prefix != "0.0.0.0" || r.Mask != "0.0.0.0" {
					t.Errorf("Prefix/Mask = %v/%v, want 0.0.0.0/0.0.0.0", r.Prefix, r.Mask)
				}
				if len(r.NextHops) != 1 || r.NextHops[0].NextHop != "192.168.1.1" {
					t.Errorf("NextHop = %v, want 192.168.1.1", r.NextHops)
				}
			},
		},
		{
			name: "network_route_cidr",
			rtx:  "ip route 10.0.0.0/8 gateway 192.168.1.1",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				r := routes[0]
				if r.Prefix != "10.0.0.0" {
					t.Errorf("Prefix = %v, want 10.0.0.0", r.Prefix)
				}
				if r.Mask != "255.0.0.0" {
					t.Errorf("Mask = %v, want 255.0.0.0", r.Mask)
				}
			},
		},
		{
			name: "route_with_weight",
			rtx:  "ip route 10.0.0.0/8 gateway 192.168.1.1 weight 10",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				if len(routes[0].NextHops) != 1 {
					t.Errorf("NextHops count = %v, want 1", len(routes[0].NextHops))
					return
				}
				if routes[0].NextHops[0].Distance != 10 {
					t.Errorf("Distance = %v, want 10", routes[0].NextHops[0].Distance)
				}
			},
		},
		{
			name: "route_with_filter",
			rtx:  "ip route 10.0.0.0/8 gateway 192.168.1.1 filter 100",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				if len(routes[0].NextHops) != 1 {
					t.Errorf("NextHops count = %v, want 1", len(routes[0].NextHops))
					return
				}
				if routes[0].NextHops[0].Filter != 100 {
					t.Errorf("Filter = %v, want 100", routes[0].NextHops[0].Filter)
				}
			},
		},
		{
			name: "route_with_hide",
			rtx:  "ip route 10.0.0.0/8 gateway 192.168.1.1 hide",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				if !routes[0].NextHops[0].Hide {
					t.Errorf("Hide = %v, want true", routes[0].NextHops[0].Hide)
				}
			},
		},
		{
			name: "route_via_pp",
			rtx:  "ip route default gateway pp 1",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				if routes[0].NextHops[0].Interface != "pp 1" {
					t.Errorf("Interface = %v, want pp 1", routes[0].NextHops[0].Interface)
				}
			},
		},
		{
			name: "route_via_tunnel",
			rtx:  "ip route 10.0.0.0/8 gateway tunnel 1",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				if routes[0].NextHops[0].Interface != "tunnel 1" {
					t.Errorf("Interface = %v, want tunnel 1", routes[0].NextHops[0].Interface)
				}
			},
		},
		{
			name: "route_ecmp",
			rtx:  "ip route default gateway 192.168.1.1 gateway 192.168.1.2",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				if len(routes[0].NextHops) != 2 {
					t.Errorf("NextHops count = %v, want 2", len(routes[0].NextHops))
					return
				}
				if routes[0].NextHops[0].NextHop != "192.168.1.1" {
					t.Errorf("NextHops[0] = %v, want 192.168.1.1", routes[0].NextHops[0].NextHop)
				}
				if routes[0].NextHops[1].NextHop != "192.168.1.2" {
					t.Errorf("NextHops[1] = %v, want 192.168.1.2", routes[0].NextHops[1].NextHop)
				}
			},
		},
		{
			name: "route_keepalive",
			rtx:  "ip route 10.0.0.0/8 gateway 192.168.1.1 keepalive 1",
			checkFunc: func(t *testing.T, routes []StaticRoute) {
				if len(routes) != 1 {
					t.Errorf("Routes count = %v, want 1", len(routes))
					return
				}
				if routes[0].NextHops[0].KeepaliveID != 1 {
					t.Errorf("KeepaliveID = %v, want 1", routes[0].NextHops[0].KeepaliveID)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			routes, err := parser.ParseRouteConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseRouteConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, routes)
		})
	}
}

// TestStaticRouteRoundTrip_Build tests Terraform value -> RTX command conversion
func TestStaticRouteRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "default_route",
			buildFunc: func() string {
				return BuildIPRouteCommand(
					StaticRoute{Prefix: "0.0.0.0", Mask: "0.0.0.0"},
					NextHop{NextHop: "192.168.1.1", Distance: 1},
				)
			},
			expectedRTX: "ip route default gateway 192.168.1.1",
		},
		{
			name: "network_route_cidr",
			buildFunc: func() string {
				return BuildIPRouteCommand(
					StaticRoute{Prefix: "10.0.0.0", Mask: "255.0.0.0"},
					NextHop{NextHop: "192.168.1.1", Distance: 1},
				)
			},
			expectedRTX: "ip route 10.0.0.0/8 gateway 192.168.1.1",
		},
		{
			name: "route_with_weight",
			buildFunc: func() string {
				return BuildIPRouteCommand(
					StaticRoute{Prefix: "10.0.0.0", Mask: "255.0.0.0"},
					NextHop{NextHop: "192.168.1.1", Distance: 10},
				)
			},
			expectedRTX: "ip route 10.0.0.0/8 gateway 192.168.1.1 weight 10",
		},
		{
			name: "route_with_filter",
			buildFunc: func() string {
				return BuildIPRouteCommand(
					StaticRoute{Prefix: "10.0.0.0", Mask: "255.0.0.0"},
					NextHop{NextHop: "192.168.1.1", Distance: 1, Filter: 100},
				)
			},
			expectedRTX: "ip route 10.0.0.0/8 gateway 192.168.1.1 filter 100",
		},
		{
			name: "route_with_hide",
			buildFunc: func() string {
				return BuildIPRouteCommand(
					StaticRoute{Prefix: "10.0.0.0", Mask: "255.0.0.0"},
					NextHop{NextHop: "192.168.1.1", Distance: 1, Hide: true},
				)
			},
			expectedRTX: "ip route 10.0.0.0/8 gateway 192.168.1.1 hide",
		},
		{
			name: "route_via_pp",
			buildFunc: func() string {
				return BuildIPRouteCommand(
					StaticRoute{Prefix: "0.0.0.0", Mask: "0.0.0.0"},
					NextHop{Interface: "pp 1", Distance: 1},
				)
			},
			expectedRTX: "ip route default gateway pp 1",
		},
		{
			name: "route_via_tunnel",
			buildFunc: func() string {
				return BuildIPRouteCommand(
					StaticRoute{Prefix: "10.0.0.0", Mask: "255.0.0.0"},
					NextHop{Interface: "tunnel 1", Distance: 1},
				)
			},
			expectedRTX: "ip route 10.0.0.0/8 gateway tunnel 1",
		},
		{
			name: "route_ecmp",
			buildFunc: func() string {
				return BuildIPRouteCommandMultiHop(StaticRoute{
					Prefix: "0.0.0.0",
					Mask:   "0.0.0.0",
					NextHops: []NextHop{
						{NextHop: "192.168.1.1", Distance: 1},
						{NextHop: "192.168.1.2", Distance: 1},
					},
				})
			},
			expectedRTX: "ip route default gateway 192.168.1.1 gateway 192.168.1.2",
		},
		{
			name: "route_keepalive",
			buildFunc: func() string {
				return BuildIPRouteCommand(
					StaticRoute{Prefix: "10.0.0.0", Mask: "255.0.0.0"},
					NextHop{NextHop: "192.168.1.1", Distance: 1, KeepaliveID: 1},
				)
			},
			expectedRTX: "ip route 10.0.0.0/8 gateway 192.168.1.1 keepalive 1",
		},
		{
			name: "delete_route",
			buildFunc: func() string {
				return BuildDeleteIPRouteCommand("10.0.0.0", "255.0.0.0", nil)
			},
			expectedRTX: "no ip route 10.0.0.0/8",
		},
		{
			name: "delete_route_with_gateway",
			buildFunc: func() string {
				hop := NextHop{NextHop: "192.168.1.1"}
				return BuildDeleteIPRouteCommand("10.0.0.0", "255.0.0.0", &hop)
			},
			expectedRTX: "no ip route 10.0.0.0/8 gateway 192.168.1.1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestStaticRouteRoundTrip_ParseBuildParse tests full round-trip
func TestStaticRouteRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewStaticRouteParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "default_route",
			rtx:  "ip route default gateway 192.168.1.1",
		},
		{
			name: "network_route",
			rtx:  "ip route 10.0.0.0/8 gateway 192.168.1.1",
		},
		{
			name: "route_via_pp",
			rtx:  "ip route default gateway pp 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			routes, err := parser.ParseRouteConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseRouteConfig(%q) error = %v", tc.rtx, err)
			}
			if len(routes) != 1 {
				t.Fatalf("Expected 1 route, got %d", len(routes))
			}
			route := routes[0]

			// Step 2: Build back to RTX command
			var rebuiltRTX string
			if len(route.NextHops) == 1 {
				rebuiltRTX = BuildIPRouteCommand(route, route.NextHops[0])
			} else {
				rebuiltRTX = BuildIPRouteCommandMultiHop(route)
			}

			// Step 3: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}

			// Step 4: Parse the rebuilt command
			routes2, err := parser.ParseRouteConfig(rebuiltRTX)
			if err != nil {
				t.Fatalf("ParseRouteConfig(%q) error = %v", rebuiltRTX, err)
			}
			if len(routes2) != 1 {
				t.Fatalf("Expected 1 route, got %d", len(routes2))
			}
			route2 := routes2[0]

			// Verify key fields match
			if route.Prefix != route2.Prefix {
				t.Errorf("Prefix mismatch: %v != %v", route.Prefix, route2.Prefix)
			}
			if route.Mask != route2.Mask {
				t.Errorf("Mask mismatch: %v != %v", route.Mask, route2.Mask)
			}
			if len(route.NextHops) != len(route2.NextHops) {
				t.Errorf("NextHops count mismatch: %v != %v", len(route.NextHops), len(route2.NextHops))
			}
		})
	}
}
