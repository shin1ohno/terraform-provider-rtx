// Code generated by specgen. DO NOT EDIT.
// Source: specs/bgp/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestBGPRoundTrip_Parse tests RTX command -> Terraform value conversion
// using the actual BGPParser
func TestBGPRoundTrip_Parse(t *testing.T) {
	parser := NewBGPParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *BGPConfig)
	}{
		{
			name: "bgp_use_on",
			rtx:  "bgp use on",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if config.Enabled != true {
					t.Errorf("Enabled = %v, want %v", config.Enabled, true)
				}
			},
		},
		{
			name: "bgp_use_off",
			rtx:  "bgp use off",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if config.Enabled != false {
					t.Errorf("Enabled = %v, want %v", config.Enabled, false)
				}
			},
		},
		{
			name: "bgp_asn_2byte",
			rtx:  "bgp autonomous-system 65001",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if config.ASN != "65001" {
					t.Errorf("ASN = %v, want %v", config.ASN, "65001")
				}
			},
		},
		{
			name: "bgp_asn_min",
			rtx:  "bgp autonomous-system 100",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if config.ASN != "100" {
					t.Errorf("ASN = %v, want %v", config.ASN, "100")
				}
			},
		},
		{
			name: "bgp_router_id",
			rtx:  "bgp router id 192.168.1.1",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if config.RouterID != "192.168.1.1" {
					t.Errorf("RouterID = %v, want %v", config.RouterID, "192.168.1.1")
				}
			},
		},
		{
			name: "bgp_router_id_loopback",
			rtx:  "bgp router id 10.0.0.1",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if config.RouterID != "10.0.0.1" {
					t.Errorf("RouterID = %v, want %v", config.RouterID, "10.0.0.1")
				}
			},
		},
		{
			// Reference: bgp neighbor <n> <as> <ip>
			name: "bgp_neighbor",
			rtx:  "bgp neighbor 1 65002 203.0.113.1",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if len(config.Neighbors) != 1 {
					t.Errorf("Neighbors count = %v, want 1", len(config.Neighbors))
					return
				}
				n := config.Neighbors[0]
				if n.ID != 1 {
					t.Errorf("Neighbor ID = %v, want 1", n.ID)
				}
				if n.IP != "203.0.113.1" {
					t.Errorf("Neighbor IP = %v, want 203.0.113.1", n.IP)
				}
				if n.RemoteAS != "65002" {
					t.Errorf("Neighbor RemoteAS = %v, want 65002", n.RemoteAS)
				}
			},
		},
		{
			name: "bgp_neighbor_second",
			rtx:  "bgp neighbor 2 65003 203.0.113.2",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if len(config.Neighbors) != 1 {
					t.Errorf("Neighbors count = %v, want 1", len(config.Neighbors))
					return
				}
				n := config.Neighbors[0]
				if n.ID != 2 {
					t.Errorf("Neighbor ID = %v, want 2", n.ID)
				}
				if n.IP != "203.0.113.2" {
					t.Errorf("Neighbor IP = %v, want 203.0.113.2", n.IP)
				}
				if n.RemoteAS != "65003" {
					t.Errorf("Neighbor RemoteAS = %v, want 65003", n.RemoteAS)
				}
			},
		},
		{
			// Reference: bgp neighbor <n> <as> <ip> hold-time=<sec>
			name: "bgp_neighbor_holdtime",
			rtx:  "bgp neighbor 1 65002 192.168.1.2 hold-time=90",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if len(config.Neighbors) != 1 {
					t.Errorf("Neighbors count = %v, want 1", len(config.Neighbors))
					return
				}
				n := config.Neighbors[0]
				if n.ID != 1 {
					t.Errorf("Neighbor ID = %v, want 1", n.ID)
				}
				if n.RemoteAS != "65002" {
					t.Errorf("Neighbor RemoteAS = %v, want 65002", n.RemoteAS)
				}
				if n.IP != "192.168.1.2" {
					t.Errorf("Neighbor IP = %v, want 192.168.1.2", n.IP)
				}
				if n.HoldTime != 90 {
					t.Errorf("Neighbor HoldTime = %v, want 90", n.HoldTime)
				}
			},
		},
		{
			// Reference: bgp neighbor <n> <as> <ip> local-address=<ip>
			name: "bgp_neighbor_local_address",
			rtx:  "bgp neighbor 1 65002 192.168.1.2 local-address=192.168.1.1",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if len(config.Neighbors) != 1 {
					t.Errorf("Neighbors count = %v, want 1", len(config.Neighbors))
					return
				}
				n := config.Neighbors[0]
				if n.LocalAddress != "192.168.1.1" {
					t.Errorf("Neighbor LocalAddress = %v, want 192.168.1.1", n.LocalAddress)
				}
			},
		},
		{
			// Reference: bgp neighbor <n> <as> <ip> passive=on
			name: "bgp_neighbor_passive",
			rtx:  "bgp neighbor 1 65002 192.168.1.2 passive=on",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if len(config.Neighbors) != 1 {
					t.Errorf("Neighbors count = %v, want 1", len(config.Neighbors))
					return
				}
				n := config.Neighbors[0]
				if n.Passive != true {
					t.Errorf("Neighbor Passive = %v, want true", n.Passive)
				}
			},
		},
		{
			// Reference: bgp neighbor pre-shared-key <n> text <password>
			name: "bgp_neighbor_preshared_key",
			rtx:  "bgp neighbor pre-shared-key 1 text mysecret",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if len(config.Neighbors) != 1 {
					t.Errorf("Neighbors count = %v, want 1", len(config.Neighbors))
					return
				}
				n := config.Neighbors[0]
				if n.ID != 1 {
					t.Errorf("Neighbor ID = %v, want 1", n.ID)
				}
				if n.Password != "mysecret" {
					t.Errorf("Neighbor Password = %v, want mysecret", n.Password)
				}
			},
		},
		{
			// Reference: bgp import filter <n> include <prefix>/<cidr>
			name: "bgp_network",
			rtx:  "bgp import filter 1 include 192.168.0.0/16",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if len(config.Networks) != 1 {
					t.Errorf("Networks count = %v, want 1", len(config.Networks))
					return
				}
				n := config.Networks[0]
				if n.Prefix != "192.168.0.0" {
					t.Errorf("Network Prefix = %v, want 192.168.0.0", n.Prefix)
				}
				if n.Mask != "255.255.0.0" {
					t.Errorf("Network Mask = %v, want 255.255.0.0", n.Mask)
				}
			},
		},
		{
			name: "bgp_network_24",
			rtx:  "bgp import filter 1 include 10.0.0.0/24",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if len(config.Networks) != 1 {
					t.Errorf("Networks count = %v, want 1", len(config.Networks))
					return
				}
				n := config.Networks[0]
				if n.Prefix != "10.0.0.0" {
					t.Errorf("Network Prefix = %v, want 10.0.0.0", n.Prefix)
				}
				if n.Mask != "255.255.255.0" {
					t.Errorf("Network Mask = %v, want 255.255.255.0", n.Mask)
				}
			},
		},
		{
			name: "bgp_import_static",
			rtx:  "bgp import from static",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if config.RedistributeStatic != true {
					t.Errorf("RedistributeStatic = %v, want true", config.RedistributeStatic)
				}
			},
		},
		{
			name: "bgp_import_connected",
			rtx:  "bgp import from connected",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				if config.RedistributeConnected != true {
					t.Errorf("RedistributeConnected = %v, want true", config.RedistributeConnected)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseBGPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseBGPConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestBGPRoundTrip_Build tests Terraform value -> RTX command conversion
// using the actual Build* functions
func TestBGPRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "bgp_use_on",
			buildFunc: func() string {
				return BuildBGPUseCommand(true)
			},
			expectedRTX: "bgp use on",
		},
		{
			name: "bgp_use_off",
			buildFunc: func() string {
				return BuildBGPUseCommand(false)
			},
			expectedRTX: "bgp use off",
		},
		{
			name: "bgp_asn_2byte",
			buildFunc: func() string {
				return BuildBGPASNCommand("65001")
			},
			expectedRTX: "bgp autonomous-system 65001",
		},
		{
			name: "bgp_router_id",
			buildFunc: func() string {
				return BuildBGPRouterIDCommand("192.168.1.1")
			},
			expectedRTX: "bgp router id 192.168.1.1",
		},
		{
			// Reference: bgp neighbor <n> <as> <ip>
			name: "bgp_neighbor",
			buildFunc: func() string {
				return BuildBGPNeighborCommand(BGPNeighbor{
					ID:       1,
					IP:       "203.0.113.1",
					RemoteAS: "65002",
				})
			},
			expectedRTX: "bgp neighbor 1 65002 203.0.113.1",
		},
		{
			// Reference: bgp neighbor <n> <as> <ip> hold-time=<sec>
			name: "bgp_neighbor_holdtime",
			buildFunc: func() string {
				return BuildBGPNeighborCommand(BGPNeighbor{
					ID:       1,
					IP:       "192.168.1.2",
					RemoteAS: "65002",
					HoldTime: 90,
				})
			},
			expectedRTX: "bgp neighbor 1 65002 192.168.1.2 hold-time=90",
		},
		{
			// Reference: bgp neighbor <n> <as> <ip> local-address=<ip>
			name: "bgp_neighbor_local_address",
			buildFunc: func() string {
				return BuildBGPNeighborCommand(BGPNeighbor{
					ID:           1,
					IP:           "192.168.1.2",
					RemoteAS:     "65002",
					LocalAddress: "192.168.1.1",
				})
			},
			expectedRTX: "bgp neighbor 1 65002 192.168.1.2 local-address=192.168.1.1",
		},
		{
			// Reference: bgp neighbor <n> <as> <ip> passive=on
			name: "bgp_neighbor_passive",
			buildFunc: func() string {
				return BuildBGPNeighborCommand(BGPNeighbor{
					ID:       1,
					IP:       "192.168.1.2",
					RemoteAS: "65002",
					Passive:  true,
				})
			},
			expectedRTX: "bgp neighbor 1 65002 192.168.1.2 passive=on",
		},
		{
			// Reference: bgp neighbor pre-shared-key <n> text <password>
			name: "bgp_neighbor_preshared_key",
			buildFunc: func() string {
				return BuildBGPNeighborPreSharedKeyCommand(1, "mysecret")
			},
			expectedRTX: "bgp neighbor pre-shared-key 1 text mysecret",
		},
		{
			// Backward compatibility alias
			name: "bgp_neighbor_password",
			buildFunc: func() string {
				return BuildBGPNeighborPasswordCommand(1, "mysecret")
			},
			expectedRTX: "bgp neighbor pre-shared-key 1 text mysecret",
		},
		{
			// Reference: bgp import filter <n> include <prefix>/<cidr>
			name: "bgp_network",
			buildFunc: func() string {
				return BuildBGPNetworkCommand(1, BGPNetwork{
					Prefix: "192.168.0.0",
					Mask:   "255.255.0.0",
				})
			},
			expectedRTX: "bgp import filter 1 include 192.168.0.0/16",
		},
		{
			name: "bgp_network_24",
			buildFunc: func() string {
				return BuildBGPNetworkCommand(1, BGPNetwork{
					Prefix: "10.0.0.0",
					Mask:   "255.255.255.0",
				})
			},
			expectedRTX: "bgp import filter 1 include 10.0.0.0/24",
		},
		{
			name: "bgp_import_static",
			buildFunc: func() string {
				return BuildBGPRedistributeCommand("static")
			},
			expectedRTX: "bgp import from static",
		},
		{
			name: "bgp_import_connected",
			buildFunc: func() string {
				return BuildBGPRedistributeCommand("connected")
			},
			expectedRTX: "bgp import from connected",
		},
		{
			name: "delete_bgp_neighbor",
			buildFunc: func() string {
				return BuildDeleteBGPNeighborCommand(1)
			},
			expectedRTX: "no bgp neighbor 1",
		},
		{
			name: "delete_bgp_network",
			buildFunc: func() string {
				return BuildDeleteBGPNetworkCommand(1)
			},
			expectedRTX: "no bgp import filter 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestBGPRoundTrip_ParseBuildParse tests full round-trip:
// RTX command -> Parse -> Build -> RTX command (should match original)
func TestBGPRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewBGPParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "bgp_use_on",
			rtx:  "bgp use on",
		},
		{
			name: "bgp_use_off",
			rtx:  "bgp use off",
		},
		{
			name: "bgp_asn",
			rtx:  "bgp autonomous-system 65001",
		},
		{
			name: "bgp_router_id",
			rtx:  "bgp router id 192.168.1.1",
		},
		{
			name: "bgp_import_static",
			rtx:  "bgp import from static",
		},
		{
			name: "bgp_import_connected",
			rtx:  "bgp import from connected",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			config, err := parser.ParseBGPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseBGPConfig(%q) error = %v", tc.rtx, err)
			}

			// Step 2: Build back to RTX command
			var rebuiltRTX string
			switch {
			case tc.name == "bgp_use_on" || tc.name == "bgp_use_off":
				rebuiltRTX = BuildBGPUseCommand(config.Enabled)
			case tc.name == "bgp_asn":
				rebuiltRTX = BuildBGPASNCommand(config.ASN)
			case tc.name == "bgp_router_id":
				rebuiltRTX = BuildBGPRouterIDCommand(config.RouterID)
			case tc.name == "bgp_import_static":
				rebuiltRTX = BuildBGPRedistributeCommand("static")
			case tc.name == "bgp_import_connected":
				rebuiltRTX = BuildBGPRedistributeCommand("connected")
			default:
				t.Fatalf("Unknown test case: %s", tc.name)
			}

			// Step 3: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}

			// Step 4: Parse the rebuilt command and verify it produces the same config
			config2, err := parser.ParseBGPConfig(rebuiltRTX)
			if err != nil {
				t.Fatalf("ParseBGPConfig(%q) error = %v", rebuiltRTX, err)
			}

			// Verify key fields match
			if config.Enabled != config2.Enabled {
				t.Errorf("Enabled mismatch: %v != %v", config.Enabled, config2.Enabled)
			}
			if config.ASN != config2.ASN {
				t.Errorf("ASN mismatch: %v != %v", config.ASN, config2.ASN)
			}
			if config.RouterID != config2.RouterID {
				t.Errorf("RouterID mismatch: %v != %v", config.RouterID, config2.RouterID)
			}
			if config.RedistributeStatic != config2.RedistributeStatic {
				t.Errorf("RedistributeStatic mismatch: %v != %v", config.RedistributeStatic, config2.RedistributeStatic)
			}
			if config.RedistributeConnected != config2.RedistributeConnected {
				t.Errorf("RedistributeConnected mismatch: %v != %v", config.RedistributeConnected, config2.RedistributeConnected)
			}
		})
	}
}
