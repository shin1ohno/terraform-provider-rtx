// Code generated by specgen. DO NOT EDIT.
// Source: specs/bgp/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestBGPRoundTrip_Parse tests RTX command -> Terraform value conversion
// using the actual BGPParser
func TestBGPRoundTrip_Parse(t *testing.T) {
	parser := NewBGPParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *BGPConfig)
	}{
		{
			name: "bgp_use_on",
			rtx:  "bgp use on",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: enabled: true
				if config.Enabled != true {
					t.Errorf("Enabled = %v, want %v", config.Enabled, true)
				}
			},
		},
		{
			name: "bgp_use_off",
			rtx:  "bgp use off",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: enabled: false
				if config.Enabled != false {
					t.Errorf("Enabled = %v, want %v", config.Enabled, false)
				}
			},
		},
		{
			name: "bgp_asn_2byte",
			rtx:  "bgp autonomous-system 65001",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: asn: "65001"
				if config.ASN != "65001" {
					t.Errorf("ASN = %v, want %v", config.ASN, "65001")
				}
			},
		},
		{
			name: "bgp_asn_4byte",
			rtx:  "bgp autonomous-system 4200000001",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: asn: "4200000001"
				if config.ASN != "4200000001" {
					t.Errorf("ASN = %v, want %v", config.ASN, "4200000001")
				}
			},
		},
		{
			name: "bgp_router_id",
			rtx:  "bgp router id 192.168.1.1",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: router_id: "192.168.1.1"
				if config.RouterID != "192.168.1.1" {
					t.Errorf("RouterID = %v, want %v", config.RouterID, "192.168.1.1")
				}
			},
		},
		{
			name: "bgp_neighbor",
			rtx:  "bgp neighbor 1 address 203.0.113.1 as 65002",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: neighbors[0]: id=1, ip="203.0.113.1", remote_as="65002"
				if len(config.Neighbors) != 1 {
					t.Errorf("Neighbors count = %v, want 1", len(config.Neighbors))
					return
				}
				n := config.Neighbors[0]
				if n.ID != 1 {
					t.Errorf("Neighbor ID = %v, want 1", n.ID)
				}
				if n.IP != "203.0.113.1" {
					t.Errorf("Neighbor IP = %v, want 203.0.113.1", n.IP)
				}
				if n.RemoteAS != "65002" {
					t.Errorf("Neighbor RemoteAS = %v, want 65002", n.RemoteAS)
				}
			},
		},
		{
			name: "bgp_neighbor_holdtime",
			rtx:  "bgp neighbor 1 hold-time 90",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: neighbors[0]: id=1, hold_time=90
				if len(config.Neighbors) != 1 {
					t.Errorf("Neighbors count = %v, want 1", len(config.Neighbors))
					return
				}
				if config.Neighbors[0].HoldTime != 90 {
					t.Errorf("Neighbor HoldTime = %v, want 90", config.Neighbors[0].HoldTime)
				}
			},
		},
		{
			name: "bgp_import_static",
			rtx:  "bgp import from static",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: redistribute_static: true
				if config.RedistributeStatic != true {
					t.Errorf("RedistributeStatic = %v, want true", config.RedistributeStatic)
				}
			},
		},
		{
			name: "bgp_import_connected",
			rtx:  "bgp import from connected",
			checkFunc: func(t *testing.T, config *BGPConfig) {
				// Expected terraform: redistribute_connected: true
				if config.RedistributeConnected != true {
					t.Errorf("RedistributeConnected = %v, want true", config.RedistributeConnected)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseBGPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseBGPConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestBGPRoundTrip_Build tests Terraform value -> RTX command conversion
// using the actual Build* functions
func TestBGPRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "bgp_use_on",
			buildFunc: func() string {
				return BuildBGPUseCommand(true)
			},
			expectedRTX: "bgp use on",
		},
		{
			name: "bgp_use_off",
			buildFunc: func() string {
				return BuildBGPUseCommand(false)
			},
			expectedRTX: "bgp use off",
		},
		{
			name: "bgp_asn_2byte",
			buildFunc: func() string {
				return BuildBGPASNCommand("65001")
			},
			expectedRTX: "bgp autonomous-system 65001",
		},
		{
			name: "bgp_asn_4byte",
			buildFunc: func() string {
				return BuildBGPASNCommand("4200000001")
			},
			expectedRTX: "bgp autonomous-system 4200000001",
		},
		{
			name: "bgp_router_id",
			buildFunc: func() string {
				return BuildBGPRouterIDCommand("192.168.1.1")
			},
			expectedRTX: "bgp router id 192.168.1.1",
		},
		{
			name: "bgp_neighbor",
			buildFunc: func() string {
				return BuildBGPNeighborCommand(BGPNeighbor{
					ID:       1,
					IP:       "203.0.113.1",
					RemoteAS: "65002",
				})
			},
			expectedRTX: "bgp neighbor 1 address 203.0.113.1 as 65002",
		},
		{
			name: "bgp_neighbor_holdtime",
			buildFunc: func() string {
				return BuildBGPNeighborHoldTimeCommand(1, 90)
			},
			expectedRTX: "bgp neighbor 1 hold-time 90",
		},
		{
			name: "bgp_neighbor_keepalive",
			buildFunc: func() string {
				return BuildBGPNeighborKeepaliveCommand(1, 30)
			},
			expectedRTX: "bgp neighbor 1 keepalive 30",
		},
		{
			name: "bgp_neighbor_multihop",
			buildFunc: func() string {
				return BuildBGPNeighborMultihopCommand(1, 2)
			},
			expectedRTX: "bgp neighbor 1 multihop 2",
		},
		{
			name: "bgp_neighbor_password",
			buildFunc: func() string {
				return BuildBGPNeighborPasswordCommand(1, "mysecret")
			},
			expectedRTX: "bgp neighbor 1 password mysecret",
		},
		{
			name: "bgp_neighbor_local_address",
			buildFunc: func() string {
				return BuildBGPNeighborLocalAddressCommand(1, "192.168.1.1")
			},
			expectedRTX: "bgp neighbor 1 local-address 192.168.1.1",
		},
		{
			name: "bgp_import_static",
			buildFunc: func() string {
				return BuildBGPRedistributeCommand("static")
			},
			expectedRTX: "bgp import from static",
		},
		{
			name: "bgp_import_connected",
			buildFunc: func() string {
				return BuildBGPRedistributeCommand("connected")
			},
			expectedRTX: "bgp import from connected",
		},
		{
			name: "delete_bgp_neighbor",
			buildFunc: func() string {
				return BuildDeleteBGPNeighborCommand(1)
			},
			expectedRTX: "no bgp neighbor 1",
		},
		{
			name: "delete_bgp_network",
			buildFunc: func() string {
				return BuildDeleteBGPNetworkCommand(1)
			},
			expectedRTX: "no bgp import filter 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestBGPRoundTrip_ParseBuildParse tests full round-trip:
// RTX command -> Parse -> Build -> RTX command (should match original)
func TestBGPRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewBGPParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "bgp_use_on",
			rtx:  "bgp use on",
		},
		{
			name: "bgp_use_off",
			rtx:  "bgp use off",
		},
		{
			name: "bgp_asn",
			rtx:  "bgp autonomous-system 65001",
		},
		{
			name: "bgp_router_id",
			rtx:  "bgp router id 192.168.1.1",
		},
		{
			name: "bgp_import_static",
			rtx:  "bgp import from static",
		},
		{
			name: "bgp_import_connected",
			rtx:  "bgp import from connected",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			config, err := parser.ParseBGPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseBGPConfig(%q) error = %v", tc.rtx, err)
			}

			// Step 2: Build back to RTX command
			var rebuiltRTX string
			switch {
			case tc.name == "bgp_use_on" || tc.name == "bgp_use_off":
				rebuiltRTX = BuildBGPUseCommand(config.Enabled)
			case tc.name == "bgp_asn":
				rebuiltRTX = BuildBGPASNCommand(config.ASN)
			case tc.name == "bgp_router_id":
				rebuiltRTX = BuildBGPRouterIDCommand(config.RouterID)
			case tc.name == "bgp_import_static":
				rebuiltRTX = BuildBGPRedistributeCommand("static")
			case tc.name == "bgp_import_connected":
				rebuiltRTX = BuildBGPRedistributeCommand("connected")
			default:
				t.Fatalf("Unknown test case: %s", tc.name)
			}

			// Step 3: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}

			// Step 4: Parse the rebuilt command and verify it produces the same config
			config2, err := parser.ParseBGPConfig(rebuiltRTX)
			if err != nil {
				t.Fatalf("ParseBGPConfig(%q) error = %v", rebuiltRTX, err)
			}

			// Verify key fields match
			if config.Enabled != config2.Enabled {
				t.Errorf("Enabled mismatch: %v != %v", config.Enabled, config2.Enabled)
			}
			if config.ASN != config2.ASN {
				t.Errorf("ASN mismatch: %v != %v", config.ASN, config2.ASN)
			}
			if config.RouterID != config2.RouterID {
				t.Errorf("RouterID mismatch: %v != %v", config.RouterID, config2.RouterID)
			}
			if config.RedistributeStatic != config2.RedistributeStatic {
				t.Errorf("RedistributeStatic mismatch: %v != %v", config.RedistributeStatic, config2.RedistributeStatic)
			}
			if config.RedistributeConnected != config2.RedistributeConnected {
				t.Errorf("RedistributeConnected mismatch: %v != %v", config.RedistributeConnected, config2.RedistributeConnected)
			}
		})
	}
}
