// Code generated by specgen. DO NOT EDIT.
// Source: specs/nat_static/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestNATStaticRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestNATStaticRoundTrip_Parse(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, descriptors []NATStatic)
	}{
		{
			name: "nat_descriptor_type",
			rtx:  "nat descriptor type 1000 static",
			checkFunc: func(t *testing.T, descriptors []NATStatic) {
				if len(descriptors) != 1 {
					t.Errorf("Descriptors count = %v, want 1", len(descriptors))
					return
				}
				if descriptors[0].DescriptorID != 1000 {
					t.Errorf("DescriptorID = %v, want 1000", descriptors[0].DescriptorID)
				}
			},
		},
		{
			name: "static_1to1_mapping",
			rtx: `nat descriptor type 1000 static
nat descriptor static 1000 203.0.113.1=192.168.1.1`,
			checkFunc: func(t *testing.T, descriptors []NATStatic) {
				if len(descriptors) != 1 {
					t.Errorf("Descriptors count = %v, want 1", len(descriptors))
					return
				}
				d := descriptors[0]
				if len(d.Entries) != 1 {
					t.Errorf("Entries count = %v, want 1", len(d.Entries))
					return
				}
				e := d.Entries[0]
				if e.OutsideGlobal != "203.0.113.1" {
					t.Errorf("OutsideGlobal = %v, want 203.0.113.1", e.OutsideGlobal)
				}
				if e.InsideLocal != "192.168.1.1" {
					t.Errorf("InsideLocal = %v, want 192.168.1.1", e.InsideLocal)
				}
			},
		},
		{
			name: "static_port_mapping",
			rtx: `nat descriptor type 1000 static
nat descriptor static 1000 203.0.113.1:80=192.168.1.1:8080 tcp`,
			checkFunc: func(t *testing.T, descriptors []NATStatic) {
				if len(descriptors) != 1 {
					t.Errorf("Descriptors count = %v, want 1", len(descriptors))
					return
				}
				d := descriptors[0]
				if len(d.Entries) != 1 {
					t.Errorf("Entries count = %v, want 1", len(d.Entries))
					return
				}
				e := d.Entries[0]
				if e.OutsideGlobal != "203.0.113.1" {
					t.Errorf("OutsideGlobal = %v, want 203.0.113.1", e.OutsideGlobal)
				}
				if e.OutsideGlobalPort != 80 {
					t.Errorf("OutsideGlobalPort = %v, want 80", e.OutsideGlobalPort)
				}
				if e.InsideLocal != "192.168.1.1" {
					t.Errorf("InsideLocal = %v, want 192.168.1.1", e.InsideLocal)
				}
				if e.InsideLocalPort != 8080 {
					t.Errorf("InsideLocalPort = %v, want 8080", e.InsideLocalPort)
				}
				if e.Protocol != "tcp" {
					t.Errorf("Protocol = %v, want tcp", e.Protocol)
				}
			},
		},
		{
			name: "multiple_mappings",
			rtx: `nat descriptor type 1000 static
nat descriptor static 1000 203.0.113.1=192.168.1.1
nat descriptor static 1000 203.0.113.2=192.168.1.2`,
			checkFunc: func(t *testing.T, descriptors []NATStatic) {
				if len(descriptors) != 1 {
					t.Errorf("Descriptors count = %v, want 1", len(descriptors))
					return
				}
				if len(descriptors[0].Entries) != 2 {
					t.Errorf("Entries count = %v, want 2", len(descriptors[0].Entries))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			descriptors, err := ParseNATStaticConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseNATStaticConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, descriptors)
		})
	}
}

// TestNATStaticRoundTrip_Build tests Terraform value -> RTX command conversion
func TestNATStaticRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "nat_descriptor_type_static",
			buildFunc: func() string {
				return BuildNATDescriptorTypeStaticCommand(1000)
			},
			expectedRTX: "nat descriptor type 1000 static",
		},
		{
			name: "static_1to1_mapping",
			buildFunc: func() string {
				return BuildNATStaticMappingCommand(1000, NATStaticEntry{
					OutsideGlobal: "203.0.113.1",
					InsideLocal:   "192.168.1.1",
				})
			},
			expectedRTX: "nat descriptor static 1000 203.0.113.1=192.168.1.1",
		},
		{
			name: "static_port_mapping",
			buildFunc: func() string {
				return BuildNATStaticPortMappingCommand(1000, NATStaticEntry{
					OutsideGlobal:     "203.0.113.1",
					OutsideGlobalPort: 80,
					InsideLocal:       "192.168.1.1",
					InsideLocalPort:   8080,
					Protocol:          "tcp",
				})
			},
			expectedRTX: "nat descriptor static 1000 203.0.113.1:80=192.168.1.1:8080 tcp",
		},
		{
			name: "delete_nat_descriptor",
			buildFunc: func() string {
				return BuildDeleteNATStaticCommand(1000)
			},
			expectedRTX: "no nat descriptor type 1000",
		},
		{
			name: "delete_nat_mapping",
			buildFunc: func() string {
				return BuildDeleteNATStaticMappingCommand(1000, NATStaticEntry{
					OutsideGlobal: "203.0.113.1",
					InsideLocal:   "192.168.1.1",
				})
			},
			expectedRTX: "no nat descriptor static 1000 203.0.113.1=192.168.1.1",
		},
		{
			name: "interface_nat",
			buildFunc: func() string {
				return BuildInterfaceNATCommand("pp1", 1000)
			},
			expectedRTX: "ip pp1 nat descriptor 1000",
		},
		{
			name: "delete_interface_nat",
			buildFunc: func() string {
				return BuildDeleteInterfaceNATCommand("pp1", 1000)
			},
			expectedRTX: "no ip pp1 nat descriptor 1000",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestNATStaticRoundTrip_BuildCommands tests full command building
func TestNATStaticRoundTrip_BuildCommands(t *testing.T) {
	nat := NATStatic{
		DescriptorID: 1000,
		Entries: []NATStaticEntry{
			{
				OutsideGlobal: "203.0.113.1",
				InsideLocal:   "192.168.1.1",
			},
			{
				OutsideGlobal:     "203.0.113.2",
				OutsideGlobalPort: 80,
				InsideLocal:       "192.168.1.2",
				InsideLocalPort:   8080,
				Protocol:          "tcp",
			},
		},
	}

	commands := BuildNATStaticCommands(nat)

	if len(commands) < 3 {
		t.Errorf("Expected at least 3 commands, got %d", len(commands))
		return
	}

	// First command should be descriptor type
	if commands[0] != "nat descriptor type 1000 static" {
		t.Errorf("First command = %q, want 'nat descriptor type 1000 static'", commands[0])
	}
}

// TestNATStaticRoundTrip_Validation tests NAT static validation functions
func TestNATStaticRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		entry     NATStaticEntry
		wantError bool
	}{
		{
			name: "valid_1to1_entry",
			entry: NATStaticEntry{
				OutsideGlobal: "203.0.113.1",
				InsideLocal:   "192.168.1.1",
			},
			wantError: false,
		},
		{
			name: "valid_port_entry",
			entry: NATStaticEntry{
				OutsideGlobal:     "203.0.113.1",
				OutsideGlobalPort: 80,
				InsideLocal:       "192.168.1.1",
				InsideLocalPort:   8080,
				Protocol:          "tcp",
			},
			wantError: false,
		},
		{
			name: "missing_inside_local",
			entry: NATStaticEntry{
				OutsideGlobal: "203.0.113.1",
			},
			wantError: true,
		},
		{
			name: "missing_outside_global",
			entry: NATStaticEntry{
				InsideLocal: "192.168.1.1",
			},
			wantError: true,
		},
		{
			name: "invalid_inside_local_ip",
			entry: NATStaticEntry{
				OutsideGlobal: "203.0.113.1",
				InsideLocal:   "invalid",
			},
			wantError: true,
		},
		{
			name: "port_nat_missing_inside_port",
			entry: NATStaticEntry{
				OutsideGlobal:     "203.0.113.1",
				OutsideGlobalPort: 80,
				InsideLocal:       "192.168.1.1",
				Protocol:          "tcp",
			},
			wantError: true,
		},
		{
			name: "port_nat_missing_protocol",
			entry: NATStaticEntry{
				OutsideGlobal:     "203.0.113.1",
				OutsideGlobalPort: 80,
				InsideLocal:       "192.168.1.1",
				InsideLocalPort:   8080,
			},
			wantError: true,
		},
		{
			name: "port_nat_invalid_protocol",
			entry: NATStaticEntry{
				OutsideGlobal:     "203.0.113.1",
				OutsideGlobalPort: 80,
				InsideLocal:       "192.168.1.1",
				InsideLocalPort:   8080,
				Protocol:          "invalid",
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateNATStaticEntry(tc.entry)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateNATStaticEntry() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}

// TestNATStaticRoundTrip_IsPortBased tests port-based NAT detection
func TestNATStaticRoundTrip_IsPortBased(t *testing.T) {
	testCases := []struct {
		name     string
		entry    NATStaticEntry
		expected bool
	}{
		{
			name: "1to1_nat",
			entry: NATStaticEntry{
				OutsideGlobal: "203.0.113.1",
				InsideLocal:   "192.168.1.1",
			},
			expected: false,
		},
		{
			name: "port_nat",
			entry: NATStaticEntry{
				OutsideGlobal:     "203.0.113.1",
				OutsideGlobalPort: 80,
				InsideLocal:       "192.168.1.1",
				InsideLocalPort:   8080,
				Protocol:          "tcp",
			},
			expected: true,
		},
		{
			name: "partial_port_nat",
			entry: NATStaticEntry{
				OutsideGlobal:     "203.0.113.1",
				OutsideGlobalPort: 80,
				InsideLocal:       "192.168.1.1",
			},
			expected: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := IsPortBasedNAT(tc.entry)
			if got != tc.expected {
				t.Errorf("IsPortBasedNAT() = %v, want %v", got, tc.expected)
			}
		})
	}
}
