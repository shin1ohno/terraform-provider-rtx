// Code generated by specgen. DO NOT EDIT.
// Source: specs/service/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestServiceRoundTrip_ParseHTTPD tests HTTPD RTX command -> Terraform value conversion
func TestServiceRoundTrip_ParseHTTPD(t *testing.T) {
	parser := NewServiceParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *HTTPDConfig)
	}{
		{
			name: "httpd_host_any",
			rtx:  "httpd host any",
			checkFunc: func(t *testing.T, config *HTTPDConfig) {
				if config.Host != "any" {
					t.Errorf("Host = %v, want any", config.Host)
				}
			},
		},
		{
			name: "httpd_host_lan1",
			rtx:  "httpd host lan1",
			checkFunc: func(t *testing.T, config *HTTPDConfig) {
				if config.Host != "lan1" {
					t.Errorf("Host = %v, want lan1", config.Host)
				}
			},
		},
		{
			name: "httpd_proxy_access_on",
			rtx:  "httpd proxy-access l2ms permit on",
			checkFunc: func(t *testing.T, config *HTTPDConfig) {
				if !config.ProxyAccess {
					t.Errorf("ProxyAccess = %v, want true", config.ProxyAccess)
				}
			},
		},
		{
			name: "httpd_proxy_access_off",
			rtx:  "httpd proxy-access l2ms permit off",
			checkFunc: func(t *testing.T, config *HTTPDConfig) {
				if config.ProxyAccess {
					t.Errorf("ProxyAccess = %v, want false", config.ProxyAccess)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseHTTPDConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseHTTPDConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestServiceRoundTrip_ParseSSHD tests SSHD RTX command -> Terraform value conversion
func TestServiceRoundTrip_ParseSSHD(t *testing.T) {
	parser := NewServiceParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *SSHDConfig)
	}{
		{
			name: "sshd_service_on",
			rtx:  "sshd service on",
			checkFunc: func(t *testing.T, config *SSHDConfig) {
				if !config.Enabled {
					t.Errorf("Enabled = %v, want true", config.Enabled)
				}
			},
		},
		{
			name: "sshd_service_off",
			rtx:  "sshd service off",
			checkFunc: func(t *testing.T, config *SSHDConfig) {
				if config.Enabled {
					t.Errorf("Enabled = %v, want false", config.Enabled)
				}
			},
		},
		{
			name: "sshd_host_single",
			rtx:  "sshd host lan1",
			checkFunc: func(t *testing.T, config *SSHDConfig) {
				if len(config.Hosts) != 1 || config.Hosts[0] != "lan1" {
					t.Errorf("Hosts = %v, want [lan1]", config.Hosts)
				}
			},
		},
		{
			name: "sshd_host_multiple",
			rtx:  "sshd host lan1 lan2",
			checkFunc: func(t *testing.T, config *SSHDConfig) {
				if len(config.Hosts) != 2 {
					t.Errorf("Hosts count = %v, want 2", len(config.Hosts))
				}
			},
		},
		{
			name: "sshd_auth_method_password",
			rtx:  "sshd auth method password",
			checkFunc: func(t *testing.T, config *SSHDConfig) {
				if config.AuthMethod != "password" {
					t.Errorf("AuthMethod = %v, want password", config.AuthMethod)
				}
			},
		},
		{
			name: "sshd_auth_method_publickey",
			rtx:  "sshd auth method publickey",
			checkFunc: func(t *testing.T, config *SSHDConfig) {
				if config.AuthMethod != "publickey" {
					t.Errorf("AuthMethod = %v, want publickey", config.AuthMethod)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseSSHDConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseSSHDConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestServiceRoundTrip_ParseSFTPD tests SFTPD RTX command -> Terraform value conversion
func TestServiceRoundTrip_ParseSFTPD(t *testing.T) {
	parser := NewServiceParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *SFTPDConfig)
	}{
		{
			name: "sftpd_host_single",
			rtx:  "sftpd host lan1",
			checkFunc: func(t *testing.T, config *SFTPDConfig) {
				if len(config.Hosts) != 1 || config.Hosts[0] != "lan1" {
					t.Errorf("Hosts = %v, want [lan1]", config.Hosts)
				}
			},
		},
		{
			name: "sftpd_host_multiple",
			rtx:  "sftpd host lan1 lan2 lan3",
			checkFunc: func(t *testing.T, config *SFTPDConfig) {
				if len(config.Hosts) != 3 {
					t.Errorf("Hosts count = %v, want 3", len(config.Hosts))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseSFTPDConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseSFTPDConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestServiceRoundTrip_Build tests Terraform value -> RTX command conversion
func TestServiceRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		// HTTPD commands
		{
			name: "httpd_host_any",
			buildFunc: func() string {
				return BuildHTTPDHostCommand("any")
			},
			expectedRTX: "httpd host any",
		},
		{
			name: "httpd_host_lan1",
			buildFunc: func() string {
				return BuildHTTPDHostCommand("lan1")
			},
			expectedRTX: "httpd host lan1",
		},
		{
			name: "httpd_proxy_access_on",
			buildFunc: func() string {
				return BuildHTTPDProxyAccessCommand(true)
			},
			expectedRTX: "httpd proxy-access l2ms permit on",
		},
		{
			name: "httpd_proxy_access_off",
			buildFunc: func() string {
				return BuildHTTPDProxyAccessCommand(false)
			},
			expectedRTX: "httpd proxy-access l2ms permit off",
		},
		{
			name: "delete_httpd_host",
			buildFunc: func() string {
				return BuildDeleteHTTPDHostCommand()
			},
			expectedRTX: "no httpd host",
		},
		// SSHD commands
		{
			name: "sshd_service_on",
			buildFunc: func() string {
				return BuildSSHDServiceCommand(true)
			},
			expectedRTX: "sshd service on",
		},
		{
			name: "sshd_service_off",
			buildFunc: func() string {
				return BuildSSHDServiceCommand(false)
			},
			expectedRTX: "sshd service off",
		},
		{
			name: "sshd_host_single",
			buildFunc: func() string {
				return BuildSSHDHostCommand([]string{"lan1"})
			},
			expectedRTX: "sshd host lan1",
		},
		{
			name: "sshd_host_multiple",
			buildFunc: func() string {
				return BuildSSHDHostCommand([]string{"lan1", "lan2"})
			},
			expectedRTX: "sshd host lan1 lan2",
		},
		{
			name: "sshd_host_key_generate",
			buildFunc: func() string {
				return BuildSSHDHostKeyGenerateCommand()
			},
			expectedRTX: "sshd host key generate",
		},
		{
			name: "sshd_auth_method_password",
			buildFunc: func() string {
				return BuildSSHDAuthMethodCommand("password")
			},
			expectedRTX: "sshd auth method password",
		},
		{
			name: "sshd_auth_method_publickey",
			buildFunc: func() string {
				return BuildSSHDAuthMethodCommand("publickey")
			},
			expectedRTX: "sshd auth method publickey",
		},
		{
			name: "sshd_auth_method_any",
			buildFunc: func() string {
				return BuildSSHDAuthMethodCommand("any")
			},
			expectedRTX: "no sshd auth method",
		},
		{
			name: "delete_sshd_service",
			buildFunc: func() string {
				return BuildDeleteSSHDServiceCommand()
			},
			expectedRTX: "no sshd service",
		},
		{
			name: "delete_sshd_host",
			buildFunc: func() string {
				return BuildDeleteSSHDHostCommand()
			},
			expectedRTX: "no sshd host",
		},
		// SFTPD commands
		{
			name: "sftpd_host_single",
			buildFunc: func() string {
				return BuildSFTPDHostCommand([]string{"lan1"})
			},
			expectedRTX: "sftpd host lan1",
		},
		{
			name: "sftpd_host_multiple",
			buildFunc: func() string {
				return BuildSFTPDHostCommand([]string{"lan1", "lan2", "lan3"})
			},
			expectedRTX: "sftpd host lan1 lan2 lan3",
		},
		{
			name: "delete_sftpd_host",
			buildFunc: func() string {
				return BuildDeleteSFTPDHostCommand()
			},
			expectedRTX: "no sftpd host",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestServiceRoundTrip_ParseBuildParse tests full round-trip
func TestServiceRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewServiceParser()

	t.Run("httpd_round_trip", func(t *testing.T) {
		rtx := "httpd host lan1"

		// Parse
		config, err := parser.ParseHTTPDConfig(rtx)
		if err != nil {
			t.Fatalf("ParseHTTPDConfig error: %v", err)
		}

		// Build
		rebuilt := BuildHTTPDHostCommand(config.Host)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}

		// Parse again
		config2, err := parser.ParseHTTPDConfig(rebuilt)
		if err != nil {
			t.Fatalf("ParseHTTPDConfig error on rebuilt: %v", err)
		}

		if config.Host != config2.Host {
			t.Errorf("Host mismatch: %v != %v", config.Host, config2.Host)
		}
	})

	t.Run("sshd_service_round_trip", func(t *testing.T) {
		rtx := "sshd service on"

		// Parse
		config, err := parser.ParseSSHDConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSSHDConfig error: %v", err)
		}

		// Build
		rebuilt := BuildSSHDServiceCommand(config.Enabled)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestServiceRoundTrip_SSHAuthorizedKeys tests SSH authorized keys parsing
func TestServiceRoundTrip_SSHAuthorizedKeys(t *testing.T) {
	testCases := []struct {
		name      string
		input     string
		expectLen int
	}{
		{
			name:      "empty_input",
			input:     "",
			expectLen: 0,
		},
		{
			name:      "single_rsa_key",
			input:     "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC user@host",
			expectLen: 1,
		},
		{
			name:      "single_ed25519_key",
			input:     "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI user@host",
			expectLen: 1,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			keys, err := ParseSSHDAuthorizedKeys(tc.input)
			if err != nil {
				t.Fatalf("ParseSSHDAuthorizedKeys error: %v", err)
			}
			if len(keys) != tc.expectLen {
				t.Errorf("Keys count = %v, want %v", len(keys), tc.expectLen)
			}
		})
	}
}
