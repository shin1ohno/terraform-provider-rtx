// Code generated by specgen. DO NOT EDIT.
// Source: specs/ethernet_filter/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestEthernetFilterRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestEthernetFilterRoundTrip_Parse(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, filters []EthernetFilter)
	}{
		{
			name: "basic_pass_filter",
			rtx:  "ethernet filter 1 pass * *",
			checkFunc: func(t *testing.T, filters []EthernetFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				f := filters[0]
				if f.Number != 1 {
					t.Errorf("Number = %v, want 1", f.Number)
				}
				if f.Action != "pass" {
					t.Errorf("Action = %v, want pass", f.Action)
				}
			},
		},
		{
			name: "reject_nolog_filter",
			rtx:  "ethernet filter 2 reject-nolog * *",
			checkFunc: func(t *testing.T, filters []EthernetFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				if filters[0].Action != "reject-nolog" {
					t.Errorf("Action = %v, want reject-nolog", filters[0].Action)
				}
			},
		},
		{
			name: "filter_with_mac",
			rtx:  "ethernet filter 3 pass 00:11:22:33:44:55 *",
			checkFunc: func(t *testing.T, filters []EthernetFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				if filters[0].SourceMAC != "00:11:22:33:44:55" {
					t.Errorf("SourceMAC = %v, want 00:11:22:33:44:55", filters[0].SourceMAC)
				}
			},
		},
		{
			name: "filter_with_ethertype",
			rtx:  "ethernet filter 4 pass * * 0x0800",
			checkFunc: func(t *testing.T, filters []EthernetFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				if filters[0].EtherType != "0x0800" {
					t.Errorf("EtherType = %v, want 0x0800", filters[0].EtherType)
				}
			},
		},
		{
			name: "dhcp_bind_filter",
			rtx:  "ethernet filter 5 pass dhcp-bind",
			checkFunc: func(t *testing.T, filters []EthernetFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				if filters[0].DHCPType != "dhcp-bind" {
					t.Errorf("DHCPType = %v, want dhcp-bind", filters[0].DHCPType)
				}
			},
		},
		{
			name: "multiple_filters",
			rtx: `ethernet filter 1 pass * *
ethernet filter 2 reject * *
ethernet filter 3 pass-log 00:11:22:33:44:55 *`,
			checkFunc: func(t *testing.T, filters []EthernetFilter) {
				if len(filters) != 3 {
					t.Errorf("Filters count = %v, want 3", len(filters))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			filters, err := ParseEthernetFilterConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseEthernetFilterConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, filters)
		})
	}
}

// TestEthernetFilterRoundTrip_Build tests Terraform value -> RTX command conversion
func TestEthernetFilterRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "basic_pass_filter",
			buildFunc: func() string {
				return BuildEthernetFilterCommand(EthernetFilter{
					Number:         1,
					Action:         "pass",
					SourceMAC:      "*",
					DestinationMAC: "*",
				})
			},
			expectedRTX: "ethernet filter 1 pass * *",
		},
		{
			name: "filter_with_ethertype",
			buildFunc: func() string {
				return BuildEthernetFilterCommand(EthernetFilter{
					Number:         2,
					Action:         "pass",
					SourceMAC:      "*",
					DestinationMAC: "*",
					EtherType:      "0x0800",
				})
			},
			expectedRTX: "ethernet filter 2 pass * * 0x0800",
		},
		{
			name: "filter_with_vlan",
			buildFunc: func() string {
				return BuildEthernetFilterCommand(EthernetFilter{
					Number:         3,
					Action:         "pass",
					SourceMAC:      "*",
					DestinationMAC: "*",
					VlanID:         100,
				})
			},
			expectedRTX: "ethernet filter 3 pass * * vlan 100",
		},
		{
			name: "dhcp_bind_filter",
			buildFunc: func() string {
				return BuildEthernetFilterCommand(EthernetFilter{
					Number:   4,
					Action:   "pass",
					DHCPType: "dhcp-bind",
				})
			},
			expectedRTX: "ethernet filter 4 pass dhcp-bind",
		},
		{
			name: "delete_filter",
			buildFunc: func() string {
				return BuildDeleteEthernetFilterCommand(1)
			},
			expectedRTX: "no ethernet filter 1",
		},
		{
			name: "interface_filter",
			buildFunc: func() string {
				return BuildInterfaceEthernetFilterCommand("lan1", "in", []int{1, 2, 3})
			},
			expectedRTX: "ethernet lan1 filter in 1 2 3",
		},
		{
			name: "delete_interface_filter",
			buildFunc: func() string {
				return BuildDeleteInterfaceEthernetFilterCommand("lan1", "in")
			},
			expectedRTX: "no ethernet lan1 filter in",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestEthernetFilterRoundTrip_ParseBuildParse tests full round-trip
func TestEthernetFilterRoundTrip_ParseBuildParse(t *testing.T) {
	t.Run("basic_filter_round_trip", func(t *testing.T) {
		rtx := "ethernet filter 1 pass * *"

		// Parse
		filters, err := ParseEthernetFilterConfig(rtx)
		if err != nil {
			t.Fatalf("ParseEthernetFilterConfig error: %v", err)
		}

		if len(filters) != 1 {
			t.Fatalf("Expected 1 filter, got %d", len(filters))
		}
		f := filters[0]

		// Build
		rebuilt := BuildEthernetFilterCommand(f)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestEthernetFilterRoundTrip_Validation tests ethernet filter validation functions
func TestEthernetFilterRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		filter    EthernetFilter
		wantError bool
	}{
		{
			name: "valid_filter",
			filter: EthernetFilter{
				Number:         1,
				Action:         "pass",
				SourceMAC:      "*",
				DestinationMAC: "*",
			},
			wantError: false,
		},
		{
			name: "invalid_number",
			filter: EthernetFilter{
				Number:         0,
				Action:         "pass",
				SourceMAC:      "*",
				DestinationMAC: "*",
			},
			wantError: true,
		},
		{
			name: "number_too_large",
			filter: EthernetFilter{
				Number:         513,
				Action:         "pass",
				SourceMAC:      "*",
				DestinationMAC: "*",
			},
			wantError: true,
		},
		{
			name: "invalid_action",
			filter: EthernetFilter{
				Number:         1,
				Action:         "invalid",
				SourceMAC:      "*",
				DestinationMAC: "*",
			},
			wantError: true,
		},
		{
			name: "invalid_mac_format",
			filter: EthernetFilter{
				Number:         1,
				Action:         "pass",
				SourceMAC:      "invalid",
				DestinationMAC: "*",
			},
			wantError: true,
		},
		{
			name: "valid_mac_address",
			filter: EthernetFilter{
				Number:         1,
				Action:         "pass",
				SourceMAC:      "00:11:22:33:44:55",
				DestinationMAC: "*",
			},
			wantError: false,
		},
		{
			name: "invalid_vlan_id",
			filter: EthernetFilter{
				Number:         1,
				Action:         "pass",
				SourceMAC:      "*",
				DestinationMAC: "*",
				VlanID:         4095,
			},
			wantError: true,
		},
		{
			name: "valid_dhcp_filter",
			filter: EthernetFilter{
				Number:   1,
				Action:   "pass",
				DHCPType: "dhcp-bind",
			},
			wantError: false,
		},
		{
			name: "invalid_dhcp_type",
			filter: EthernetFilter{
				Number:   1,
				Action:   "pass",
				DHCPType: "invalid",
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateEthernetFilter(tc.filter)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateEthernetFilter() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}

// TestEthernetFilterRoundTrip_NormalizeMAC tests MAC address normalization
func TestEthernetFilterRoundTrip_NormalizeMAC(t *testing.T) {
	testCases := []struct {
		input    string
		expected string
	}{
		{"00:11:22:33:44:55", "00:11:22:33:44:55"},
		{"00-11-22-33-44-55", "00:11:22:33:44:55"},
		{"0011.2233.4455", "00:11:22:33:44:55"},
		{"001122334455", "00:11:22:33:44:55"},
		{"AA:BB:CC:DD:EE:FF", "aa:bb:cc:dd:ee:ff"},
		{"*", "*"},
	}

	for _, tc := range testCases {
		t.Run(tc.input, func(t *testing.T) {
			got := NormalizeMAC(tc.input)
			if got != tc.expected {
				t.Errorf("NormalizeMAC(%q) = %q, want %q", tc.input, got, tc.expected)
			}
		})
	}
}
