// Code generated by specgen. DO NOT EDIT.
// Source: specs/dhcp/interface.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestDHCPInterfaceRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestDHCPInterfaceRoundTrip_Parse(t *testing.T) {
	parser := NewDHCPInterfaceParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, configs []DHCPInterfaceConfig)
	}{
		{
			name: "dhcp_service_server",
			rtx:  "ip lan1 dhcp service server",
			checkFunc: func(t *testing.T, configs []DHCPInterfaceConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].Interface != "lan1" {
					t.Errorf("Interface = %v, want lan1", configs[0].Interface)
				}
				if configs[0].RelayEnabled {
					t.Errorf("RelayEnabled = %v, want false", configs[0].RelayEnabled)
				}
			},
		},
		{
			name: "dhcp_service_server_with_scope",
			rtx:  "ip lan1 dhcp service server 1",
			checkFunc: func(t *testing.T, configs []DHCPInterfaceConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].Interface != "lan1" {
					t.Errorf("Interface = %v, want lan1", configs[0].Interface)
				}
				if configs[0].ScopeID != 1 {
					t.Errorf("ScopeID = %v, want 1", configs[0].ScopeID)
				}
				if configs[0].RelayEnabled {
					t.Errorf("RelayEnabled = %v, want false", configs[0].RelayEnabled)
				}
			},
		},
		{
			name: "dhcp_service_relay",
			rtx:  "ip lan1 dhcp service relay",
			checkFunc: func(t *testing.T, configs []DHCPInterfaceConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].Interface != "lan1" {
					t.Errorf("Interface = %v, want lan1", configs[0].Interface)
				}
				if !configs[0].RelayEnabled {
					t.Errorf("RelayEnabled = %v, want true", configs[0].RelayEnabled)
				}
			},
		},
		{
			name: "multiple_interfaces",
			rtx: `ip lan1 dhcp service server 1
ip lan2 dhcp service relay`,
			checkFunc: func(t *testing.T, configs []DHCPInterfaceConfig) {
				if len(configs) != 2 {
					t.Errorf("Configs count = %v, want 2", len(configs))
				}
			},
		},
		{
			name: "empty_config",
			rtx:  "",
			checkFunc: func(t *testing.T, configs []DHCPInterfaceConfig) {
				if len(configs) != 0 {
					t.Errorf("Configs count = %v, want 0", len(configs))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			configs, err := parser.ParseInterfaceDHCPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseInterfaceDHCPConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, configs)
		})
	}
}

// TestDHCPInterfaceRoundTrip_Build tests Terraform value -> RTX command conversion
func TestDHCPInterfaceRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "dhcp_service_server",
			buildFunc: func() string {
				return BuildInterfaceDHCPServiceCommand("lan1", "server", 0)
			},
			expectedRTX: "ip lan1 dhcp service server",
		},
		{
			name: "dhcp_service_server_with_scope",
			buildFunc: func() string {
				return BuildInterfaceDHCPServiceCommand("lan1", "server", 1)
			},
			expectedRTX: "ip lan1 dhcp service server 1",
		},
		{
			name: "dhcp_service_relay",
			buildFunc: func() string {
				return BuildInterfaceDHCPServiceCommand("lan1", "relay", 0)
			},
			expectedRTX: "ip lan1 dhcp service relay",
		},
		{
			name: "delete_dhcp_service",
			buildFunc: func() string {
				return BuildDeleteInterfaceDHCPServiceCommand("lan1")
			},
			expectedRTX: "no ip lan1 dhcp service",
		},
		{
			name: "lan2_dhcp_service_server",
			buildFunc: func() string {
				return BuildInterfaceDHCPServiceCommand("lan2", "server", 2)
			},
			expectedRTX: "ip lan2 dhcp service server 2",
		},
		{
			name: "vlan1_dhcp_service_relay",
			buildFunc: func() string {
				return BuildInterfaceDHCPServiceCommand("vlan1", "relay", 0)
			},
			expectedRTX: "ip vlan1 dhcp service relay",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestDHCPInterfaceRoundTrip_ParseBuildParse tests full round-trip
func TestDHCPInterfaceRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewDHCPInterfaceParser()

	t.Run("dhcp_service_server_round_trip", func(t *testing.T) {
		rtx := "ip lan1 dhcp service server"

		// Parse
		configs, err := parser.ParseInterfaceDHCPConfig(rtx)
		if err != nil {
			t.Fatalf("ParseInterfaceDHCPConfig error: %v", err)
		}

		if len(configs) != 1 {
			t.Fatalf("Expected 1 config, got %d", len(configs))
		}

		// Build
		serviceType := "server"
		if configs[0].RelayEnabled {
			serviceType = "relay"
		}
		rebuilt := BuildInterfaceDHCPServiceCommand(configs[0].Interface, serviceType, configs[0].ScopeID)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("dhcp_service_server_with_scope_round_trip", func(t *testing.T) {
		rtx := "ip lan1 dhcp service server 1"

		// Parse
		configs, err := parser.ParseInterfaceDHCPConfig(rtx)
		if err != nil {
			t.Fatalf("ParseInterfaceDHCPConfig error: %v", err)
		}

		if len(configs) != 1 {
			t.Fatalf("Expected 1 config, got %d", len(configs))
		}

		// Build
		serviceType := "server"
		if configs[0].RelayEnabled {
			serviceType = "relay"
		}
		rebuilt := BuildInterfaceDHCPServiceCommand(configs[0].Interface, serviceType, configs[0].ScopeID)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("dhcp_service_relay_round_trip", func(t *testing.T) {
		rtx := "ip lan1 dhcp service relay"

		// Parse
		configs, err := parser.ParseInterfaceDHCPConfig(rtx)
		if err != nil {
			t.Fatalf("ParseInterfaceDHCPConfig error: %v", err)
		}

		if len(configs) != 1 {
			t.Fatalf("Expected 1 config, got %d", len(configs))
		}

		// Build
		serviceType := "server"
		if configs[0].RelayEnabled {
			serviceType = "relay"
		}
		rebuilt := BuildInterfaceDHCPServiceCommand(configs[0].Interface, serviceType, configs[0].ScopeID)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestDHCPInterfaceRoundTrip_Validation tests DHCP interface validation functions
func TestDHCPInterfaceRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		iface     string
		wantError bool
	}{
		{
			name:      "valid_lan1",
			iface:     "lan1",
			wantError: false,
		},
		{
			name:      "valid_lan2",
			iface:     "lan2",
			wantError: false,
		},
		{
			name:      "valid_vlan1",
			iface:     "vlan1",
			wantError: false,
		},
		{
			name:      "valid_bridge1",
			iface:     "bridge1",
			wantError: false,
		},
		{
			name:      "valid_loopback1",
			iface:     "loopback1",
			wantError: false,
		},
		{
			name:      "valid_tunnel1",
			iface:     "tunnel1",
			wantError: false,
		},
		{
			name:      "valid_pp1",
			iface:     "pp1",
			wantError: false,
		},
		{
			name:      "invalid_interface",
			iface:     "invalid",
			wantError: true,
		},
		{
			name:      "invalid_lan",
			iface:     "lan",
			wantError: true,
		},
		{
			name:      "invalid_empty",
			iface:     "",
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateDHCPInterfaceName(tc.iface)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateDHCPInterfaceName(%q) error = %v, wantError %v", tc.iface, err, tc.wantError)
			}
		})
	}
}

// TestDHCPInterfaceRoundTrip_DifferentInterfaces tests parsing different interface types
func TestDHCPInterfaceRoundTrip_DifferentInterfaces(t *testing.T) {
	parser := NewDHCPInterfaceParser()

	testCases := []struct {
		name  string
		rtx   string
		iface string
	}{
		{"lan1", "ip lan1 dhcp service server", "lan1"},
		{"lan2", "ip lan2 dhcp service server 2", "lan2"},
		{"vlan1", "ip vlan1 dhcp service relay", "vlan1"},
		{"bridge1", "ip bridge1 dhcp service server 1", "bridge1"},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			configs, err := parser.ParseInterfaceDHCPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseInterfaceDHCPConfig(%q) error = %v", tc.rtx, err)
			}
			if len(configs) != 1 {
				t.Errorf("Configs count = %v, want 1", len(configs))
				return
			}
			if configs[0].Interface != tc.iface {
				t.Errorf("Interface = %v, want %v", configs[0].Interface, tc.iface)
			}
		})
	}
}
