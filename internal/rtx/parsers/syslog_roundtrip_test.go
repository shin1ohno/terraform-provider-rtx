// Code generated by specgen. DO NOT EDIT.
// Source: specs/syslog/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestSyslogRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestSyslogRoundTrip_Parse(t *testing.T) {
	parser := NewSyslogParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *SyslogConfig)
	}{
		{
			name: "syslog_host_simple",
			rtx:  "syslog host 192.168.1.100",
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if len(config.Hosts) != 1 {
					t.Errorf("Hosts count = %v, want 1", len(config.Hosts))
					return
				}
				if config.Hosts[0].Address != "192.168.1.100" {
					t.Errorf("Host Address = %v, want 192.168.1.100", config.Hosts[0].Address)
				}
				if config.Hosts[0].Port != 514 {
					t.Errorf("Host Port = %v, want 514", config.Hosts[0].Port)
				}
			},
		},
		{
			name: "syslog_host_with_port",
			rtx:  "syslog host 192.168.1.100 1514",
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if len(config.Hosts) != 1 {
					t.Errorf("Hosts count = %v, want 1", len(config.Hosts))
					return
				}
				if config.Hosts[0].Port != 1514 {
					t.Errorf("Host Port = %v, want 1514", config.Hosts[0].Port)
				}
			},
		},
		{
			name: "syslog_local_address",
			rtx:  "syslog local address 192.168.1.1",
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if config.LocalAddress != "192.168.1.1" {
					t.Errorf("LocalAddress = %v, want 192.168.1.1", config.LocalAddress)
				}
			},
		},
		{
			name: "syslog_facility",
			rtx:  "syslog facility local0",
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if config.Facility != "local0" {
					t.Errorf("Facility = %v, want local0", config.Facility)
				}
			},
		},
		{
			name: "syslog_notice_on",
			rtx:  "syslog notice on",
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if !config.Notice {
					t.Errorf("Notice = %v, want true", config.Notice)
				}
			},
		},
		{
			name: "syslog_notice_off",
			rtx:  "syslog notice off",
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if config.Notice {
					t.Errorf("Notice = %v, want false", config.Notice)
				}
			},
		},
		{
			name: "syslog_info_on",
			rtx:  "syslog info on",
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if !config.Info {
					t.Errorf("Info = %v, want true", config.Info)
				}
			},
		},
		{
			name: "syslog_debug_on",
			rtx:  "syslog debug on",
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if !config.Debug {
					t.Errorf("Debug = %v, want true", config.Debug)
				}
			},
		},
		{
			name: "syslog_full_config",
			rtx: `syslog host 192.168.1.100
syslog local address 192.168.1.1
syslog facility local0
syslog notice on
syslog info on
syslog debug off`,
			checkFunc: func(t *testing.T, config *SyslogConfig) {
				if len(config.Hosts) != 1 {
					t.Errorf("Hosts count = %v, want 1", len(config.Hosts))
				}
				if config.LocalAddress != "192.168.1.1" {
					t.Errorf("LocalAddress = %v, want 192.168.1.1", config.LocalAddress)
				}
				if config.Facility != "local0" {
					t.Errorf("Facility = %v, want local0", config.Facility)
				}
				if !config.Notice {
					t.Errorf("Notice = %v, want true", config.Notice)
				}
				if !config.Info {
					t.Errorf("Info = %v, want true", config.Info)
				}
				if config.Debug {
					t.Errorf("Debug = %v, want false", config.Debug)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseSyslogConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseSyslogConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestSyslogRoundTrip_Build tests Terraform value -> RTX command conversion
func TestSyslogRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "syslog_host_simple",
			buildFunc: func() string {
				return BuildSyslogHostCommand(SyslogHost{
					Address: "192.168.1.100",
				})
			},
			expectedRTX: "syslog host 192.168.1.100",
		},
		{
			name: "syslog_host_with_port",
			buildFunc: func() string {
				return BuildSyslogHostCommand(SyslogHost{
					Address: "192.168.1.100",
					Port:    1514,
				})
			},
			expectedRTX: "syslog host 192.168.1.100 1514",
		},
		{
			name: "syslog_host_default_port",
			buildFunc: func() string {
				return BuildSyslogHostCommand(SyslogHost{
					Address: "192.168.1.100",
					Port:    514,
				})
			},
			expectedRTX: "syslog host 192.168.1.100",
		},
		{
			name: "syslog_local_address",
			buildFunc: func() string {
				return BuildSyslogLocalAddressCommand("192.168.1.1")
			},
			expectedRTX: "syslog local address 192.168.1.1",
		},
		{
			name: "syslog_facility",
			buildFunc: func() string {
				return BuildSyslogFacilityCommand("local0")
			},
			expectedRTX: "syslog facility local0",
		},
		{
			name: "syslog_notice_on",
			buildFunc: func() string {
				return BuildSyslogNoticeCommand(true)
			},
			expectedRTX: "syslog notice on",
		},
		{
			name: "syslog_notice_off",
			buildFunc: func() string {
				return BuildSyslogNoticeCommand(false)
			},
			expectedRTX: "syslog notice off",
		},
		{
			name: "syslog_info_on",
			buildFunc: func() string {
				return BuildSyslogInfoCommand(true)
			},
			expectedRTX: "syslog info on",
		},
		{
			name: "syslog_info_off",
			buildFunc: func() string {
				return BuildSyslogInfoCommand(false)
			},
			expectedRTX: "syslog info off",
		},
		{
			name: "syslog_debug_on",
			buildFunc: func() string {
				return BuildSyslogDebugCommand(true)
			},
			expectedRTX: "syslog debug on",
		},
		{
			name: "syslog_debug_off",
			buildFunc: func() string {
				return BuildSyslogDebugCommand(false)
			},
			expectedRTX: "syslog debug off",
		},
		{
			name: "delete_syslog_host",
			buildFunc: func() string {
				return BuildDeleteSyslogHostCommand("192.168.1.100")
			},
			expectedRTX: "no syslog host 192.168.1.100",
		},
		{
			name: "delete_syslog_local_address",
			buildFunc: func() string {
				return BuildDeleteSyslogLocalAddressCommand()
			},
			expectedRTX: "no syslog local address",
		},
		{
			name: "delete_syslog_facility",
			buildFunc: func() string {
				return BuildDeleteSyslogFacilityCommand()
			},
			expectedRTX: "no syslog facility",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestSyslogRoundTrip_ParseBuildParse tests full round-trip
func TestSyslogRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewSyslogParser()

	t.Run("syslog_host_round_trip", func(t *testing.T) {
		rtx := "syslog host 192.168.1.100"

		// Parse
		config, err := parser.ParseSyslogConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSyslogConfig error: %v", err)
		}

		if len(config.Hosts) != 1 {
			t.Fatalf("Expected 1 host, got %d", len(config.Hosts))
		}

		// Build
		rebuilt := BuildSyslogHostCommand(config.Hosts[0])

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("syslog_facility_round_trip", func(t *testing.T) {
		rtx := "syslog facility local0"

		// Parse
		config, err := parser.ParseSyslogConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSyslogConfig error: %v", err)
		}

		// Build
		rebuilt := BuildSyslogFacilityCommand(config.Facility)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("syslog_notice_round_trip", func(t *testing.T) {
		rtx := "syslog notice on"

		// Parse
		config, err := parser.ParseSyslogConfig(rtx)
		if err != nil {
			t.Fatalf("ParseSyslogConfig error: %v", err)
		}

		// Build
		rebuilt := BuildSyslogNoticeCommand(config.Notice)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestSyslogRoundTrip_Validation tests syslog validation functions
func TestSyslogRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		config    *SyslogConfig
		wantError bool
	}{
		{
			name: "valid_config",
			config: &SyslogConfig{
				Hosts: []SyslogHost{
					{Address: "192.168.1.100", Port: 514},
				},
				LocalAddress: "192.168.1.1",
				Facility:     "local0",
			},
			wantError: false,
		},
		{
			name: "invalid_host_address",
			config: &SyslogConfig{
				Hosts: []SyslogHost{
					{Address: "-invalid", Port: 514}, // Hostname cannot start with hyphen
				},
			},
			wantError: true,
		},
		{
			name: "invalid_local_address",
			config: &SyslogConfig{
				LocalAddress: "invalid-ip",
			},
			wantError: true,
		},
		{
			name: "invalid_facility",
			config: &SyslogConfig{
				Facility: "invalid",
			},
			wantError: true,
		},
		{
			name: "invalid_port",
			config: &SyslogConfig{
				Hosts: []SyslogHost{
					{Address: "192.168.1.100", Port: -1},
				},
			},
			wantError: true,
		},
		{
			name: "valid_hostname",
			config: &SyslogConfig{
				Hosts: []SyslogHost{
					{Address: "syslog.example.com", Port: 514},
				},
			},
			wantError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateSyslogConfig(tc.config)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateSyslogConfig() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}

// TestSyslogRoundTrip_Delete tests delete command generation
func TestSyslogRoundTrip_Delete(t *testing.T) {
	config := &SyslogConfig{
		Hosts: []SyslogHost{
			{Address: "192.168.1.100", Port: 514},
		},
		LocalAddress: "192.168.1.1",
		Facility:     "local0",
		Notice:       true,
		Info:         true,
		Debug:        false,
	}

	commands := BuildDeleteSyslogCommand(config)

	if len(commands) == 0 {
		t.Errorf("Expected delete commands, got empty slice")
		return
	}

	// Verify host delete is present
	foundHostDelete := false
	for _, cmd := range commands {
		if cmd == "no syslog host 192.168.1.100" {
			foundHostDelete = true
			break
		}
	}
	if !foundHostDelete {
		t.Errorf("Expected 'no syslog host 192.168.1.100' in delete commands")
	}
}
