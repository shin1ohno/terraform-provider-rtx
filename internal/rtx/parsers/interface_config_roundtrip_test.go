// Code generated by specgen. DO NOT EDIT.
// Source: specs/interface/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestInterfaceConfigRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestInterfaceConfigRoundTrip_Parse(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		iface     string
		checkFunc func(t *testing.T, config *InterfaceConfig)
	}{
		{
			name:  "ip_address_static",
			rtx:   "ip lan1 address 192.168.1.1/24",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if config.IPAddress == nil {
					t.Errorf("IPAddress should not be nil")
					return
				}
				if config.IPAddress.Address != "192.168.1.1/24" {
					t.Errorf("IPAddress.Address = %v, want 192.168.1.1/24", config.IPAddress.Address)
				}
				if config.IPAddress.DHCP {
					t.Errorf("IPAddress.DHCP = %v, want false", config.IPAddress.DHCP)
				}
			},
		},
		{
			name:  "ip_address_dhcp",
			rtx:   "ip lan1 address dhcp",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if config.IPAddress == nil {
					t.Errorf("IPAddress should not be nil")
					return
				}
				if !config.IPAddress.DHCP {
					t.Errorf("IPAddress.DHCP = %v, want true", config.IPAddress.DHCP)
				}
			},
		},
		{
			name:  "description",
			rtx:   `description lan1 "LAN Interface"`,
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if config.Description != "LAN Interface" {
					t.Errorf("Description = %v, want LAN Interface", config.Description)
				}
			},
		},
		{
			name:  "secure_filter_in",
			rtx:   "ip lan1 secure filter in 100 200 300",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if len(config.SecureFilterIn) != 3 {
					t.Errorf("SecureFilterIn count = %v, want 3", len(config.SecureFilterIn))
					return
				}
				if config.SecureFilterIn[0] != 100 {
					t.Errorf("SecureFilterIn[0] = %v, want 100", config.SecureFilterIn[0])
				}
			},
		},
		{
			name:  "secure_filter_out_with_dynamic",
			rtx:   "ip lan1 secure filter out 100 200 dynamic 10 20",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if len(config.SecureFilterOut) != 2 {
					t.Errorf("SecureFilterOut count = %v, want 2", len(config.SecureFilterOut))
				}
				if len(config.DynamicFilterOut) != 2 {
					t.Errorf("DynamicFilterOut count = %v, want 2", len(config.DynamicFilterOut))
				}
			},
		},
		{
			name:  "nat_descriptor",
			rtx:   "ip lan1 nat descriptor 1000",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if config.NATDescriptor != 1000 {
					t.Errorf("NATDescriptor = %v, want 1000", config.NATDescriptor)
				}
			},
		},
		{
			name:  "proxyarp_on",
			rtx:   "ip lan1 proxyarp on",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if !config.ProxyARP {
					t.Errorf("ProxyARP = %v, want true", config.ProxyARP)
				}
			},
		},
		{
			name:  "mtu",
			rtx:   "ip lan1 mtu 1400",
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if config.MTU != 1400 {
					t.Errorf("MTU = %v, want 1400", config.MTU)
				}
			},
		},
		{
			name: "full_config",
			rtx: `description lan1 "Main LAN"
ip lan1 address 192.168.1.1/24
ip lan1 secure filter in 100 200
ip lan1 secure filter out 300 dynamic 10
ip lan1 nat descriptor 1000
ip lan1 proxyarp on
ip lan1 mtu 1400`,
			iface: "lan1",
			checkFunc: func(t *testing.T, config *InterfaceConfig) {
				if config.Description != "Main LAN" {
					t.Errorf("Description = %v, want Main LAN", config.Description)
				}
				if config.IPAddress == nil || config.IPAddress.Address != "192.168.1.1/24" {
					t.Errorf("IPAddress unexpected value")
				}
				if len(config.SecureFilterIn) != 2 {
					t.Errorf("SecureFilterIn count = %v, want 2", len(config.SecureFilterIn))
				}
				if len(config.SecureFilterOut) != 1 {
					t.Errorf("SecureFilterOut count = %v, want 1", len(config.SecureFilterOut))
				}
				if config.NATDescriptor != 1000 {
					t.Errorf("NATDescriptor = %v, want 1000", config.NATDescriptor)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := ParseInterfaceConfig(tc.rtx, tc.iface)
			if err != nil {
				t.Fatalf("ParseInterfaceConfig(%q, %q) error = %v", tc.rtx, tc.iface, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestInterfaceConfigRoundTrip_Build tests Terraform value -> RTX command conversion
func TestInterfaceConfigRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "ip_address_static",
			buildFunc: func() string {
				return BuildIPAddressCommand("lan1", InterfaceIP{
					Address: "192.168.1.1/24",
				})
			},
			expectedRTX: "ip lan1 address 192.168.1.1/24",
		},
		{
			name: "ip_address_dhcp",
			buildFunc: func() string {
				return BuildIPAddressCommand("lan1", InterfaceIP{
					DHCP: true,
				})
			},
			expectedRTX: "ip lan1 address dhcp",
		},
		{
			name: "description",
			buildFunc: func() string {
				return BuildDescriptionCommand("lan1", "Main LAN")
			},
			expectedRTX: `description lan1 "Main LAN"`,
		},
		{
			name: "secure_filter_in",
			buildFunc: func() string {
				return BuildSecureFilterInCommand("lan1", []int{100, 200, 300})
			},
			expectedRTX: "ip lan1 secure filter in 100 200 300",
		},
		{
			name: "secure_filter_out_simple",
			buildFunc: func() string {
				return BuildSecureFilterOutCommand("lan1", []int{100, 200}, nil)
			},
			expectedRTX: "ip lan1 secure filter out 100 200",
		},
		{
			name: "secure_filter_out_with_dynamic",
			buildFunc: func() string {
				return BuildSecureFilterOutCommand("lan1", []int{100, 200}, []int{10, 20})
			},
			expectedRTX: "ip lan1 secure filter out 100 200 dynamic 10 20",
		},
		{
			name: "nat_descriptor",
			buildFunc: func() string {
				return BuildNATDescriptorCommand("lan1", 1000)
			},
			expectedRTX: "ip lan1 nat descriptor 1000",
		},
		{
			name: "proxyarp_on",
			buildFunc: func() string {
				return BuildProxyARPCommand("lan1", true)
			},
			expectedRTX: "ip lan1 proxyarp on",
		},
		{
			name: "proxyarp_off",
			buildFunc: func() string {
				return BuildProxyARPCommand("lan1", false)
			},
			expectedRTX: "ip lan1 proxyarp off",
		},
		{
			name: "mtu",
			buildFunc: func() string {
				return BuildMTUCommand("lan1", 1400)
			},
			expectedRTX: "ip lan1 mtu 1400",
		},
		{
			name: "delete_ip_address",
			buildFunc: func() string {
				return BuildDeleteIPAddressCommand("lan1")
			},
			expectedRTX: "no ip lan1 address",
		},
		{
			name: "delete_secure_filter",
			buildFunc: func() string {
				return BuildDeleteSecureFilterCommand("lan1", "in")
			},
			expectedRTX: "no ip lan1 secure filter in",
		},
		{
			name: "delete_nat_descriptor",
			buildFunc: func() string {
				return BuildDeleteNATDescriptorCommand("lan1")
			},
			expectedRTX: "no ip lan1 nat descriptor",
		},
		{
			name: "delete_description",
			buildFunc: func() string {
				return BuildDeleteDescriptionCommand("lan1")
			},
			expectedRTX: "no description lan1",
		},
		{
			name: "delete_mtu",
			buildFunc: func() string {
				return BuildDeleteMTUCommand("lan1")
			},
			expectedRTX: "no ip lan1 mtu",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestInterfaceConfigRoundTrip_ParseBuildParse tests full round-trip
func TestInterfaceConfigRoundTrip_ParseBuildParse(t *testing.T) {
	t.Run("ip_address_round_trip", func(t *testing.T) {
		rtx := "ip lan1 address 192.168.1.1/24"
		iface := "lan1"

		// Parse
		config, err := ParseInterfaceConfig(rtx, iface)
		if err != nil {
			t.Fatalf("ParseInterfaceConfig error: %v", err)
		}

		// Build
		rebuilt := BuildIPAddressCommand(iface, *config.IPAddress)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})

	t.Run("secure_filter_round_trip", func(t *testing.T) {
		rtx := "ip lan1 secure filter in 100 200 300"
		iface := "lan1"

		// Parse
		config, err := ParseInterfaceConfig(rtx, iface)
		if err != nil {
			t.Fatalf("ParseInterfaceConfig error: %v", err)
		}

		// Build
		rebuilt := BuildSecureFilterInCommand(iface, config.SecureFilterIn)

		// Verify
		if rebuilt != rtx {
			t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", rtx, rebuilt)
		}
	})
}

// TestInterfaceConfigRoundTrip_Validation tests interface config validation functions
func TestInterfaceConfigRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		config    InterfaceConfig
		wantError bool
	}{
		{
			name: "valid_config",
			config: InterfaceConfig{
				Name: "lan1",
				IPAddress: &InterfaceIP{
					Address: "192.168.1.1/24",
				},
			},
			wantError: false,
		},
		{
			name: "invalid_interface_name",
			config: InterfaceConfig{
				Name: "invalid",
			},
			wantError: true,
		},
		{
			name: "dhcp_with_static_conflict",
			config: InterfaceConfig{
				Name: "lan1",
				IPAddress: &InterfaceIP{
					Address: "192.168.1.1/24",
					DHCP:    true,
				},
			},
			wantError: true,
		},
		{
			name: "invalid_ip_format",
			config: InterfaceConfig{
				Name: "lan1",
				IPAddress: &InterfaceIP{
					Address: "192.168.1.1", // Missing prefix
				},
			},
			wantError: true,
		},
		{
			name: "invalid_filter_number",
			config: InterfaceConfig{
				Name:           "lan1",
				SecureFilterIn: []int{0},
			},
			wantError: true,
		},
		{
			name: "invalid_mtu_too_small",
			config: InterfaceConfig{
				Name: "lan1",
				MTU:  50,
			},
			wantError: true,
		},
		{
			name: "invalid_mtu_too_large",
			config: InterfaceConfig{
				Name: "lan1",
				MTU:  70000,
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateInterfaceConfig(tc.config)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateInterfaceConfig() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}

// TestInterfaceConfigRoundTrip_InterfaceNameValidation tests interface name validation
func TestInterfaceConfigRoundTrip_InterfaceNameValidation(t *testing.T) {
	testCases := []struct {
		name      string
		wantError bool
	}{
		{"lan1", false},
		{"lan2", false},
		{"bridge1", false},
		{"pp1", false},
		{"tunnel1", false},
		{"invalid", true},
		{"lan", true},
		{"", true},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateInterfaceName(tc.name)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateInterfaceName(%q) error = %v, wantError %v", tc.name, err, tc.wantError)
			}
		})
	}
}
