// Code generated by specgen. DO NOT EDIT.
// Source: specs/dns/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestDNSRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestDNSRoundTrip_Parse(t *testing.T) {
	parser := NewDNSParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *DNSConfig)
	}{
		{
			name: "dns_server_single",
			rtx:  "dns server 8.8.8.8",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if len(config.NameServers) != 1 {
					t.Errorf("NameServers count = %v, want 1", len(config.NameServers))
					return
				}
				if config.NameServers[0] != "8.8.8.8" {
					t.Errorf("NameServers[0] = %v, want 8.8.8.8", config.NameServers[0])
				}
			},
		},
		{
			name: "dns_server_multiple",
			rtx:  "dns server 8.8.8.8 8.8.4.4",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if len(config.NameServers) != 2 {
					t.Errorf("NameServers count = %v, want 2", len(config.NameServers))
					return
				}
				if config.NameServers[0] != "8.8.8.8" {
					t.Errorf("NameServers[0] = %v, want 8.8.8.8", config.NameServers[0])
				}
				if config.NameServers[1] != "8.8.4.4" {
					t.Errorf("NameServers[1] = %v, want 8.8.4.4", config.NameServers[1])
				}
			},
		},
		{
			name: "dns_domain_lookup_on",
			rtx:  "dns domain lookup on",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if config.DomainLookup != true {
					t.Errorf("DomainLookup = %v, want true", config.DomainLookup)
				}
			},
		},
		{
			name: "dns_domain_lookup_off",
			rtx:  "dns domain lookup off",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if config.DomainLookup != false {
					t.Errorf("DomainLookup = %v, want false", config.DomainLookup)
				}
			},
		},
		{
			name: "dns_service_on",
			rtx:  "dns service on",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if config.ServiceOn != true {
					t.Errorf("ServiceOn = %v, want true", config.ServiceOn)
				}
			},
		},
		{
			name: "dns_service_recursive",
			rtx:  "dns service recursive",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if config.ServiceOn != true {
					t.Errorf("ServiceOn = %v, want true (recursive)", config.ServiceOn)
				}
			},
		},
		{
			name: "dns_private_spoof_on",
			rtx:  "dns private address spoof on",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if config.PrivateSpoof != true {
					t.Errorf("PrivateSpoof = %v, want true", config.PrivateSpoof)
				}
			},
		},
		{
			name: "dns_static",
			rtx:  "dns static myhost.local 192.168.1.100",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if len(config.Hosts) != 1 {
					t.Errorf("Hosts count = %v, want 1", len(config.Hosts))
					return
				}
				if config.Hosts[0].Name != "myhost.local" {
					t.Errorf("Hosts[0].Name = %v, want myhost.local", config.Hosts[0].Name)
				}
				if config.Hosts[0].Address != "192.168.1.100" {
					t.Errorf("Hosts[0].Address = %v, want 192.168.1.100", config.Hosts[0].Address)
				}
			},
		},
		{
			name: "dns_server_select_basic",
			rtx:  "dns server select 1 8.8.8.8 .",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if len(config.ServerSelect) != 1 {
					t.Errorf("ServerSelect count = %v, want 1", len(config.ServerSelect))
					return
				}
				sel := config.ServerSelect[0]
				if sel.ID != 1 {
					t.Errorf("ServerSelect[0].ID = %v, want 1", sel.ID)
				}
				if len(sel.Servers) != 1 || sel.Servers[0].Address != "8.8.8.8" {
					t.Errorf("ServerSelect[0].Servers = %v, want [8.8.8.8]", sel.Servers)
				}
				if sel.QueryPattern != "." {
					t.Errorf("ServerSelect[0].QueryPattern = %v, want .", sel.QueryPattern)
				}
			},
		},
		{
			name: "dns_server_select_with_edns",
			rtx:  "dns server select 1 8.8.8.8 edns=on .",
			checkFunc: func(t *testing.T, config *DNSConfig) {
				if len(config.ServerSelect) != 1 {
					t.Errorf("ServerSelect count = %v, want 1", len(config.ServerSelect))
					return
				}
				sel := config.ServerSelect[0]
				if len(sel.Servers) != 1 || !sel.Servers[0].EDNS {
					t.Errorf("EDNS should be enabled for server")
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParseDNSConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseDNSConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestDNSRoundTrip_Build tests Terraform value -> RTX command conversion
func TestDNSRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "dns_server_single",
			buildFunc: func() string {
				return BuildDNSServerCommand([]string{"8.8.8.8"})
			},
			expectedRTX: "dns server 8.8.8.8",
		},
		{
			name: "dns_server_multiple",
			buildFunc: func() string {
				return BuildDNSServerCommand([]string{"8.8.8.8", "8.8.4.4"})
			},
			expectedRTX: "dns server 8.8.8.8 8.8.4.4",
		},
		{
			name: "dns_domain_lookup_on",
			buildFunc: func() string {
				return BuildDNSDomainLookupCommand(true)
			},
			expectedRTX: "dns domain lookup on",
		},
		{
			name: "dns_domain_lookup_off",
			buildFunc: func() string {
				return BuildDNSDomainLookupCommand(false)
			},
			expectedRTX: "no dns domain lookup",
		},
		{
			name: "dns_service_on",
			buildFunc: func() string {
				return BuildDNSServiceCommand(true)
			},
			expectedRTX: "dns service recursive",
		},
		{
			name: "dns_service_off",
			buildFunc: func() string {
				return BuildDNSServiceCommand(false)
			},
			expectedRTX: "dns service off",
		},
		{
			name: "dns_private_spoof_on",
			buildFunc: func() string {
				return BuildDNSPrivateSpoofCommand(true)
			},
			expectedRTX: "dns private address spoof on",
		},
		{
			name: "dns_private_spoof_off",
			buildFunc: func() string {
				return BuildDNSPrivateSpoofCommand(false)
			},
			expectedRTX: "dns private address spoof off",
		},
		{
			name: "dns_static",
			buildFunc: func() string {
				return BuildDNSStaticCommand(DNSHost{Name: "myhost.local", Address: "192.168.1.100"})
			},
			expectedRTX: "dns static myhost.local 192.168.1.100",
		},
		{
			name: "dns_domain_name",
			buildFunc: func() string {
				return BuildDNSDomainNameCommand("example.com")
			},
			expectedRTX: "dns domain example.com",
		},
		{
			name: "dns_server_select_basic",
			buildFunc: func() string {
				return BuildDNSServerSelectCommand(DNSServerSelect{
					ID:           1,
					Servers:      []DNSServer{{Address: "8.8.8.8", EDNS: false}},
					QueryPattern: ".",
				})
			},
			expectedRTX: "dns server select 1 8.8.8.8 .",
		},
		{
			name: "dns_server_select_with_edns",
			buildFunc: func() string {
				return BuildDNSServerSelectCommand(DNSServerSelect{
					ID:           1,
					Servers:      []DNSServer{{Address: "8.8.8.8", EDNS: true}},
					QueryPattern: ".",
				})
			},
			expectedRTX: "dns server select 1 8.8.8.8 edns=on .",
		},
		{
			name: "delete_dns_server",
			buildFunc: func() string {
				return BuildDeleteDNSServerCommand()
			},
			expectedRTX: "no dns server",
		},
		{
			name: "delete_dns_static",
			buildFunc: func() string {
				return BuildDeleteDNSStaticCommand("myhost.local")
			},
			expectedRTX: "no dns static myhost.local",
		},
		{
			name: "delete_dns_server_select",
			buildFunc: func() string {
				return BuildDeleteDNSServerSelectCommand(1)
			},
			expectedRTX: "no dns server select 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestDNSRoundTrip_ParseBuildParse tests full round-trip
func TestDNSRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewDNSParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "dns_server_single",
			rtx:  "dns server 8.8.8.8",
		},
		{
			name: "dns_static",
			rtx:  "dns static myhost.local 192.168.1.100",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			config, err := parser.ParseDNSConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseDNSConfig(%q) error = %v", tc.rtx, err)
			}

			// Step 2: Build back to RTX command based on what was parsed
			var rebuiltRTX string
			switch tc.name {
			case "dns_server_single":
				rebuiltRTX = BuildDNSServerCommand(config.NameServers)
			case "dns_static":
				if len(config.Hosts) > 0 {
					rebuiltRTX = BuildDNSStaticCommand(config.Hosts[0])
				}
			}

			// Step 3: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}

			// Step 4: Parse the rebuilt command
			config2, err := parser.ParseDNSConfig(rebuiltRTX)
			if err != nil {
				t.Fatalf("ParseDNSConfig(%q) error = %v", rebuiltRTX, err)
			}

			// Verify key fields match
			if tc.name == "dns_server_single" {
				if len(config.NameServers) != len(config2.NameServers) {
					t.Errorf("NameServers count mismatch: %v != %v", len(config.NameServers), len(config2.NameServers))
				}
			}
		})
	}
}
