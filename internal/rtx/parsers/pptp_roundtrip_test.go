// Code generated by specgen. DO NOT EDIT.
// Source: specs/pptp/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestPPTPRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestPPTPRoundTrip_Parse(t *testing.T) {
	parser := NewPPTPParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, config *PPTPConfig)
	}{
		{
			name: "pptp_service_on",
			rtx:  "pptp service on",
			checkFunc: func(t *testing.T, config *PPTPConfig) {
				if !config.Enabled {
					t.Errorf("Enabled = %v, want true", config.Enabled)
				}
			},
		},
		{
			name: "pptp_service_off",
			rtx:  "pptp service off",
			checkFunc: func(t *testing.T, config *PPTPConfig) {
				if config.Enabled {
					t.Errorf("Enabled = %v, want false", config.Enabled)
				}
			},
		},
		{
			name: "pptp_with_disconnect_time",
			rtx: `pptp service on
pptp tunnel disconnect time 300`,
			checkFunc: func(t *testing.T, config *PPTPConfig) {
				if config.DisconnectTime != 300 {
					t.Errorf("DisconnectTime = %v, want 300", config.DisconnectTime)
				}
			},
		},
		{
			name: "pptp_with_keepalive",
			rtx: `pptp service on
pptp keepalive use on`,
			checkFunc: func(t *testing.T, config *PPTPConfig) {
				if !config.KeepaliveEnabled {
					t.Errorf("KeepaliveEnabled = %v, want true", config.KeepaliveEnabled)
				}
			},
		},
		{
			name: "pptp_with_auth",
			rtx: `pptp service on
pp select anonymous
pp auth accept mschap-v2
pp auth myname admin secretpass`,
			checkFunc: func(t *testing.T, config *PPTPConfig) {
				if config.Authentication == nil {
					t.Errorf("Authentication should not be nil")
					return
				}
				if config.Authentication.Method != "mschap-v2" {
					t.Errorf("Auth Method = %v, want mschap-v2", config.Authentication.Method)
				}
				if config.Authentication.Username != "admin" {
					t.Errorf("Username = %v, want admin", config.Authentication.Username)
				}
			},
		},
		{
			name: "pptp_with_encryption",
			rtx: `pptp service on
pp select anonymous
ppp ccp type mppe-128`,
			checkFunc: func(t *testing.T, config *PPTPConfig) {
				if config.Encryption == nil {
					t.Errorf("Encryption should not be nil")
					return
				}
				if config.Encryption.MPPEBits != 128 {
					t.Errorf("MPPEBits = %v, want 128", config.Encryption.MPPEBits)
				}
			},
		},
		{
			name: "pptp_with_ip_pool",
			rtx: `pptp service on
pp select anonymous
ip pp remote address pool 192.168.100.10-192.168.100.50`,
			checkFunc: func(t *testing.T, config *PPTPConfig) {
				if config.IPPool == nil {
					t.Errorf("IPPool should not be nil")
					return
				}
				if config.IPPool.Start != "192.168.100.10" {
					t.Errorf("IPPool Start = %v, want 192.168.100.10", config.IPPool.Start)
				}
				if config.IPPool.End != "192.168.100.50" {
					t.Errorf("IPPool End = %v, want 192.168.100.50", config.IPPool.End)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			config, err := parser.ParsePPTPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParsePPTPConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, config)
		})
	}
}

// TestPPTPRoundTrip_Build tests Terraform value -> RTX command conversion
func TestPPTPRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "pptp_service_on",
			buildFunc: func() string {
				return BuildPPTPServiceCommand(true)
			},
			expectedRTX: "pptp service on",
		},
		{
			name: "pptp_service_off",
			buildFunc: func() string {
				return BuildPPTPServiceCommand(false)
			},
			expectedRTX: "pptp service off",
		},
		{
			name: "pptp_disconnect_time",
			buildFunc: func() string {
				return BuildPPTPTunnelDisconnectTimeCommand(300)
			},
			expectedRTX: "pptp tunnel disconnect time 300",
		},
		{
			name: "pptp_keepalive_on",
			buildFunc: func() string {
				return BuildPPTPKeepaliveCommand(true)
			},
			expectedRTX: "pptp keepalive use on",
		},
		{
			name: "pptp_keepalive_off",
			buildFunc: func() string {
				return BuildPPTPKeepaliveCommand(false)
			},
			expectedRTX: "pptp keepalive use off",
		},
		{
			name: "pptp_auth_accept",
			buildFunc: func() string {
				return BuildPPTPAuthAcceptCommand("mschap-v2")
			},
			expectedRTX: "pp auth accept mschap-v2",
		},
		{
			name: "pptp_auth_myname",
			buildFunc: func() string {
				return BuildPPTPAuthMynameCommand("admin", "secretpass")
			},
			expectedRTX: "pp auth myname admin secretpass",
		},
		{
			name: "pptp_ccp_mppe_128",
			buildFunc: func() string {
				return BuildPPPCCPTypeCommand(PPTPEncryption{MPPEBits: 128})
			},
			expectedRTX: "ppp ccp type mppe-128",
		},
		{
			name: "pptp_ccp_mppe_40",
			buildFunc: func() string {
				return BuildPPPCCPTypeCommand(PPTPEncryption{MPPEBits: 40})
			},
			expectedRTX: "ppp ccp type mppe-40",
		},
		{
			name: "pptp_ccp_mppe_56",
			buildFunc: func() string {
				return BuildPPPCCPTypeCommand(PPTPEncryption{MPPEBits: 56})
			},
			expectedRTX: "ppp ccp type mppe-56",
		},
		{
			name: "pptp_ccp_mppe_require",
			buildFunc: func() string {
				return BuildPPPCCPTypeCommand(PPTPEncryption{MPPEBits: 128, Required: true})
			},
			expectedRTX: "ppp ccp type mppe-128 require",
		},
		{
			name: "pptp_ip_pool",
			buildFunc: func() string {
				return BuildPPTPIPPoolCommand("192.168.100.10", "192.168.100.50")
			},
			expectedRTX: "ip pp remote address pool 192.168.100.10-192.168.100.50",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestPPTPRoundTrip_ParseBuildParse tests full round-trip
func TestPPTPRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewPPTPParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "pptp_service_on",
			rtx:  "pptp service on",
		},
		{
			name: "pptp_service_off",
			rtx:  "pptp service off",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			config, err := parser.ParsePPTPConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParsePPTPConfig(%q) error = %v", tc.rtx, err)
			}

			// Step 2: Build back to RTX command
			rebuiltRTX := BuildPPTPServiceCommand(config.Enabled)

			// Step 3: Verify the rebuilt command matches the original
			expectedCmd := "pptp service on"
			if !config.Enabled {
				expectedCmd = "pptp service off"
			}
			if rebuiltRTX != expectedCmd {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}

			// Step 4: Parse the rebuilt command
			config2, err := parser.ParsePPTPConfig(rebuiltRTX)
			if err != nil {
				t.Fatalf("ParsePPTPConfig(%q) error = %v", rebuiltRTX, err)
			}

			// Verify key field matches
			if config.Enabled != config2.Enabled {
				t.Errorf("Enabled mismatch: %v != %v", config.Enabled, config2.Enabled)
			}
		})
	}
}

// TestPPTPRoundTrip_Delete tests delete command generation
func TestPPTPRoundTrip_Delete(t *testing.T) {
	commands := BuildDeletePPTPCommand()

	if len(commands) == 0 {
		t.Errorf("Expected delete commands, got empty slice")
		return
	}

	// Verify pptp service off is in the commands
	found := false
	for _, cmd := range commands {
		if cmd == "pptp service off" {
			found = true
			break
		}
	}
	if !found {
		t.Errorf("Expected 'pptp service off' in delete commands")
	}
}
