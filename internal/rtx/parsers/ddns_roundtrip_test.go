// Code generated by specgen. DO NOT EDIT.
// Source: specs/ddns/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"strings"
	"testing"
)

// TestDDNSRoundTrip_ParseNetVolante tests RTX command -> Terraform value conversion for NetVolante DNS
func TestDDNSRoundTrip_ParseNetVolante(t *testing.T) {
	parser := NewDDNSParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, configs []NetVolanteConfig)
	}{
		{
			name: "netvolante_hostname",
			rtx:  "netvolante-dns hostname host pp 1 myhost.aa0.netvolante.jp",
			checkFunc: func(t *testing.T, configs []NetVolanteConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if configs[0].Hostname != "myhost.aa0.netvolante.jp" {
					t.Errorf("Hostname = %v, want myhost.aa0.netvolante.jp", configs[0].Hostname)
				}
			},
		},
		{
			name: "netvolante_with_ipv6",
			rtx: `netvolante-dns hostname host lan1 myhost.aa0.netvolante.jp
netvolante-dns use ipv6 lan1 on`,
			checkFunc: func(t *testing.T, configs []NetVolanteConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if !configs[0].IPv6 {
					t.Errorf("IPv6 = %v, want true", configs[0].IPv6)
				}
			},
		},
		{
			name: "netvolante_with_auto_hostname",
			rtx: `netvolante-dns hostname host lan1 myhost.aa0.netvolante.jp
netvolante-dns auto hostname lan1 on`,
			checkFunc: func(t *testing.T, configs []NetVolanteConfig) {
				if len(configs) != 1 {
					t.Errorf("Configs count = %v, want 1", len(configs))
					return
				}
				if !configs[0].AutoHostname {
					t.Errorf("AutoHostname = %v, want true", configs[0].AutoHostname)
				}
			},
		},
		{
			name: "empty_config",
			rtx:  "",
			checkFunc: func(t *testing.T, configs []NetVolanteConfig) {
				if len(configs) != 0 {
					t.Errorf("Configs count = %v, want 0", len(configs))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			configs, err := parser.ParseNetVolanteDNS(tc.rtx)
			if err != nil {
				t.Fatalf("ParseNetVolanteDNS(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, configs)
		})
	}
}

// TestDDNSRoundTrip_BuildNetVolante tests Terraform value -> RTX command conversion for NetVolante DNS
func TestDDNSRoundTrip_BuildNetVolante(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "netvolante_hostname",
			buildFunc: func() string {
				return BuildNetVolanteHostnameCommand("pp 1", "myhost.aa0.netvolante.jp")
			},
			expectedRTX: "netvolante-dns hostname host pp 1 myhost.aa0.netvolante.jp",
		},
		{
			name: "netvolante_server",
			buildFunc: func() string {
				return BuildNetVolanteServerCommand(2)
			},
			expectedRTX: "netvolante-dns server 2",
		},
		{
			name: "netvolante_timeout",
			buildFunc: func() string {
				return BuildNetVolanteTimeoutCommand(120)
			},
			expectedRTX: "netvolante-dns timeout 120",
		},
		{
			name: "netvolante_ipv6_on",
			buildFunc: func() string {
				return BuildNetVolanteIPv6Command("lan1", true)
			},
			expectedRTX: "netvolante-dns use ipv6 lan1 on",
		},
		{
			name: "netvolante_ipv6_off",
			buildFunc: func() string {
				return BuildNetVolanteIPv6Command("lan1", false)
			},
			expectedRTX: "netvolante-dns use ipv6 lan1 off",
		},
		{
			name: "netvolante_auto_hostname_on",
			buildFunc: func() string {
				return BuildNetVolanteAutoHostnameCommand("lan1", true)
			},
			expectedRTX: "netvolante-dns auto hostname lan1 on",
		},
		{
			name: "netvolante_auto_hostname_off",
			buildFunc: func() string {
				return BuildNetVolanteAutoHostnameCommand("lan1", false)
			},
			expectedRTX: "netvolante-dns auto hostname lan1 off",
		},
		{
			name: "netvolante_use_on",
			buildFunc: func() string {
				return BuildNetVolanteUseCommand("lan1", true)
			},
			expectedRTX: "netvolante-dns use lan1 on",
		},
		{
			name: "netvolante_use_off",
			buildFunc: func() string {
				return BuildNetVolanteUseCommand("lan1", false)
			},
			expectedRTX: "netvolante-dns use lan1 off",
		},
		{
			name: "netvolante_go",
			buildFunc: func() string {
				return BuildNetVolanteGoCommand("pp 1")
			},
			expectedRTX: "netvolante-dns go pp 1",
		},
		{
			name: "delete_netvolante_hostname",
			buildFunc: func() string {
				return BuildDeleteNetVolanteHostnameCommand("pp 1")
			},
			expectedRTX: "no netvolante-dns hostname host pp 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestDDNSRoundTrip_BuildCustomDDNS tests Terraform value -> RTX command conversion for custom DDNS
func TestDDNSRoundTrip_BuildCustomDDNS(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "ddns_url",
			buildFunc: func() string {
				return BuildDDNSURLCommand(1, "https://example.com/update")
			},
			expectedRTX: "ddns server url 1 https://example.com/update",
		},
		{
			name: "ddns_hostname",
			buildFunc: func() string {
				return BuildDDNSHostnameCommand(1, "myhost.example.com")
			},
			expectedRTX: "ddns server hostname 1 myhost.example.com",
		},
		{
			name: "ddns_user",
			buildFunc: func() string {
				return BuildDDNSUserCommand(1, "username", "password")
			},
			expectedRTX: "ddns server user 1 username password",
		},
		{
			name: "ddns_go",
			buildFunc: func() string {
				return BuildDDNSGoCommand(1)
			},
			expectedRTX: "ddns server go 1",
		},
		{
			name: "delete_ddns_url",
			buildFunc: func() string {
				return BuildDeleteDDNSURLCommand(1)
			},
			expectedRTX: "no ddns server url 1",
		},
		{
			name: "delete_ddns_hostname",
			buildFunc: func() string {
				return BuildDeleteDDNSHostnameCommand(1)
			},
			expectedRTX: "no ddns server hostname 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestDDNSRoundTrip_BuildNetVolanteCommands tests full command generation
func TestDDNSRoundTrip_BuildNetVolanteCommands(t *testing.T) {
	config := NetVolanteConfig{
		Interface:    "pp 1",
		Hostname:     "myhost.aa0.netvolante.jp",
		Server:       2,
		Timeout:      120,
		IPv6:         true,
		AutoHostname: true,
		Use:          true,
	}

	commands := BuildNetVolanteCommand(config)

	if len(commands) == 0 {
		t.Errorf("Expected commands, got empty slice")
		return
	}

	// Check that hostname command is present
	foundHostname := false
	foundServer := false
	foundIPv6 := false
	for _, cmd := range commands {
		if strings.Contains(cmd, "hostname host") {
			foundHostname = true
		}
		if strings.Contains(cmd, "server 2") {
			foundServer = true
		}
		if strings.Contains(cmd, "ipv6") && strings.Contains(cmd, "on") {
			foundIPv6 = true
		}
	}

	if !foundHostname {
		t.Errorf("Expected hostname command in output")
	}
	if !foundServer {
		t.Errorf("Expected server command in output")
	}
	if !foundIPv6 {
		t.Errorf("Expected IPv6 command in output")
	}
}

// TestDDNSRoundTrip_Validation tests DDNS validation functions
func TestDDNSRoundTrip_Validation(t *testing.T) {
	t.Run("valid_hostnames", func(t *testing.T) {
		validHostnames := []string{
			"myhost.example.com",
			"test.aa0.netvolante.jp",
			"a1.b2.c3.example.org",
			"host123",
		}
		for _, hostname := range validHostnames {
			if err := ValidateHostname(hostname); err != nil {
				t.Errorf("ValidateHostname(%q) unexpected error: %v", hostname, err)
			}
		}
	})

	t.Run("invalid_hostnames", func(t *testing.T) {
		invalidHostnames := []string{
			"",
			"-invalid.com",
			"invalid-.com",
			"inv..alid.com",
		}
		for _, hostname := range invalidHostnames {
			if err := ValidateHostname(hostname); err == nil {
				t.Errorf("ValidateHostname(%q) expected error, got nil", hostname)
			}
		}
	})

	t.Run("valid_urls", func(t *testing.T) {
		validURLs := []string{
			"http://example.com/update",
			"https://api.example.com/ddns",
			"https://dyn.example.org/nic/update",
		}
		for _, url := range validURLs {
			if err := ValidateDDNSURL(url); err != nil {
				t.Errorf("ValidateDDNSURL(%q) unexpected error: %v", url, err)
			}
		}
	})

	t.Run("invalid_urls", func(t *testing.T) {
		invalidURLs := []string{
			"",
			"ftp://example.com",
			"example.com/update",
		}
		for _, url := range invalidURLs {
			if err := ValidateDDNSURL(url); err == nil {
				t.Errorf("ValidateDDNSURL(%q) expected error, got nil", url)
			}
		}
	})
}

// TestDDNSRoundTrip_EdgeCases tests edge cases
func TestDDNSRoundTrip_EdgeCases(t *testing.T) {
	t.Run("empty_interface", func(t *testing.T) {
		cmd := BuildNetVolanteHostnameCommand("", "hostname")
		if cmd != "" {
			t.Errorf("Expected empty command for empty interface, got %q", cmd)
		}
	})

	t.Run("empty_hostname", func(t *testing.T) {
		cmd := BuildNetVolanteHostnameCommand("lan1", "")
		if cmd != "" {
			t.Errorf("Expected empty command for empty hostname, got %q", cmd)
		}
	})

	t.Run("invalid_server", func(t *testing.T) {
		cmd := BuildNetVolanteServerCommand(3)
		if cmd != "" {
			t.Errorf("Expected empty command for invalid server, got %q", cmd)
		}
	})

	t.Run("invalid_ddns_id_zero", func(t *testing.T) {
		cmd := BuildDDNSURLCommand(0, "https://example.com")
		if cmd != "" {
			t.Errorf("Expected empty command for invalid ID, got %q", cmd)
		}
	})

	t.Run("invalid_ddns_id_too_high", func(t *testing.T) {
		cmd := BuildDDNSURLCommand(5, "https://example.com")
		if cmd != "" {
			t.Errorf("Expected empty command for invalid ID, got %q", cmd)
		}
	})
}
