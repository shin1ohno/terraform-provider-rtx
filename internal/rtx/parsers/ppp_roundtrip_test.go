// Code generated by specgen. DO NOT EDIT.
// Source: specs/ppp/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestPPPRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestPPPRoundTrip_Parse(t *testing.T) {
	parser := NewPPPParser()

	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, configs []PPPoEConfig)
	}{
		{
			name: "pppoe_basic",
			rtx: `pp select 1
pppoe use lan2
pp auth accept chap
pp auth myname user@isp password123
pp enable 1`,
			checkFunc: func(t *testing.T, configs []PPPoEConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				c := configs[0]
				if c.Number != 1 {
					t.Errorf("Number = %v, want 1", c.Number)
				}
				if c.Interface != "lan2" {
					t.Errorf("Interface = %v, want lan2", c.Interface)
				}
				if c.Authentication == nil {
					t.Errorf("Authentication should not be nil")
					return
				}
				if c.Authentication.Method != "chap" {
					t.Errorf("Auth Method = %v, want chap", c.Authentication.Method)
				}
				if c.Authentication.Username != "user@isp" {
					t.Errorf("Username = %v, want user@isp", c.Authentication.Username)
				}
				if !c.Enabled {
					t.Errorf("Enabled = %v, want true", c.Enabled)
				}
			},
		},
		{
			name: "pppoe_with_ip_config",
			rtx: `pp select 2
pppoe use lan2
pp auth accept pap
pp auth myname myuser mypass
ip pp mtu 1454
ip pp tcp mss limit 1414
ip pp nat descriptor 1000
pp enable 2`,
			checkFunc: func(t *testing.T, configs []PPPoEConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				c := configs[0]
				if c.IPConfig == nil {
					t.Errorf("IPConfig should not be nil")
					return
				}
				if c.IPConfig.MTU != 1454 {
					t.Errorf("MTU = %v, want 1454", c.IPConfig.MTU)
				}
				if c.IPConfig.TCPMSSLimit != 1414 {
					t.Errorf("TCPMSSLimit = %v, want 1414", c.IPConfig.TCPMSSLimit)
				}
				if c.IPConfig.NATDescriptor != 1000 {
					t.Errorf("NATDescriptor = %v, want 1000", c.IPConfig.NATDescriptor)
				}
			},
		},
		{
			name: "pppoe_always_on",
			rtx: `pp select 3
pppoe use lan2
pp auth accept mschap-v2
pp auth myname testuser testpass
pp always-on on
pp enable 3`,
			checkFunc: func(t *testing.T, configs []PPPoEConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				if !configs[0].AlwaysOn {
					t.Errorf("AlwaysOn = %v, want true", configs[0].AlwaysOn)
				}
			},
		},
		{
			name: "pppoe_with_description",
			rtx: `pp select 4
description pp ISP Connection
pppoe use lan2
pp auth accept chap
pp auth myname user pass
pp enable 4`,
			checkFunc: func(t *testing.T, configs []PPPoEConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				if configs[0].Name != "ISP Connection" {
					t.Errorf("Name = %v, want 'ISP Connection'", configs[0].Name)
				}
			},
		},
		{
			name: "pppoe_with_disconnect_timeout",
			rtx: `pp select 5
pppoe use lan2
pp auth accept chap
pp auth myname user pass
pp disconnect time 300
pp enable 5`,
			checkFunc: func(t *testing.T, configs []PPPoEConfig) {
				if len(configs) != 1 {
					t.Errorf("Config count = %v, want 1", len(configs))
					return
				}
				if configs[0].DisconnectTimeout != 300 {
					t.Errorf("DisconnectTimeout = %v, want 300", configs[0].DisconnectTimeout)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			configs, err := parser.ParsePPPoEConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParsePPPoEConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, configs)
		})
	}
}

// TestPPPRoundTrip_Build tests Terraform value -> RTX command conversion
func TestPPPRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "pp_select",
			buildFunc: func() string {
				return BuildPPSelectCommand(1)
			},
			expectedRTX: "pp select 1",
		},
		{
			name: "pp_description",
			buildFunc: func() string {
				return BuildPPDescriptionCommand("ISP Connection")
			},
			expectedRTX: "description pp ISP Connection",
		},
		{
			name: "pppoe_use",
			buildFunc: func() string {
				return BuildPPPoEUseCommand("lan2")
			},
			expectedRTX: "pppoe use lan2",
		},
		{
			name: "pp_bind",
			buildFunc: func() string {
				return BuildPPBindCommand("tunnel1")
			},
			expectedRTX: "pp bind tunnel1",
		},
		{
			name: "pppoe_service_name",
			buildFunc: func() string {
				return BuildPPPoEServiceNameCommand("flets")
			},
			expectedRTX: "pppoe service-name flets",
		},
		{
			name: "pp_auth_accept",
			buildFunc: func() string {
				return BuildPPPAuthAcceptCommand("chap")
			},
			expectedRTX: "pp auth accept chap",
		},
		{
			name: "pp_auth_myname",
			buildFunc: func() string {
				return BuildPPPAuthMynameCommand("user@isp", "password123")
			},
			expectedRTX: "pp auth myname user@isp password123",
		},
		{
			name: "pp_always_on_on",
			buildFunc: func() string {
				return BuildPPAlwaysOnCommand(true)
			},
			expectedRTX: "pp always-on on",
		},
		{
			name: "pp_always_on_off",
			buildFunc: func() string {
				return BuildPPAlwaysOnCommand(false)
			},
			expectedRTX: "pp always-on off",
		},
		{
			name: "pp_disconnect_time",
			buildFunc: func() string {
				return BuildPPDisconnectTimeCommand(300)
			},
			expectedRTX: "pp disconnect time 300",
		},
		{
			name: "pp_disconnect_time_off",
			buildFunc: func() string {
				return BuildPPDisconnectTimeCommand(0)
			},
			expectedRTX: "pp disconnect time off",
		},
		{
			name: "pp_enable",
			buildFunc: func() string {
				return BuildPPEnableCommand(1)
			},
			expectedRTX: "pp enable 1",
		},
		{
			name: "pp_disable",
			buildFunc: func() string {
				return BuildPPDisableCommand(1)
			},
			expectedRTX: "pp disable 1",
		},
		{
			name: "ip_pp_address",
			buildFunc: func() string {
				return BuildIPPPAddressCommand("192.168.1.1/24")
			},
			expectedRTX: "ip pp address 192.168.1.1/24",
		},
		{
			name: "ip_pp_mtu",
			buildFunc: func() string {
				return BuildIPPPMTUCommand(1454)
			},
			expectedRTX: "ip pp mtu 1454",
		},
		{
			name: "ip_pp_tcp_mss_limit",
			buildFunc: func() string {
				return BuildIPPPTCPMSSLimitCommand(1414)
			},
			expectedRTX: "ip pp tcp mss limit 1414",
		},
		{
			name: "ip_pp_nat_descriptor",
			buildFunc: func() string {
				return BuildIPPPNATDescriptorCommand(1000)
			},
			expectedRTX: "ip pp nat descriptor 1000",
		},
		{
			name: "delete_ip_pp_address",
			buildFunc: func() string {
				return BuildDeleteIPPPAddressCommand()
			},
			expectedRTX: "no ip pp address",
		},
		{
			name: "delete_ip_pp_mtu",
			buildFunc: func() string {
				return BuildDeleteIPPPMTUCommand()
			},
			expectedRTX: "no ip pp mtu",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestPPPRoundTrip_ParseBuildParse tests full round-trip
func TestPPPRoundTrip_ParseBuildParse(t *testing.T) {
	parser := NewPPPParser()

	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "pppoe_basic",
			rtx: `pp select 1
pppoe use lan2
pp auth accept chap
pp auth myname user@isp password123
pp always-on on
pp enable 1`,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX config
			configs, err := parser.ParsePPPoEConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParsePPPoEConfig(%q) error = %v", tc.rtx, err)
			}
			if len(configs) != 1 {
				t.Fatalf("Expected 1 config, got %d", len(configs))
			}
			config := configs[0]

			// Step 2: Build back to RTX commands
			commands := BuildPPPoECommand(config)
			if len(commands) == 0 {
				t.Fatalf("BuildPPPoECommand returned empty commands")
			}

			// Step 3: Verify key commands are present
			foundPPSelect := false
			foundPPPoEUse := false
			foundAuthAccept := false

			for _, cmd := range commands {
				if cmd == "pp select 1" {
					foundPPSelect = true
				}
				if cmd == "pppoe use lan2" {
					foundPPPoEUse = true
				}
				if cmd == "pp auth accept chap" {
					foundAuthAccept = true
				}
			}

			if !foundPPSelect {
				t.Errorf("Expected 'pp select 1' command")
			}
			if !foundPPPoEUse {
				t.Errorf("Expected 'pppoe use lan2' command")
			}
			if !foundAuthAccept {
				t.Errorf("Expected 'pp auth accept chap' command")
			}
		})
	}
}
