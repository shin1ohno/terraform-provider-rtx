// Code generated by specgen. DO NOT EDIT.
// Source: specs/nat/masquerade.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestNATMasqueradeRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestNATMasqueradeRoundTrip_Parse(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, nats []NATMasquerade)
	}{
		{
			name: "nat_type_masquerade",
			rtx:  "nat descriptor type 1 masquerade",
			checkFunc: func(t *testing.T, nats []NATMasquerade) {
				if len(nats) != 1 {
					t.Errorf("NATs count = %v, want 1", len(nats))
					return
				}
				if nats[0].DescriptorID != 1 {
					t.Errorf("DescriptorID = %v, want 1", nats[0].DescriptorID)
				}
			},
		},
		{
			name: "nat_outer_ipcp",
			rtx:  "nat descriptor address outer 1 ipcp",
			checkFunc: func(t *testing.T, nats []NATMasquerade) {
				if len(nats) != 1 {
					t.Errorf("NATs count = %v, want 1", len(nats))
					return
				}
				if nats[0].OuterAddress != "ipcp" {
					t.Errorf("OuterAddress = %v, want ipcp", nats[0].OuterAddress)
				}
			},
		},
		{
			name: "nat_outer_primary",
			rtx:  "nat descriptor address outer 1 primary",
			checkFunc: func(t *testing.T, nats []NATMasquerade) {
				if len(nats) != 1 {
					t.Errorf("NATs count = %v, want 1", len(nats))
					return
				}
				if nats[0].OuterAddress != "primary" {
					t.Errorf("OuterAddress = %v, want primary", nats[0].OuterAddress)
				}
			},
		},
		{
			name: "nat_inner_range",
			rtx:  "nat descriptor address inner 1 192.168.1.0-192.168.1.255",
			checkFunc: func(t *testing.T, nats []NATMasquerade) {
				if len(nats) != 1 {
					t.Errorf("NATs count = %v, want 1", len(nats))
					return
				}
				if nats[0].InnerNetwork != "192.168.1.0-192.168.1.255" {
					t.Errorf("InnerNetwork = %v, want 192.168.1.0-192.168.1.255", nats[0].InnerNetwork)
				}
			},
		},
		{
			name: "nat_static_tcp_same_port",
			rtx:  "nat descriptor masquerade static 1 1 192.168.1.100 tcp 80",
			checkFunc: func(t *testing.T, nats []NATMasquerade) {
				if len(nats) != 1 {
					t.Errorf("NATs count = %v, want 1", len(nats))
					return
				}
				if len(nats[0].StaticEntries) != 1 {
					t.Errorf("StaticEntries count = %v, want 1", len(nats[0].StaticEntries))
					return
				}
				e := nats[0].StaticEntries[0]
				if e.InsideLocal != "192.168.1.100" {
					t.Errorf("InsideLocal = %v, want 192.168.1.100", e.InsideLocal)
				}
				if e.Protocol != "tcp" {
					t.Errorf("Protocol = %v, want tcp", e.Protocol)
				}
				if e.InsideLocalPort == nil || *e.InsideLocalPort != 80 {
					t.Errorf("InsideLocalPort = %v, want 80", e.InsideLocalPort)
				}
			},
		},
		{
			name: "nat_static_tcp_diff_port",
			rtx:  "nat descriptor masquerade static 1 2 192.168.1.100 tcp 8080=80",
			checkFunc: func(t *testing.T, nats []NATMasquerade) {
				if len(nats) != 1 {
					t.Errorf("NATs count = %v, want 1", len(nats))
					return
				}
				if len(nats[0].StaticEntries) != 1 {
					t.Errorf("StaticEntries count = %v, want 1", len(nats[0].StaticEntries))
					return
				}
				e := nats[0].StaticEntries[0]
				if e.OutsideGlobalPort == nil || *e.OutsideGlobalPort != 8080 {
					t.Errorf("OutsideGlobalPort = %v, want 8080", e.OutsideGlobalPort)
				}
				if e.InsideLocalPort == nil || *e.InsideLocalPort != 80 {
					t.Errorf("InsideLocalPort = %v, want 80", e.InsideLocalPort)
				}
			},
		},
		{
			name: "nat_static_esp",
			rtx:  "nat descriptor masquerade static 1000 1 192.168.1.253 esp",
			checkFunc: func(t *testing.T, nats []NATMasquerade) {
				if len(nats) != 1 {
					t.Errorf("NATs count = %v, want 1", len(nats))
					return
				}
				if len(nats[0].StaticEntries) != 1 {
					t.Errorf("StaticEntries count = %v, want 1", len(nats[0].StaticEntries))
					return
				}
				e := nats[0].StaticEntries[0]
				if e.Protocol != "esp" {
					t.Errorf("Protocol = %v, want esp", e.Protocol)
				}
				if e.InsideLocalPort != nil {
					t.Errorf("InsideLocalPort should be nil for ESP, got %v", *e.InsideLocalPort)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			nats, err := ParseNATMasqueradeConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseNATMasqueradeConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, nats)
		})
	}
}

// TestNATMasqueradeRoundTrip_Build tests Terraform value -> RTX command conversion
func TestNATMasqueradeRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "nat_type_masquerade",
			buildFunc: func() string {
				return BuildNATDescriptorTypeMasqueradeCommand(1)
			},
			expectedRTX: "nat descriptor type 1 masquerade",
		},
		{
			name: "nat_outer_ipcp",
			buildFunc: func() string {
				return BuildNATDescriptorAddressOuterCommand(1, "ipcp")
			},
			expectedRTX: "nat descriptor address outer 1 ipcp",
		},
		{
			name: "nat_outer_primary",
			buildFunc: func() string {
				return BuildNATDescriptorAddressOuterCommand(1, "primary")
			},
			expectedRTX: "nat descriptor address outer 1 primary",
		},
		{
			name: "nat_inner_range",
			buildFunc: func() string {
				return BuildNATDescriptorAddressInnerCommand(1, "192.168.1.0-192.168.1.255")
			},
			expectedRTX: "nat descriptor address inner 1 192.168.1.0-192.168.1.255",
		},
		{
			name: "nat_static_tcp_same_port",
			buildFunc: func() string {
				port := 80
				return BuildNATMasqueradeStaticCommand(1, 1, MasqueradeStaticEntry{
					InsideLocal:       "192.168.1.100",
					InsideLocalPort:   &port,
					OutsideGlobal:     "ipcp",
					OutsideGlobalPort: &port,
					Protocol:          "tcp",
				})
			},
			expectedRTX: "nat descriptor masquerade static 1 1 192.168.1.100 tcp 80",
		},
		{
			name: "nat_static_tcp_diff_port",
			buildFunc: func() string {
				outerPort := 8080
				innerPort := 80
				return BuildNATMasqueradeStaticCommand(1, 2, MasqueradeStaticEntry{
					InsideLocal:       "192.168.1.100",
					InsideLocalPort:   &innerPort,
					OutsideGlobal:     "ipcp",
					OutsideGlobalPort: &outerPort,
					Protocol:          "tcp",
				})
			},
			expectedRTX: "nat descriptor masquerade static 1 2 192.168.1.100 tcp 8080=80",
		},
		{
			name: "nat_static_esp",
			buildFunc: func() string {
				return BuildNATMasqueradeStaticCommand(1000, 1, MasqueradeStaticEntry{
					InsideLocal:   "192.168.1.253",
					OutsideGlobal: "ipcp",
					Protocol:      "esp",
				})
			},
			expectedRTX: "nat descriptor masquerade static 1000 1 192.168.1.253 esp",
		},
		{
			name: "interface_nat_descriptor",
			buildFunc: func() string {
				return BuildInterfaceNATDescriptorCommand("pp 1", 1)
			},
			expectedRTX: "ip pp 1 nat descriptor 1",
		},
		{
			name: "delete_nat_masquerade",
			buildFunc: func() string {
				return BuildDeleteNATMasqueradeCommand(1)
			},
			expectedRTX: "no nat descriptor type 1",
		},
		{
			name: "delete_nat_static",
			buildFunc: func() string {
				return BuildDeleteNATMasqueradeStaticCommand(1, 1)
			},
			expectedRTX: "no nat descriptor masquerade static 1 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestNATMasqueradeRoundTrip_ParseBuildParse tests full round-trip
func TestNATMasqueradeRoundTrip_ParseBuildParse(t *testing.T) {
	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "nat_type",
			rtx:  "nat descriptor type 1 masquerade",
		},
		{
			name: "nat_outer",
			rtx:  "nat descriptor address outer 1 ipcp",
		},
		{
			name: "nat_inner",
			rtx:  "nat descriptor address inner 1 192.168.1.0-192.168.1.255",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse the RTX command
			nats, err := ParseNATMasqueradeConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseNATMasqueradeConfig(%q) error = %v", tc.rtx, err)
			}
			if len(nats) != 1 {
				t.Fatalf("Expected 1 NAT, got %d", len(nats))
			}
			nat := nats[0]

			// Step 2: Build back to RTX command
			var rebuiltRTX string
			switch tc.name {
			case "nat_type":
				rebuiltRTX = BuildNATDescriptorTypeMasqueradeCommand(nat.DescriptorID)
			case "nat_outer":
				rebuiltRTX = BuildNATDescriptorAddressOuterCommand(nat.DescriptorID, nat.OuterAddress)
			case "nat_inner":
				rebuiltRTX = BuildNATDescriptorAddressInnerCommand(nat.DescriptorID, nat.InnerNetwork)
			}

			// Step 3: Verify the rebuilt command matches the original
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}
		})
	}
}

// TestNATMasqueradeRoundTrip_StaticEntry tests static entry round-trip
func TestNATMasqueradeRoundTrip_StaticEntry(t *testing.T) {
	testCases := []struct {
		name string
		rtx  string
	}{
		{
			name: "tcp_same_port",
			rtx:  "nat descriptor masquerade static 1 1 192.168.1.100 tcp 80",
		},
		{
			name: "tcp_diff_port",
			rtx:  "nat descriptor masquerade static 1 2 192.168.1.100 tcp 8080=80",
		},
		{
			name: "esp_protocol",
			rtx:  "nat descriptor masquerade static 1000 1 192.168.1.253 esp",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Step 1: Parse
			nats, err := ParseNATMasqueradeConfig(tc.rtx)
			if err != nil {
				t.Fatalf("Parse error: %v", err)
			}
			if len(nats) != 1 || len(nats[0].StaticEntries) != 1 {
				t.Fatalf("Expected 1 NAT with 1 static entry")
			}
			nat := nats[0]
			entry := nat.StaticEntries[0]

			// Step 2: Build
			rebuiltRTX := BuildNATMasqueradeStaticCommand(nat.DescriptorID, entry.EntryNumber, entry)

			// Step 3: Verify
			if rebuiltRTX != tc.rtx {
				t.Errorf("Round-trip failed:\n  Original: %q\n  Rebuilt:  %q", tc.rtx, rebuiltRTX)
			}
		})
	}
}
