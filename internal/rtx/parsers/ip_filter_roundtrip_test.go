// Code generated by specgen. DO NOT EDIT.
// Source: specs/ip_filter/config.yaml
// This file tests RTX <-> Terraform round-trip conversions using actual parsers

package parsers

import (
	"testing"
)

// TestIPFilterRoundTrip_Parse tests RTX command -> Terraform value conversion
func TestIPFilterRoundTrip_Parse(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, filters []IPFilter)
	}{
		{
			name: "basic_pass_filter",
			rtx:  "ip filter 100 pass * * * * *",
			checkFunc: func(t *testing.T, filters []IPFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				f := filters[0]
				if f.Number != 100 {
					t.Errorf("Number = %v, want 100", f.Number)
				}
				if f.Action != "pass" {
					t.Errorf("Action = %v, want pass", f.Action)
				}
			},
		},
		{
			name: "reject_filter",
			rtx:  "ip filter 200 reject * * * * *",
			checkFunc: func(t *testing.T, filters []IPFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				if filters[0].Action != "reject" {
					t.Errorf("Action = %v, want reject", filters[0].Action)
				}
			},
		},
		{
			name: "filter_with_ports",
			rtx:  "ip filter 300 pass 192.168.1.0/24 * tcp * 80",
			checkFunc: func(t *testing.T, filters []IPFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				f := filters[0]
				if f.SourceAddress != "192.168.1.0/24" {
					t.Errorf("SourceAddress = %v, want 192.168.1.0/24", f.SourceAddress)
				}
				if f.Protocol != "tcp" {
					t.Errorf("Protocol = %v, want tcp", f.Protocol)
				}
				if f.DestPort != "80" {
					t.Errorf("DestPort = %v, want 80", f.DestPort)
				}
			},
		},
		{
			name: "filter_with_established",
			rtx:  "ip filter 400 pass * * tcp * * established",
			checkFunc: func(t *testing.T, filters []IPFilter) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				if !filters[0].Established {
					t.Errorf("Established = %v, want true", filters[0].Established)
				}
			},
		},
		{
			name: "multiple_filters",
			rtx: `ip filter 100 pass * * * * *
ip filter 200 reject * * icmp * *
ip filter 300 pass 192.168.1.0/24 * tcp * 22`,
			checkFunc: func(t *testing.T, filters []IPFilter) {
				if len(filters) != 3 {
					t.Errorf("Filters count = %v, want 3", len(filters))
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			filters, err := ParseIPFilterConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseIPFilterConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, filters)
		})
	}
}

// TestIPFilterRoundTrip_Build tests Terraform value -> RTX command conversion
func TestIPFilterRoundTrip_Build(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "basic_pass_filter",
			buildFunc: func() string {
				return BuildIPFilterCommand(IPFilter{
					Number:        100,
					Action:        "pass",
					SourceAddress: "*",
					DestAddress:   "*",
					Protocol:      "*",
				})
			},
			expectedRTX: "ip filter 100 pass * * *",
		},
		{
			name: "filter_with_ports",
			buildFunc: func() string {
				return BuildIPFilterCommand(IPFilter{
					Number:        200,
					Action:        "pass",
					SourceAddress: "192.168.1.0/24",
					DestAddress:   "*",
					Protocol:      "tcp",
					SourcePort:    "*",
					DestPort:      "80",
				})
			},
			expectedRTX: "ip filter 200 pass 192.168.1.0/24 * tcp * 80",
		},
		{
			name: "filter_with_established",
			buildFunc: func() string {
				return BuildIPFilterCommand(IPFilter{
					Number:        300,
					Action:        "pass",
					SourceAddress: "*",
					DestAddress:   "*",
					Protocol:      "tcp",
					Established:   true,
				})
			},
			expectedRTX: "ip filter 300 pass * * tcp established",
		},
		{
			name: "delete_filter",
			buildFunc: func() string {
				return BuildDeleteIPFilterCommand(100)
			},
			expectedRTX: "no ip filter 100",
		},
		{
			name: "interface_secure_filter",
			buildFunc: func() string {
				return BuildInterfaceSecureFilterCommand("lan1", "in", []int{100, 200, 300})
			},
			expectedRTX: "ip lan1 secure filter in 100 200 300",
		},
		{
			name: "delete_interface_secure_filter",
			buildFunc: func() string {
				return BuildDeleteInterfaceSecureFilterCommand("lan1", "in")
			},
			expectedRTX: "no ip lan1 secure filter in",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestIPFilterDynamicRoundTrip_Parse tests dynamic IP filter parsing
func TestIPFilterDynamicRoundTrip_Parse(t *testing.T) {
	testCases := []struct {
		name      string
		rtx       string
		checkFunc func(t *testing.T, filters []IPFilterDynamic)
	}{
		{
			name: "basic_dynamic_filter",
			rtx:  "ip filter dynamic 1 * * ftp",
			checkFunc: func(t *testing.T, filters []IPFilterDynamic) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				f := filters[0]
				if f.Number != 1 {
					t.Errorf("Number = %v, want 1", f.Number)
				}
				if f.Protocol != "ftp" {
					t.Errorf("Protocol = %v, want ftp", f.Protocol)
				}
			},
		},
		{
			name: "dynamic_filter_with_syslog",
			rtx:  "ip filter dynamic 2 * * www syslog on",
			checkFunc: func(t *testing.T, filters []IPFilterDynamic) {
				if len(filters) != 1 {
					t.Errorf("Filters count = %v, want 1", len(filters))
					return
				}
				if !filters[0].SyslogOn {
					t.Errorf("SyslogOn = %v, want true", filters[0].SyslogOn)
				}
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			filters, err := ParseIPFilterDynamicConfig(tc.rtx)
			if err != nil {
				t.Fatalf("ParseIPFilterDynamicConfig(%q) error = %v", tc.rtx, err)
			}
			tc.checkFunc(t, filters)
		})
	}
}

// TestIPFilterRoundTrip_BuildDynamic tests dynamic IP filter command building
func TestIPFilterRoundTrip_BuildDynamic(t *testing.T) {
	testCases := []struct {
		name        string
		buildFunc   func() string
		expectedRTX string
	}{
		{
			name: "basic_dynamic_filter",
			buildFunc: func() string {
				return BuildIPFilterDynamicCommand(IPFilterDynamic{
					Number:   1,
					Source:   "*",
					Dest:     "*",
					Protocol: "ftp",
				})
			},
			expectedRTX: "ip filter dynamic 1 * * ftp",
		},
		{
			name: "dynamic_filter_with_syslog",
			buildFunc: func() string {
				return BuildIPFilterDynamicCommand(IPFilterDynamic{
					Number:   2,
					Source:   "*",
					Dest:     "*",
					Protocol: "www",
					SyslogOn: true,
				})
			},
			expectedRTX: "ip filter dynamic 2 * * www syslog on",
		},
		{
			name: "delete_dynamic_filter",
			buildFunc: func() string {
				return BuildDeleteIPFilterDynamicCommand(1)
			},
			expectedRTX: "no ip filter dynamic 1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			got := tc.buildFunc()
			if got != tc.expectedRTX {
				t.Errorf("Build() = %q, want %q", got, tc.expectedRTX)
			}
		})
	}
}

// TestIPFilterRoundTrip_Validation tests IP filter validation functions
func TestIPFilterRoundTrip_Validation(t *testing.T) {
	testCases := []struct {
		name      string
		filter    IPFilter
		wantError bool
	}{
		{
			name: "valid_filter",
			filter: IPFilter{
				Number:        100,
				Action:        "pass",
				SourceAddress: "*",
				DestAddress:   "*",
				Protocol:      "tcp",
			},
			wantError: false,
		},
		{
			name: "invalid_number",
			filter: IPFilter{
				Number:        0,
				Action:        "pass",
				SourceAddress: "*",
				DestAddress:   "*",
				Protocol:      "tcp",
			},
			wantError: true,
		},
		{
			name: "invalid_action",
			filter: IPFilter{
				Number:        100,
				Action:        "invalid",
				SourceAddress: "*",
				DestAddress:   "*",
				Protocol:      "tcp",
			},
			wantError: true,
		},
		{
			name: "missing_source",
			filter: IPFilter{
				Number:        100,
				Action:        "pass",
				SourceAddress: "",
				DestAddress:   "*",
				Protocol:      "tcp",
			},
			wantError: true,
		},
		{
			name: "invalid_protocol",
			filter: IPFilter{
				Number:        100,
				Action:        "pass",
				SourceAddress: "*",
				DestAddress:   "*",
				Protocol:      "invalid",
			},
			wantError: true,
		},
		{
			name: "established_with_non_tcp",
			filter: IPFilter{
				Number:        100,
				Action:        "pass",
				SourceAddress: "*",
				DestAddress:   "*",
				Protocol:      "udp",
				Established:   true,
			},
			wantError: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			err := ValidateIPFilter(tc.filter)
			if (err != nil) != tc.wantError {
				t.Errorf("ValidateIPFilter() error = %v, wantError %v", err, tc.wantError)
			}
		})
	}
}
